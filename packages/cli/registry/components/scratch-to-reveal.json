{
  "name": "scratch-to-reveal",
  "dependencies": [
    "motion-v"
  ],
  "files": [
    {
      "path": "index.ts",
      "content": "export { default as ScratchToReveal } from \"./ScratchToReveal.vue\";\r\n"
    },
    {
      "path": "ScratchToReveal.vue",
      "content": "<template>\r\n  <Motion\r\n    ref=\"containerRef\"\r\n    :class=\"cn('relative select-none', props.class)\"\r\n    :style=\"{\r\n      width: containerWidth,\r\n      height: containerHeight,\r\n      cursor: cursorImg,\r\n    }\"\r\n    :initial=\"{\r\n      scale: 1,\r\n      rotate: [0, 10, -10, 10, -10, 0],\r\n    }\"\r\n    :transition=\"{ duration: 0.5 }\"\r\n  >\r\n    <canvas\r\n      ref=\"canvasRef\"\r\n      :width=\"width\"\r\n      :height=\"height\"\r\n      class=\"absolute left-0 top-0\"\r\n      @mousedown=\"handleMouseDown\"\r\n      @touchstart=\"handleTouchStart\"\r\n    />\r\n\r\n    <slot />\r\n  </Motion>\r\n</template>\r\n\r\n<script lang=\"ts\" setup>\r\nimport { cn } from \"@/lib/utils\";\r\nimport { Motion, useAnimate } from \"motion-v\";\r\nimport { ref, computed, onMounted, onUnmounted, type Ref } from \"vue\";\r\n\r\nconst cursorImg =\r\n  \"url('data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIzMiIgaGVpZ2h0PSIzMiIgdmlld0JveD0iMCAwIDMyIDMyIj4KICA8Y2lyY2xlIGN4PSIxNiIgY3k9IjE2IiByPSIxNSIgc3R5bGU9ImZpbGw6I2ZmZjtzdHJva2U6IzAwMDtzdHJva2Utd2lkdGg6MXB4OyIgLz4KPC9zdmc+'), auto\";\r\n\r\ninterface Props {\r\n  class?: string;\r\n  width: number;\r\n  height: number;\r\n  minScratchPercentage?: number;\r\n  gradientColors?: [string, string, string];\r\n}\r\n\r\nconst canvasRef = ref<HTMLCanvasElement>();\r\n\r\nconst props = withDefaults(defineProps<Props>(), {\r\n  gradientColors: () => [\"#A97CF8\", \"#F38CB8\", \"#FDCC92\"],\r\n  minScratchPercentage: 50,\r\n});\r\n\r\nconst containerWidth = computed(() => props.width + \"px\");\r\nconst containerHeight = computed(() => props.height + \"px\");\r\n\r\nconst context = ref<CanvasRenderingContext2D>();\r\n\r\nconst emit = defineEmits<{\r\n  complete: [];\r\n}>();\r\n\r\nconst isScratching = ref(false);\r\nconst isComplete = ref(false);\r\n\r\nfunction handleMouseDown() {\r\n  isScratching.value = true;\r\n}\r\nfunction handleTouchStart() {\r\n  isScratching.value = true;\r\n}\r\n\r\nconst canvasWidth = computed(() => canvasRef.value?.width || props.width);\r\nconst canvasHeight = computed(() => canvasRef.value?.height || props.height);\r\n\r\nfunction drawCanvas(canvasRef: Ref<HTMLCanvasElement>) {\r\n  context.value = canvasRef.value.getContext(\"2d\")!;\r\n  context.value.fillStyle = \"#ccc\";\r\n  context.value.fillRect(0, 0, canvasWidth.value, canvasHeight.value);\r\n  const gradient = context.value.createLinearGradient(0, 0, canvasWidth.value, canvasHeight.value);\r\n  gradient.addColorStop(0, props.gradientColors[0]);\r\n  gradient.addColorStop(0.5, props.gradientColors[1]);\r\n  gradient.addColorStop(1, props.gradientColors[2]);\r\n  context.value.fillStyle = gradient;\r\n  context.value.fillRect(0, 0, canvasWidth.value, canvasHeight.value);\r\n}\r\n\r\nfunction scratch(clientX: number, clientY: number) {\r\n  if (canvasRef.value && context.value) {\r\n    const rect = canvasRef.value.getBoundingClientRect();\r\n    const x = clientX - rect.left + 16;\r\n    const y = clientY - rect.top + 16;\r\n\r\n    context.value.globalCompositeOperation = \"destination-out\";\r\n    context.value.beginPath();\r\n    context.value.arc(x, y, 30, 0, Math.PI * 2);\r\n    context.value.fill();\r\n  }\r\n}\r\n\r\nfunction handleDocumentMouseMove(event: MouseEvent) {\r\n  if (!isScratching.value) return;\r\n  scratch(event.clientX, event.clientY);\r\n}\r\n\r\nfunction handleDocumentTouchMove(event: TouchEvent) {\r\n  if (!isScratching.value) return;\r\n  const touch = event.touches[0];\r\n  scratch(touch.clientX, touch.clientY);\r\n}\r\n\r\nfunction handleDocumentMouseUp() {\r\n  isScratching.value = false;\r\n  checkCompletion();\r\n}\r\nfunction handleDocumentTouchEnd() {\r\n  isScratching.value = false;\r\n  checkCompletion();\r\n}\r\n\r\nfunction addEventListeners() {\r\n  document.addEventListener(\"mousedown\", handleDocumentMouseMove);\r\n  document.addEventListener(\"mousemove\", handleDocumentMouseMove);\r\n  document.addEventListener(\"touchstart\", handleDocumentTouchMove);\r\n  document.addEventListener(\"touchmove\", handleDocumentTouchMove);\r\n  document.addEventListener(\"mouseup\", handleDocumentMouseUp);\r\n  document.addEventListener(\"touchend\", handleDocumentTouchEnd);\r\n  document.addEventListener(\"touchcancel\", handleDocumentTouchEnd);\r\n}\r\n\r\nfunction checkCompletion() {\r\n  if (isComplete.value) return;\r\n\r\n  if (canvasRef.value && context.value) {\r\n    const imageData = context.value.getImageData(0, 0, canvasWidth.value, canvasHeight.value);\r\n    const pixels = imageData.data;\r\n    const totalPixels = pixels.length / 4;\r\n    let clearPixels = 0;\r\n\r\n    for (let i = 3; i < pixels.length; i += 4) {\r\n      if (pixels[i] === 0) {\r\n        clearPixels++;\r\n      }\r\n    }\r\n\r\n    const percentage = (clearPixels / totalPixels) * 100;\r\n\r\n    if (percentage >= props.minScratchPercentage) {\r\n      isComplete.value = true;\r\n      context.value.clearRect(0, 0, canvasWidth.value, canvasHeight.value);\r\n\r\n      startAnimation();\r\n    } else {\r\n      isScratching.value = false;\r\n    }\r\n  }\r\n}\r\n\r\nconst [containerRef, animate] = useAnimate();\r\nasync function startAnimation() {\r\n  if (!containerRef.value) return;\r\n  animate(containerRef.value, {\r\n    scale: 1,\r\n    rotate: [0, 10, -10, 10, -10, 0],\r\n  });\r\n\r\n  emit(\"complete\");\r\n}\r\n\r\nonMounted(() => {\r\n  if (!canvasRef.value) return;\r\n\r\n  drawCanvas(canvasRef as Ref<HTMLCanvasElement>);\r\n\r\n  addEventListeners();\r\n});\r\n\r\nfunction removeEventListeners() {\r\n  document.removeEventListener(\"mousedown\", handleDocumentMouseMove);\r\n  document.removeEventListener(\"mousemove\", handleDocumentMouseMove);\r\n  document.removeEventListener(\"touchstart\", handleDocumentTouchMove);\r\n  document.removeEventListener(\"touchmove\", handleDocumentTouchMove);\r\n  document.removeEventListener(\"mouseup\", handleDocumentMouseUp);\r\n  document.removeEventListener(\"touchend\", handleDocumentTouchEnd);\r\n  document.removeEventListener(\"touchcancel\", handleDocumentTouchEnd);\r\n}\r\nonUnmounted(() => {\r\n  removeEventListeners();\r\n});\r\n</script>\r\n\r\n<style></style>\r\n",
      "target": "web"
    },
    {
      "path": "ScratchToReveal.vue",
      "content": "<template>\r\n  <Motion\r\n    ref=\"containerRef\"\r\n    :class=\"cn('relative select-none', props.class)\"\r\n    :style=\"{\r\n      width: containerWidth,\r\n      height: containerHeight,\r\n      cursor: cursorImg,\r\n    }\"\r\n    :initial=\"{\r\n      scale: 1,\r\n      rotate: [0, 10, -10, 10, -10, 0],\r\n    }\"\r\n    :transition=\"{ duration: 0.5 }\"\r\n  >\r\n    <canvas\r\n      ref=\"canvasRef\"\r\n      :width=\"width\"\r\n      :height=\"height\"\r\n      class=\"absolute left-0 top-0\"\r\n      @mousedown=\"handleMouseDown\"\r\n      @touchstart=\"handleTouchStart\"\r\n    />\r\n\r\n    <slot />\r\n  </Motion>\r\n</template>\r\n\r\n<script lang=\"ts\" setup>\r\nimport { cn } from \"@/lib/utils\";\r\nimport { Motion, useAnimate } from \"motion-v\";\r\nimport { ref, computed, onMounted, onUnmounted, type Ref } from \"vue\";\r\n\r\nconst cursorImg =\r\n  \"url('data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIzMiIgaGVpZ2h0PSIzMiIgdmlld0JveD0iMCAwIDMyIDMyIj4KICA8Y2lyY2xlIGN4PSIxNiIgY3k9IjE2IiByPSIxNSIgc3R5bGU9ImZpbGw6I2ZmZjtzdHJva2U6IzAwMDtzdHJva2Utd2lkdGg6MXB4OyIgLz4KPC9zdmc+'), auto\";\r\n\r\ninterface Props {\r\n  class?: string;\r\n  width: number;\r\n  height: number;\r\n  minScratchPercentage?: number;\r\n  gradientColors?: [string, string, string];\r\n}\r\n\r\nconst canvasRef = ref<HTMLCanvasElement>();\r\n\r\nconst props = withDefaults(defineProps<Props>(), {\r\n  gradientColors: () => [\"#A97CF8\", \"#F38CB8\", \"#FDCC92\"],\r\n  minScratchPercentage: 50,\r\n});\r\n\r\nconst containerWidth = computed(() => props.width + \"px\");\r\nconst containerHeight = computed(() => props.height + \"px\");\r\n\r\nconst context = ref<CanvasRenderingContext2D>();\r\n\r\nconst emit = defineEmits<{\r\n  complete: [];\r\n}>();\r\n\r\nconst isScratching = ref(false);\r\nconst isComplete = ref(false);\r\n\r\nfunction handleMouseDown() {\r\n  isScratching.value = true;\r\n}\r\nfunction handleTouchStart() {\r\n  isScratching.value = true;\r\n}\r\n\r\nconst canvasWidth = computed(() => canvasRef.value?.width || props.width);\r\nconst canvasHeight = computed(() => canvasRef.value?.height || props.height);\r\n\r\nfunction drawCanvas(canvasRef: Ref<HTMLCanvasElement>) {\r\n  context.value = canvasRef.value.getContext(\"2d\")!;\r\n  context.value.fillStyle = \"#ccc\";\r\n  context.value.fillRect(0, 0, canvasWidth.value, canvasHeight.value);\r\n  const gradient = context.value.createLinearGradient(0, 0, canvasWidth.value, canvasHeight.value);\r\n  gradient.addColorStop(0, props.gradientColors[0]);\r\n  gradient.addColorStop(0.5, props.gradientColors[1]);\r\n  gradient.addColorStop(1, props.gradientColors[2]);\r\n  context.value.fillStyle = gradient;\r\n  context.value.fillRect(0, 0, canvasWidth.value, canvasHeight.value);\r\n}\r\n\r\nfunction scratch(clientX: number, clientY: number) {\r\n  if (canvasRef.value && context.value) {\r\n    const rect = canvasRef.value.getBoundingClientRect();\r\n    const x = clientX - rect.left + 16;\r\n    const y = clientY - rect.top + 16;\r\n\r\n    context.value.globalCompositeOperation = \"destination-out\";\r\n    context.value.beginPath();\r\n    context.value.arc(x, y, 30, 0, Math.PI * 2);\r\n    context.value.fill();\r\n  }\r\n}\r\n\r\nfunction handleDocumentMouseMove(event: MouseEvent) {\r\n  if (!isScratching.value) return;\r\n  scratch(event.clientX, event.clientY);\r\n}\r\n\r\nfunction handleDocumentTouchMove(event: TouchEvent) {\r\n  if (!isScratching.value) return;\r\n  const touch = event.touches[0];\r\n  scratch(touch.clientX, touch.clientY);\r\n}\r\n\r\nfunction handleDocumentMouseUp() {\r\n  isScratching.value = false;\r\n  checkCompletion();\r\n}\r\nfunction handleDocumentTouchEnd() {\r\n  isScratching.value = false;\r\n  checkCompletion();\r\n}\r\n\r\nfunction addEventListeners() {\r\n  document.addEventListener(\"mousedown\", handleDocumentMouseMove);\r\n  document.addEventListener(\"mousemove\", handleDocumentMouseMove);\r\n  document.addEventListener(\"touchstart\", handleDocumentTouchMove);\r\n  document.addEventListener(\"touchmove\", handleDocumentTouchMove);\r\n  document.addEventListener(\"mouseup\", handleDocumentMouseUp);\r\n  document.addEventListener(\"touchend\", handleDocumentTouchEnd);\r\n  document.addEventListener(\"touchcancel\", handleDocumentTouchEnd);\r\n}\r\n\r\nfunction checkCompletion() {\r\n  if (isComplete.value) return;\r\n\r\n  if (canvasRef.value && context.value) {\r\n    const imageData = context.value.getImageData(0, 0, canvasWidth.value, canvasHeight.value);\r\n    const pixels = imageData.data;\r\n    const totalPixels = pixels.length / 4;\r\n    let clearPixels = 0;\r\n\r\n    for (let i = 3; i < pixels.length; i += 4) {\r\n      if (pixels[i] === 0) {\r\n        clearPixels++;\r\n      }\r\n    }\r\n\r\n    const percentage = (clearPixels / totalPixels) * 100;\r\n\r\n    if (percentage >= props.minScratchPercentage) {\r\n      isComplete.value = true;\r\n      context.value.clearRect(0, 0, canvasWidth.value, canvasHeight.value);\r\n\r\n      startAnimation();\r\n    } else {\r\n      isScratching.value = false;\r\n    }\r\n  }\r\n}\r\n\r\nconst [containerRef, animate] = useAnimate();\r\nasync function startAnimation() {\r\n  if (!containerRef.value) return;\r\n  animate(containerRef.value, {\r\n    scale: 1,\r\n    rotate: [0, 10, -10, 10, -10, 0],\r\n  });\r\n\r\n  emit(\"complete\");\r\n}\r\n\r\nonMounted(() => {\r\n  if (!canvasRef.value) return;\r\n\r\n  drawCanvas(canvasRef as Ref<HTMLCanvasElement>);\r\n\r\n  addEventListeners();\r\n});\r\n\r\nfunction removeEventListeners() {\r\n  document.removeEventListener(\"mousedown\", handleDocumentMouseMove);\r\n  document.removeEventListener(\"mousemove\", handleDocumentMouseMove);\r\n  document.removeEventListener(\"touchstart\", handleDocumentTouchMove);\r\n  document.removeEventListener(\"touchmove\", handleDocumentTouchMove);\r\n  document.removeEventListener(\"mouseup\", handleDocumentMouseUp);\r\n  document.removeEventListener(\"touchend\", handleDocumentTouchEnd);\r\n  document.removeEventListener(\"touchcancel\", handleDocumentTouchEnd);\r\n}\r\nonUnmounted(() => {\r\n  removeEventListeners();\r\n});\r\n</script>\r\n\r\n<style></style>\r\n",
      "target": "uniapp"
    }
  ],
  "fileCount": 3,
  "contentHash": "0720eec60aa5b764ef9c182d92e1d5574b80cfde"
}
