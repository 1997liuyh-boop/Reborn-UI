{
  "name": "flickering-grid",
  "dependencies": [],
  "files": [
    {
      "path": "FlickeringGrid.vue",
      "content": "<template>\r\n  <div\r\n    ref=\"containerRef\"\r\n    :class=\"cn('w-full h-full', props.class)\"\r\n  >\r\n    <canvas\r\n      ref=\"canvasRef\"\r\n      class=\"pointer-events-none\"\r\n      :width=\"canvasSize.width\"\r\n      :height=\"canvasSize.height\"\r\n    />\r\n  </div>\r\n</template>\r\n\r\n<script lang=\"ts\" setup>\r\nimport { cn } from \"@/lib/utils\";\r\nimport { ref, onMounted, onBeforeUnmount, toRefs, computed } from \"vue\";\r\n\r\ninterface FlickeringGridProps {\r\n  squareSize?: number;\r\n  gridGap?: number;\r\n  flickerChance?: number;\r\n  color?: string;\r\n  width?: number;\r\n  height?: number;\r\n  class?: string;\r\n  maxOpacity?: number;\r\n}\r\n\r\nconst props = withDefaults(defineProps<FlickeringGridProps>(), {\r\n  squareSize: 4,\r\n  gridGap: 6,\r\n  flickerChance: 0.3,\r\n  color: \"rgb(0, 0, 0)\",\r\n  maxOpacity: 0.3,\r\n});\r\n\r\nconst { squareSize, gridGap, flickerChance, color, maxOpacity, width, height } = toRefs(props);\r\n\r\nconst containerRef = ref<HTMLDivElement>();\r\nconst canvasRef = ref<HTMLCanvasElement>();\r\nconst context = ref<CanvasRenderingContext2D>();\r\n\r\nconst isInView = ref(false);\r\nconst canvasSize = ref({ width: 0, height: 0 });\r\n\r\nconst computedColor = computed(() => {\r\n  if (!context.value) return \"rgba(255, 0, 0,\";\r\n\r\n  const hex = color.value.replace(/^#/, \"\");\r\n  const bigint = Number.parseInt(hex, 16);\r\n  const r = (bigint >> 16) & 255;\r\n  const g = (bigint >> 8) & 255;\r\n  const b = bigint & 255;\r\n  return `rgba(${r}, ${g}, ${b},`;\r\n});\r\n\r\nfunction setupCanvas(\r\n  canvas: HTMLCanvasElement,\r\n  width: number,\r\n  height: number,\r\n): {\r\n  cols: number;\r\n  rows: number;\r\n  squares: Float32Array;\r\n  dpr: number;\r\n} {\r\n  const dpr = window.devicePixelRatio || 1;\r\n  canvas.width = width * dpr;\r\n  canvas.height = height * dpr;\r\n  canvas.style.width = `${width}px`;\r\n  canvas.style.height = `${height}px`;\r\n\r\n  const cols = Math.floor(width / (squareSize.value + gridGap.value));\r\n  const rows = Math.floor(height / (squareSize.value + gridGap.value));\r\n\r\n  const squares = new Float32Array(cols * rows);\r\n  for (let i = 0; i < squares.length; i++) {\r\n    squares[i] = Math.random() * maxOpacity.value;\r\n  }\r\n  return { cols, rows, squares, dpr };\r\n}\r\n\r\nfunction updateSquares(squares: Float32Array, deltaTime: number) {\r\n  for (let i = 0; i < squares.length; i++) {\r\n    if (Math.random() < flickerChance.value * deltaTime) {\r\n      squares[i] = Math.random() * maxOpacity.value;\r\n    }\r\n  }\r\n}\r\n\r\nfunction drawGrid(\r\n  ctx: CanvasRenderingContext2D,\r\n  width: number,\r\n  height: number,\r\n  cols: number,\r\n  rows: number,\r\n  squares: Float32Array,\r\n  dpr: number,\r\n) {\r\n  ctx.clearRect(0, 0, width, height);\r\n  ctx.fillStyle = \"transparent\";\r\n  ctx.fillRect(0, 0, width, height);\r\n  for (let i = 0; i < cols; i++) {\r\n    for (let j = 0; j < rows; j++) {\r\n      const opacity = squares[i * rows + j];\r\n      ctx.fillStyle = `${computedColor.value}${opacity})`;\r\n      ctx.fillRect(\r\n        i * (squareSize.value + gridGap.value) * dpr,\r\n        j * (squareSize.value + gridGap.value) * dpr,\r\n        squareSize.value * dpr,\r\n        squareSize.value * dpr,\r\n      );\r\n    }\r\n  }\r\n}\r\n\r\nconst gridParams = ref<ReturnType<typeof setupCanvas>>();\r\n\r\nfunction updateCanvasSize() {\r\n  const newWidth = width.value || containerRef.value!.clientWidth;\r\n  const newHeight = height.value || containerRef.value!.clientHeight;\r\n\r\n  canvasSize.value = { width: newWidth, height: newHeight };\r\n  gridParams.value = setupCanvas(canvasRef.value!, newWidth, newHeight);\r\n}\r\n\r\nlet animationFrameId: number | undefined;\r\nlet resizeObserver: ResizeObserver | undefined;\r\nlet intersectionObserver: IntersectionObserver | undefined;\r\nlet lastTime = 0;\r\n\r\nfunction animate(time: number) {\r\n  if (!isInView.value) return;\r\n\r\n  const deltaTime = (time - lastTime) / 1000;\r\n  lastTime = time;\r\n\r\n  updateSquares(gridParams.value!.squares, deltaTime);\r\n  drawGrid(\r\n    context.value!,\r\n    canvasRef.value!.width,\r\n    canvasRef.value!.height,\r\n    gridParams.value!.cols,\r\n    gridParams.value!.rows,\r\n    gridParams.value!.squares,\r\n    gridParams.value!.dpr,\r\n  );\r\n  animationFrameId = requestAnimationFrame(animate);\r\n}\r\n\r\nonMounted(() => {\r\n  if (!canvasRef.value || !containerRef.value) return;\r\n  context.value = canvasRef.value.getContext(\"2d\")!;\r\n  if (!context.value) return;\r\n\r\n  updateCanvasSize();\r\n\r\n  resizeObserver = new ResizeObserver(() => {\r\n    updateCanvasSize();\r\n  });\r\n  intersectionObserver = new IntersectionObserver(\r\n    ([entry]) => {\r\n      isInView.value = entry.isIntersecting;\r\n      animationFrameId = requestAnimationFrame(animate);\r\n    },\r\n    { threshold: 0 },\r\n  );\r\n\r\n  resizeObserver.observe(containerRef.value);\r\n  intersectionObserver.observe(canvasRef.value);\r\n});\r\n\r\nonBeforeUnmount(() => {\r\n  if (animationFrameId) {\r\n    cancelAnimationFrame(animationFrameId);\r\n  }\r\n  resizeObserver?.disconnect();\r\n  intersectionObserver?.disconnect();\r\n});\r\n</script>\r\n",
      "target": "web"
    },
    {
      "path": "FlickeringGrid.vue",
      "content": "<template>\r\n  <view\r\n    ref=\"containerRef\"\r\n    :class=\"cn('w-full h-full', props.class)\"\r\n  >\r\n    <canvas\r\n      ref=\"canvasRef\"\r\n      class=\"pointer-events-none\"\r\n      :width=\"canvasSize.width\"\r\n      :height=\"canvasSize.height\"\r\n    />\r\n  </view>\r\n</template>\r\n\r\n<script lang=\"ts\" setup>\r\nimport { cn } from \"@/lib/utils\";\r\nimport { ref, onMounted, onBeforeUnmount, toRefs, computed } from \"vue\";\r\n\r\ninterface FlickeringGridProps {\r\n  squareSize?: number;\r\n  gridGap?: number;\r\n  flickerChance?: number;\r\n  color?: string;\r\n  width?: number;\r\n  height?: number;\r\n  class?: string;\r\n  maxOpacity?: number;\r\n}\r\n\r\nconst props = withDefaults(defineProps<FlickeringGridProps>(), {\r\n  squareSize: 4,\r\n  gridGap: 6,\r\n  flickerChance: 0.3,\r\n  color: \"rgb(0, 0, 0)\",\r\n  maxOpacity: 0.3,\r\n});\r\n\r\nconst { squareSize, gridGap, flickerChance, color, maxOpacity, width, height } = toRefs(props);\r\n\r\nconst containerRef = ref<HTMLDivElement>();\r\nconst canvasRef = ref<HTMLCanvasElement>();\r\nconst context = ref<CanvasRenderingContext2D>();\r\n\r\nconst isInView = ref(false);\r\nconst canvasSize = ref({ width: 0, height: 0 });\r\n\r\nconst computedColor = computed(() => {\r\n  if (!context.value) return \"rgba(255, 0, 0,\";\r\n\r\n  const hex = color.value.replace(/^#/, \"\");\r\n  const bigint = Number.parseInt(hex, 16);\r\n  const r = (bigint >> 16) & 255;\r\n  const g = (bigint >> 8) & 255;\r\n  const b = bigint & 255;\r\n  return `rgba(${r}, ${g}, ${b},`;\r\n});\r\n\r\nfunction setupCanvas(\r\n  canvas: HTMLCanvasElement,\r\n  width: number,\r\n  height: number,\r\n): {\r\n  cols: number;\r\n  rows: number;\r\n  squares: Float32Array;\r\n  dpr: number;\r\n} {\r\n  const dpr = window.devicePixelRatio || 1;\r\n  canvas.width = width * dpr;\r\n  canvas.height = height * dpr;\r\n  canvas.style.width = `${width}px`;\r\n  canvas.style.height = `${height}px`;\r\n\r\n  const cols = Math.floor(width / (squareSize.value + gridGap.value));\r\n  const rows = Math.floor(height / (squareSize.value + gridGap.value));\r\n\r\n  const squares = new Float32Array(cols * rows);\r\n  for (let i = 0; i < squares.length; i++) {\r\n    squares[i] = Math.random() * maxOpacity.value;\r\n  }\r\n  return { cols, rows, squares, dpr };\r\n}\r\n\r\nfunction updateSquares(squares: Float32Array, deltaTime: number) {\r\n  for (let i = 0; i < squares.length; i++) {\r\n    if (Math.random() < flickerChance.value * deltaTime) {\r\n      squares[i] = Math.random() * maxOpacity.value;\r\n    }\r\n  }\r\n}\r\n\r\nfunction drawGrid(\r\n  ctx: CanvasRenderingContext2D,\r\n  width: number,\r\n  height: number,\r\n  cols: number,\r\n  rows: number,\r\n  squares: Float32Array,\r\n  dpr: number,\r\n) {\r\n  ctx.clearRect(0, 0, width, height);\r\n  ctx.fillStyle = \"transparent\";\r\n  ctx.fillRect(0, 0, width, height);\r\n  for (let i = 0; i < cols; i++) {\r\n    for (let j = 0; j < rows; j++) {\r\n      const opacity = squares[i * rows + j];\r\n      ctx.fillStyle = `${computedColor.value}${opacity})`;\r\n      ctx.fillRect(\r\n        i * (squareSize.value + gridGap.value) * dpr,\r\n        j * (squareSize.value + gridGap.value) * dpr,\r\n        squareSize.value * dpr,\r\n        squareSize.value * dpr,\r\n      );\r\n    }\r\n  }\r\n}\r\n\r\nconst gridParams = ref<ReturnType<typeof setupCanvas>>();\r\n\r\nfunction updateCanvasSize() {\r\n  const newWidth = width.value || containerRef.value!.clientWidth;\r\n  const newHeight = height.value || containerRef.value!.clientHeight;\r\n\r\n  canvasSize.value = { width: newWidth, height: newHeight };\r\n  gridParams.value = setupCanvas(canvasRef.value!, newWidth, newHeight);\r\n}\r\n\r\nlet animationFrameId: number | undefined;\r\nlet resizeObserver: ResizeObserver | undefined;\r\nlet intersectionObserver: IntersectionObserver | undefined;\r\nlet lastTime = 0;\r\n\r\nfunction animate(time: number) {\r\n  if (!isInView.value) return;\r\n\r\n  const deltaTime = (time - lastTime) / 1000;\r\n  lastTime = time;\r\n\r\n  updateSquares(gridParams.value!.squares, deltaTime);\r\n  drawGrid(\r\n    context.value!,\r\n    canvasRef.value!.width,\r\n    canvasRef.value!.height,\r\n    gridParams.value!.cols,\r\n    gridParams.value!.rows,\r\n    gridParams.value!.squares,\r\n    gridParams.value!.dpr,\r\n  );\r\n  animationFrameId = requestAnimationFrame(animate);\r\n}\r\n\r\nonMounted(() => {\r\n  if (!canvasRef.value || !containerRef.value) return;\r\n  context.value = canvasRef.value.getContext(\"2d\")!;\r\n  if (!context.value) return;\r\n\r\n  updateCanvasSize();\r\n\r\n  resizeObserver = new ResizeObserver(() => {\r\n    updateCanvasSize();\r\n  });\r\n  intersectionObserver = new IntersectionObserver(\r\n    ([entry]) => {\r\n      isInView.value = entry.isIntersecting;\r\n      animationFrameId = requestAnimationFrame(animate);\r\n    },\r\n    { threshold: 0 },\r\n  );\r\n\r\n  resizeObserver.observe(containerRef.value);\r\n  intersectionObserver.observe(canvasRef.value);\r\n});\r\n\r\nonBeforeUnmount(() => {\r\n  if (animationFrameId) {\r\n    cancelAnimationFrame(animationFrameId);\r\n  }\r\n  resizeObserver?.disconnect();\r\n  intersectionObserver?.disconnect();\r\n});\r\n</script>\r\n",
      "target": "uniapp"
    },
    {
      "path": "index.ts",
      "content": "export { default as FlickeringGrid } from \"./FlickeringGrid.vue\";\r\n"
    }
  ],
  "fileCount": 3,
  "contentHash": "f35fa4a6cb96869ff65285ca01c57cdedc2ce24c"
}
