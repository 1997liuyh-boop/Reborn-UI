{
  "name": "vortex",
  "dependencies": [
    "@vueuse/core",
    "simplex-noise"
  ],
  "files": [
    {
      "path": "index.ts",
      "content": "export { default as Vortex } from \"./Vortex.vue\";\r\n"
    },
    {
      "path": "Vortex.vue",
      "content": "<template>\r\n  <div :class=\"cn('relative h-full w-full', props.containerClass)\">\r\n    <Motion\r\n      ref=\"containerRef\"\r\n      as=\"div\"\r\n      :initial=\"{ opacity: 0 }\"\r\n      :animate=\"{ opacity: 1 }\"\r\n      class=\"absolute inset-0 z-0 flex size-full items-center justify-center bg-transparent\"\r\n    >\r\n      <canvas ref=\"canvasRef\"></canvas>\r\n    </Motion>\r\n\r\n    <div :class=\"cn('relative z-10', props.class)\">\r\n      <slot />\r\n    </div>\r\n  </div>\r\n</template>\r\n\r\n<script setup lang=\"ts\">\r\nimport { createNoise3D } from \"simplex-noise\";\r\nimport { onMounted, onUnmounted } from \"vue\";\r\nimport { templateRef } from \"@vueuse/core\";\r\nimport { cn } from \"@/lib/utils\";\r\nimport { useDebounceFn } from \"@vueuse/core\";\r\nconst TAU = 2 * Math.PI;\r\nconst BASE_TTL = 50;\r\nconst RANGE_TTL = 150;\r\nconst PARTICLE_PROP_COUNT = 9;\r\nconst RANGE_HUE = 100;\r\nconst NOISE_STEPS = 3;\r\nconst X_OFF = 0.00125;\r\nconst Y_OFF = 0.00125;\r\nconst Z_OFF = 0.0005;\r\n\r\ninterface VortexProps {\r\n  class?: string;\r\n  containerClass?: string;\r\n  particleCount?: number;\r\n  rangeY?: number;\r\n  baseHue?: number;\r\n  baseSpeed?: number;\r\n  rangeSpeed?: number;\r\n  baseRadius?: number;\r\n  rangeRadius?: number;\r\n  backgroundColor?: string;\r\n}\r\n\r\nconst props = withDefaults(defineProps<VortexProps>(), {\r\n  particleCount: 700,\r\n  rangeY: 100,\r\n  baseSpeed: 0.0,\r\n  rangeSpeed: 1.5,\r\n  baseRadius: 1,\r\n  rangeRadius: 2,\r\n  baseHue: 220,\r\n  backgroundColor: \"#000000\",\r\n});\r\n\r\nconst tick = ref<number>(0);\r\nconst animationFrame = ref<number | null>(null);\r\nconst particleProps = shallowRef<Float32Array | null>(null);\r\nconst center = ref<[number, number]>([0, 0]);\r\nconst ctx = shallowRef<CanvasRenderingContext2D | null>(null);\r\n\r\nconst canvasRef = templateRef<HTMLCanvasElement | null>(\"canvasRef\");\r\nconst containerRef = templateRef<HTMLElement | null>(\"containerRef\");\r\n\r\nconst particleCache = {\r\n  x: 0,\r\n  y: 0,\r\n  vx: 0,\r\n  vy: 0,\r\n  life: 0,\r\n  ttl: 0,\r\n  speed: 0,\r\n  radius: 0,\r\n  hue: 0,\r\n};\r\n\r\nconst noise3D = createNoise3D();\r\n\r\nfunction rand(n: number) {\r\n  return n * Math.random();\r\n}\r\nfunction randRange(n: number): number {\r\n  return n - rand(2 * n);\r\n}\r\nfunction fadeInOut(t: number, m: number): number {\r\n  const hm = 0.5 * m;\r\n  return Math.abs(((t + hm) % m) - hm) / hm;\r\n}\r\nfunction lerp(n1: number, n2: number, speed: number): number {\r\n  return (1 - speed) * n1 + speed * n2;\r\n}\r\n\r\nfunction initParticle(i: number) {\r\n  if (!particleProps.value || !canvasRef.value) return;\r\n\r\n  const canvas = canvasRef.value;\r\n  particleCache.x = rand(canvas.width);\r\n  particleCache.y = center.value[1] + randRange(props.rangeY);\r\n  particleCache.vx = 0;\r\n  particleCache.vy = 0;\r\n  particleCache.life = 0;\r\n  particleCache.ttl = BASE_TTL + rand(RANGE_TTL);\r\n  particleCache.speed = props.baseSpeed + rand(props.rangeSpeed);\r\n  particleCache.radius = props.baseRadius + rand(props.rangeRadius);\r\n  particleCache.hue = props.baseHue + rand(RANGE_HUE);\r\n\r\n  particleProps.value.set(\r\n    [\r\n      particleCache.x,\r\n      particleCache.y,\r\n      particleCache.vx,\r\n      particleCache.vy,\r\n      particleCache.life,\r\n      particleCache.ttl,\r\n      particleCache.speed,\r\n      particleCache.radius,\r\n      particleCache.hue,\r\n    ],\r\n    i,\r\n  );\r\n}\r\n\r\nfunction updateParticle(i: number) {\r\n  if (!particleProps.value || !canvasRef.value || !ctx.value) return;\r\n\r\n  const canvas = canvasRef.value;\r\n  const props = particleProps.value;\r\n  const context = ctx.value;\r\n\r\n  particleCache.x = props[i]!;\r\n  particleCache.y = props[i + 1]!;\r\n  particleCache.vx = props[i + 2]!;\r\n  particleCache.vy = props[i + 3]!;\r\n  particleCache.life = props[i + 4]!;\r\n  particleCache.ttl = props[i + 5]!;\r\n  particleCache.speed = props[i + 6]!;\r\n  particleCache.radius = props[i + 7]!;\r\n  particleCache.hue = props[i + 8]!;\r\n\r\n  const n =\r\n    noise3D(particleCache.x * X_OFF, particleCache.y * Y_OFF, tick.value * Z_OFF) *\r\n    NOISE_STEPS *\r\n    TAU;\r\n\r\n  const nextVx = lerp(particleCache.vx, Math.cos(n), 0.5);\r\n  const nextVy = lerp(particleCache.vy, Math.sin(n), 0.5);\r\n  const nextX = particleCache.x + nextVx * particleCache.speed;\r\n  const nextY = particleCache.y + nextVy * particleCache.speed;\r\n\r\n  context.save();\r\n  context.lineCap = \"round\";\r\n  context.lineWidth = particleCache.radius;\r\n  context.strokeStyle = `hsla(${particleCache.hue},100%,60%,${fadeInOut(\r\n    particleCache.life,\r\n    particleCache.ttl,\r\n  )})`;\r\n  context.beginPath();\r\n  context.moveTo(particleCache.x, particleCache.y);\r\n  context.lineTo(nextX, nextY);\r\n  context.stroke();\r\n  context.restore();\r\n\r\n  props[i] = nextX;\r\n  props[i + 1] = nextY;\r\n  props[i + 2] = nextVx;\r\n  props[i + 3] = nextVy;\r\n  props[i + 4] = particleCache.life + 1;\r\n\r\n  if (\r\n    nextX > canvas.width ||\r\n    nextX < 0 ||\r\n    nextY > canvas.height ||\r\n    nextY < 0 ||\r\n    particleCache.life > particleCache.ttl\r\n  ) {\r\n    initParticle(i);\r\n  }\r\n}\r\n\r\nfunction draw() {\r\n  if (!canvasRef.value || !ctx.value || !particleProps.value) return;\r\n\r\n  const canvas = canvasRef.value;\r\n  const context = ctx.value;\r\n\r\n  tick.value++;\r\n\r\n  context.fillStyle = props.backgroundColor;\r\n  context.fillRect(0, 0, canvas.width, canvas.height);\r\n\r\n  for (let i = 0; i < particleProps.value.length; i += PARTICLE_PROP_COUNT) {\r\n    updateParticle(i);\r\n  }\r\n\r\n  context.save();\r\n  context.filter = \"blur(8px) brightness(200%)\";\r\n  context.globalCompositeOperation = \"lighter\";\r\n  context.drawImage(canvas, 0, 0);\r\n  context.restore();\r\n\r\n  context.save();\r\n  context.filter = \"blur(4px) brightness(200%)\";\r\n  context.globalCompositeOperation = \"lighter\";\r\n  context.drawImage(canvas, 0, 0);\r\n  context.restore();\r\n\r\n  animationFrame.value = requestAnimationFrame(draw);\r\n}\r\n\r\nconst handleResize = useDebounceFn(() => {\r\n  if (!canvasRef.value) return;\r\n\r\n  const canvas = canvasRef.value;\r\n  const { innerWidth, innerHeight } = window;\r\n  canvas.width = innerWidth;\r\n  canvas.height = innerHeight;\r\n  center.value = [0.5 * canvas.width, 0.5 * canvas.height];\r\n}, 150);\r\n\r\nonMounted(() => {\r\n  const canvas = canvasRef.value;\r\n  if (!canvas) return;\r\n\r\n  ctx.value = canvas.getContext(\"2d\");\r\n  if (!ctx.value) return;\r\n\r\n  canvas.width = window.innerWidth;\r\n  canvas.height = window.innerHeight;\r\n  center.value = [0.5 * canvas.width, 0.5 * canvas.height];\r\n\r\n  const particlePropsLength = props.particleCount * PARTICLE_PROP_COUNT;\r\n  particleProps.value = new Float32Array(particlePropsLength);\r\n\r\n  for (let i = 0; i < particlePropsLength; i += PARTICLE_PROP_COUNT) {\r\n    initParticle(i);\r\n  }\r\n\r\n  draw();\r\n  window.addEventListener(\"resize\", handleResize);\r\n});\r\n\r\nonUnmounted(() => {\r\n  if (animationFrame.value) {\r\n    cancelAnimationFrame(animationFrame.value);\r\n  }\r\n  window.removeEventListener(\"resize\", handleResize);\r\n\r\n  ctx.value = null;\r\n  particleProps.value = null;\r\n});\r\n</script>\r\n",
      "target": "web"
    },
    {
      "path": "Vortex.vue",
      "content": "<template>\r\n  <view :class=\"cn('relative h-full w-full', props.containerClass)\">\r\n    <Motion\r\n      ref=\"containerRef\"\r\n      as=\"div\"\r\n      :initial=\"{ opacity: 0 }\"\r\n      :animate=\"{ opacity: 1 }\"\r\n      class=\"absolute inset-0 z-0 flex size-full items-center justify-center bg-transparent\"\r\n    >\r\n      <canvas ref=\"canvasRef\"></canvas>\r\n    </Motion>\r\n\r\n    <view :class=\"cn('relative z-10', props.class)\">\r\n      <slot />\r\n    </view>\r\n  </view>\r\n</template>\r\n\r\n<script setup lang=\"ts\">\r\nimport { createNoise3D } from \"simplex-noise\";\r\nimport { onMounted, onUnmounted } from \"vue\";\r\nimport { templateRef } from \"@vueuse/core\";\r\nimport { cn } from \"@/lib/utils\";\r\nimport { useDebounceFn } from \"@vueuse/core\";\r\nconst TAU = 2 * Math.PI;\r\nconst BASE_TTL = 50;\r\nconst RANGE_TTL = 150;\r\nconst PARTICLE_PROP_COUNT = 9;\r\nconst RANGE_HUE = 100;\r\nconst NOISE_STEPS = 3;\r\nconst X_OFF = 0.00125;\r\nconst Y_OFF = 0.00125;\r\nconst Z_OFF = 0.0005;\r\n\r\ninterface VortexProps {\r\n  class?: string;\r\n  containerClass?: string;\r\n  particleCount?: number;\r\n  rangeY?: number;\r\n  baseHue?: number;\r\n  baseSpeed?: number;\r\n  rangeSpeed?: number;\r\n  baseRadius?: number;\r\n  rangeRadius?: number;\r\n  backgroundColor?: string;\r\n}\r\n\r\nconst props = withDefaults(defineProps<VortexProps>(), {\r\n  particleCount: 700,\r\n  rangeY: 100,\r\n  baseSpeed: 0.0,\r\n  rangeSpeed: 1.5,\r\n  baseRadius: 1,\r\n  rangeRadius: 2,\r\n  baseHue: 220,\r\n  backgroundColor: \"#000000\",\r\n});\r\n\r\nconst tick = ref<number>(0);\r\nconst animationFrame = ref<number | null>(null);\r\nconst particleProps = shallowRef<Float32Array | null>(null);\r\nconst center = ref<[number, number]>([0, 0]);\r\nconst ctx = shallowRef<CanvasRenderingContext2D | null>(null);\r\n\r\nconst canvasRef = templateRef<HTMLCanvasElement | null>(\"canvasRef\");\r\nconst containerRef = templateRef<HTMLElement | null>(\"containerRef\");\r\n\r\nconst particleCache = {\r\n  x: 0,\r\n  y: 0,\r\n  vx: 0,\r\n  vy: 0,\r\n  life: 0,\r\n  ttl: 0,\r\n  speed: 0,\r\n  radius: 0,\r\n  hue: 0,\r\n};\r\n\r\nconst noise3D = createNoise3D();\r\n\r\nfunction rand(n: number) {\r\n  return n * Math.random();\r\n}\r\nfunction randRange(n: number): number {\r\n  return n - rand(2 * n);\r\n}\r\nfunction fadeInOut(t: number, m: number): number {\r\n  const hm = 0.5 * m;\r\n  return Math.abs(((t + hm) % m) - hm) / hm;\r\n}\r\nfunction lerp(n1: number, n2: number, speed: number): number {\r\n  return (1 - speed) * n1 + speed * n2;\r\n}\r\n\r\nfunction initParticle(i: number) {\r\n  if (!particleProps.value || !canvasRef.value) return;\r\n\r\n  const canvas = canvasRef.value;\r\n  particleCache.x = rand(canvas.width);\r\n  particleCache.y = center.value[1] + randRange(props.rangeY);\r\n  particleCache.vx = 0;\r\n  particleCache.vy = 0;\r\n  particleCache.life = 0;\r\n  particleCache.ttl = BASE_TTL + rand(RANGE_TTL);\r\n  particleCache.speed = props.baseSpeed + rand(props.rangeSpeed);\r\n  particleCache.radius = props.baseRadius + rand(props.rangeRadius);\r\n  particleCache.hue = props.baseHue + rand(RANGE_HUE);\r\n\r\n  particleProps.value.set(\r\n    [\r\n      particleCache.x,\r\n      particleCache.y,\r\n      particleCache.vx,\r\n      particleCache.vy,\r\n      particleCache.life,\r\n      particleCache.ttl,\r\n      particleCache.speed,\r\n      particleCache.radius,\r\n      particleCache.hue,\r\n    ],\r\n    i,\r\n  );\r\n}\r\n\r\nfunction updateParticle(i: number) {\r\n  if (!particleProps.value || !canvasRef.value || !ctx.value) return;\r\n\r\n  const canvas = canvasRef.value;\r\n  const props = particleProps.value;\r\n  const context = ctx.value;\r\n\r\n  particleCache.x = props[i]!;\r\n  particleCache.y = props[i + 1]!;\r\n  particleCache.vx = props[i + 2]!;\r\n  particleCache.vy = props[i + 3]!;\r\n  particleCache.life = props[i + 4]!;\r\n  particleCache.ttl = props[i + 5]!;\r\n  particleCache.speed = props[i + 6]!;\r\n  particleCache.radius = props[i + 7]!;\r\n  particleCache.hue = props[i + 8]!;\r\n\r\n  const n =\r\n    noise3D(particleCache.x * X_OFF, particleCache.y * Y_OFF, tick.value * Z_OFF) *\r\n    NOISE_STEPS *\r\n    TAU;\r\n\r\n  const nextVx = lerp(particleCache.vx, Math.cos(n), 0.5);\r\n  const nextVy = lerp(particleCache.vy, Math.sin(n), 0.5);\r\n  const nextX = particleCache.x + nextVx * particleCache.speed;\r\n  const nextY = particleCache.y + nextVy * particleCache.speed;\r\n\r\n  context.save();\r\n  context.lineCap = \"round\";\r\n  context.lineWidth = particleCache.radius;\r\n  context.strokeStyle = `hsla(${particleCache.hue},100%,60%,${fadeInOut(\r\n    particleCache.life,\r\n    particleCache.ttl,\r\n  )})`;\r\n  context.beginPath();\r\n  context.moveTo(particleCache.x, particleCache.y);\r\n  context.lineTo(nextX, nextY);\r\n  context.stroke();\r\n  context.restore();\r\n\r\n  props[i] = nextX;\r\n  props[i + 1] = nextY;\r\n  props[i + 2] = nextVx;\r\n  props[i + 3] = nextVy;\r\n  props[i + 4] = particleCache.life + 1;\r\n\r\n  if (\r\n    nextX > canvas.width ||\r\n    nextX < 0 ||\r\n    nextY > canvas.height ||\r\n    nextY < 0 ||\r\n    particleCache.life > particleCache.ttl\r\n  ) {\r\n    initParticle(i);\r\n  }\r\n}\r\n\r\nfunction draw() {\r\n  if (!canvasRef.value || !ctx.value || !particleProps.value) return;\r\n\r\n  const canvas = canvasRef.value;\r\n  const context = ctx.value;\r\n\r\n  tick.value++;\r\n\r\n  context.fillStyle = props.backgroundColor;\r\n  context.fillRect(0, 0, canvas.width, canvas.height);\r\n\r\n  for (let i = 0; i < particleProps.value.length; i += PARTICLE_PROP_COUNT) {\r\n    updateParticle(i);\r\n  }\r\n\r\n  context.save();\r\n  context.filter = \"blur(8px) brightness(200%)\";\r\n  context.globalCompositeOperation = \"lighter\";\r\n  context.drawImage(canvas, 0, 0);\r\n  context.restore();\r\n\r\n  context.save();\r\n  context.filter = \"blur(4px) brightness(200%)\";\r\n  context.globalCompositeOperation = \"lighter\";\r\n  context.drawImage(canvas, 0, 0);\r\n  context.restore();\r\n\r\n  animationFrame.value = requestAnimationFrame(draw);\r\n}\r\n\r\nconst handleResize = useDebounceFn(() => {\r\n  if (!canvasRef.value) return;\r\n\r\n  const canvas = canvasRef.value;\r\n  const { innerWidth, innerHeight } = window;\r\n  canvas.width = innerWidth;\r\n  canvas.height = innerHeight;\r\n  center.value = [0.5 * canvas.width, 0.5 * canvas.height];\r\n}, 150);\r\n\r\nonMounted(() => {\r\n  const canvas = canvasRef.value;\r\n  if (!canvas) return;\r\n\r\n  ctx.value = canvas.getContext(\"2d\");\r\n  if (!ctx.value) return;\r\n\r\n  canvas.width = window.innerWidth;\r\n  canvas.height = window.innerHeight;\r\n  center.value = [0.5 * canvas.width, 0.5 * canvas.height];\r\n\r\n  const particlePropsLength = props.particleCount * PARTICLE_PROP_COUNT;\r\n  particleProps.value = new Float32Array(particlePropsLength);\r\n\r\n  for (let i = 0; i < particlePropsLength; i += PARTICLE_PROP_COUNT) {\r\n    initParticle(i);\r\n  }\r\n\r\n  draw();\r\n  window.addEventListener(\"resize\", handleResize);\r\n});\r\n\r\nonUnmounted(() => {\r\n  if (animationFrame.value) {\r\n    cancelAnimationFrame(animationFrame.value);\r\n  }\r\n  window.removeEventListener(\"resize\", handleResize);\r\n\r\n  ctx.value = null;\r\n  particleProps.value = null;\r\n});\r\n</script>\r\n",
      "target": "uniapp"
    }
  ],
  "fileCount": 3,
  "contentHash": "0ff9ef8d10315cef33d74a1c38363fd30b6e9908"
}
