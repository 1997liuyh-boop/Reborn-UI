{
  "name": "shader-toy",
  "dependencies": [
    "ogl"
  ],
  "files": [
    {
      "path": "index.ts",
      "content": "export { default as ShaderToy } from \"./ShaderToy.vue\";\r\nexport * from \"./InspiraShaderToy\";\r\n"
    },
    {
      "path": "InspiraShaderToy.ts",
      "content": "import { Renderer, Camera, Transform, Geometry, Program, Mesh } from \"ogl\";\r\n\r\nexport interface ShaderConfig {\r\n  source: string;\r\n}\r\n\r\nexport interface MouseState {\r\n  x: number;\r\n  y: number;\r\n  clickX: number;\r\n  clickY: number;\r\n}\r\n\r\nexport interface HSVControls {\r\n  hue: number; // 0-360\r\n  saturation: number; // 0-1\r\n  brightness: number; // 0-1\r\n}\r\n\r\nexport type MouseMode = \"click\" | \"hover\";\r\n\r\nexport class InspiraShaderToy {\r\n  private renderer: Renderer;\r\n  private camera: Camera;\r\n  private scene: Transform;\r\n  private geometry: Geometry;\r\n  private program: Program | null = null;\r\n  private mesh: Mesh | null = null;\r\n\r\n  // Timing\r\n  private isPlaying: boolean = false;\r\n  private firstDrawTime: number = 0;\r\n  private prevDrawTime: number = 0;\r\n  private targetFPS: number = 60;\r\n  private frameInterval: number = 1000 / 60;\r\n  private lastFrameTime: number = 0;\r\n\r\n  // Callback\r\n  private onDrawCallback?: () => void;\r\n\r\n  // Uniforms\r\n  private iFrame: number = 0;\r\n  private iMouse: MouseState = { x: 0, y: 0, clickX: 0, clickY: 0 };\r\n  private hsv: HSVControls = { hue: 0, saturation: 1, brightness: 1 };\r\n  private _mouseMode: MouseMode = \"click\";\r\n  private _mouseSensitivity: number = 1.0; // New: mouse sensitivity multiplier\r\n  private _mouseDamping: number = 0.9; // New: mouse movement damping factor (0-1)\r\n\r\n  private _speed: number = 1; // Speed multiplier\r\n\r\n  // Shader source\r\n  private shaderSource: string = \"\";\r\n\r\n  private readonly vertexShader = `#version 300 es\r\n    #ifdef GL_ES\r\n    precision highp float;\r\n    precision highp int;\r\n    #endif\r\n    in vec2 position;\r\n    void main() {\r\n        gl_Position = vec4(position, 0.0, 1.0);\r\n    }\r\n  `;\r\n\r\n  private readonly fragmentShaderHeader = `#version 300 es\r\n    #ifdef GL_ES\r\n    precision highp float;\r\n    precision highp int;\r\n    #endif\r\n    \r\n    uniform vec3      iResolution;     // viewport resolution (in pixels)\r\n    uniform float     iTime;           // shader playback time (in seconds)\r\n    uniform float     iTimeDelta;      // render time (in seconds)\r\n    uniform float     iFrameRate;      // shader frame rate\r\n    uniform int       iFrame;          // shader playback frame\r\n    uniform vec4      iMouse;          // mouse pixel coords. xy: current, zw: click\r\n    uniform vec4      iDate;           // (year, month, day, unixtime in seconds)\r\n    uniform vec3      iHSV;            // HSV controls (hue, saturation, brightness)\r\n    uniform float     iSpeed;          // speed multiplier\r\n    \r\n    out vec4 fragColor;\r\n    \r\n    // HSV to RGB conversion\r\n    vec3 hsv2rgb(vec3 c) {\r\n        vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\r\n        vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\r\n        return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\r\n    }\r\n    \r\n    // RGB to HSV conversion\r\n    vec3 rgb2hsv(vec3 c) {\r\n        vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\r\n        vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\r\n        vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\r\n        float d = q.x - min(q.w, q.y);\r\n        float e = 1.0e-10;\r\n        return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\r\n    }\r\n    \r\n    // Apply HSV adjustments\r\n    vec3 applyHSV(vec3 color, vec3 hsvAdjust) {\r\n        vec3 hsv = rgb2hsv(color);\r\n        hsv.x = fract(hsv.x + hsvAdjust.x / 360.0);\r\n        hsv.y = clamp(hsv.y * hsvAdjust.y, 0.0, 1.0);\r\n        hsv.z = clamp(hsv.z * hsvAdjust.z, 0.0, 1.0);\r\n        return hsv2rgb(hsv);\r\n    }\r\n    \r\n    void mainImage(out vec4 c, in vec2 f);\r\n    \r\n    void main() {\r\n        vec4 color = vec4(0.0, 0.0, 0.0, 1.0);\r\n        mainImage(color, gl_FragCoord.xy);\r\n        \r\n        // Apply HSV adjustments if not default\r\n        if (iHSV.x != 0.0 || iHSV.y != 1.0 || iHSV.z != 1.0) {\r\n            color.rgb = applyHSV(color.rgb, iHSV);\r\n        }\r\n        \r\n        fragColor = color;\r\n    }\r\n  `;\r\n\r\n  constructor(\r\n    private container: HTMLElement,\r\n    mouseMode?: MouseMode,\r\n    fps?: number,\r\n  ) {\r\n    if (mouseMode) {\r\n      this._mouseMode = mouseMode;\r\n    }\r\n    if (fps) {\r\n      this.setFrameRate(fps);\r\n    }\r\n\r\n    // Create renderer with WebGL 2 context\r\n    this.renderer = new Renderer({\r\n      width: this.container.clientWidth,\r\n      height: this.container.clientHeight,\r\n      dpr: window.devicePixelRatio,\r\n      alpha: true,\r\n      depth: false,\r\n      stencil: false,\r\n      antialias: true,\r\n      powerPreference: \"high-performance\",\r\n    });\r\n\r\n    // Ensure WebGL 2 context\r\n    if (!this.renderer.gl || !(this.renderer.gl instanceof WebGL2RenderingContext)) {\r\n      throw new Error(\"WebGL 2 not supported\");\r\n    }\r\n\r\n    // Append canvas to container\r\n    this.container.appendChild(this.renderer.gl.canvas);\r\n\r\n    // Setup camera (orthographic for full-screen quad)\r\n    this.camera = new Camera(this.renderer.gl);\r\n    this.camera.position.z = 1;\r\n\r\n    // Setup scene\r\n    this.scene = new Transform();\r\n\r\n    // Setup geometry (full-screen quad)\r\n    this.geometry = new Geometry(this.renderer.gl, {\r\n      position: {\r\n        size: 2,\r\n        data: new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1, -1, 1, 1, -1]),\r\n      },\r\n    });\r\n\r\n    this.setup();\r\n  }\r\n\r\n  private setup(): void {\r\n    this.setupMouseEvents();\r\n    this.setupResizeHandler();\r\n  }\r\n\r\n  private setupMouseEvents(): void {\r\n    const canvas = this.renderer.gl.canvas;\r\n    let isMouseDown = false;\r\n\r\n    const getScaledMousePos = (event: MouseEvent | Touch) => {\r\n      const rect = canvas.getBoundingClientRect();\r\n      const dpr = window.devicePixelRatio;\r\n\r\n      // Get mouse position relative to canvas\r\n      const x = event.clientX - rect.left;\r\n      const y = event.clientY - rect.top;\r\n\r\n      // Scale by DPR, apply sensitivity, and flip Y-axis\r\n      return {\r\n        x: x * dpr * this._mouseSensitivity,\r\n        y: (canvas.height - y * dpr) * this._mouseSensitivity, // Flip Y to match GLSL coordinates\r\n      };\r\n    };\r\n\r\n    canvas.addEventListener(\"mousemove\", (event: MouseEvent) => {\r\n      const { x: newX, y: newY } = getScaledMousePos(event);\r\n\r\n      // Apply damping with configurable factor\r\n      this.iMouse.x = this.iMouse.x * this._mouseDamping + newX * (1 - this._mouseDamping);\r\n      this.iMouse.y = this.iMouse.y * this._mouseDamping + newY * (1 - this._mouseDamping);\r\n\r\n      // Handle click coordinates based on mode\r\n      if (this._mouseMode === \"hover\" && !isMouseDown) {\r\n        this.iMouse.clickX = this.iMouse.x;\r\n        this.iMouse.clickY = this.iMouse.y;\r\n      } else if (isMouseDown) {\r\n        this.iMouse.clickX = newX;\r\n        this.iMouse.clickY = newY;\r\n      }\r\n    });\r\n\r\n    canvas.addEventListener(\"mousedown\", (event: MouseEvent) => {\r\n      isMouseDown = true;\r\n      const { x: clickX, y: clickY } = getScaledMousePos(event);\r\n\r\n      if (this._mouseMode === \"click\") {\r\n        this.iMouse.clickX = clickX;\r\n        this.iMouse.clickY = clickY;\r\n      }\r\n    });\r\n\r\n    canvas.addEventListener(\"mouseup\", () => {\r\n      isMouseDown = false;\r\n    });\r\n\r\n    // Handle touch events for mobile\r\n    canvas.addEventListener(\"touchmove\", (event: TouchEvent) => {\r\n      event.preventDefault();\r\n      const touch = event.touches[0];\r\n      const { x: newX, y: newY } = getScaledMousePos(touch);\r\n\r\n      this.iMouse.x = newX;\r\n      this.iMouse.y = newY;\r\n\r\n      if (this._mouseMode === \"hover\") {\r\n        this.iMouse.clickX = newX;\r\n        this.iMouse.clickY = newY;\r\n      }\r\n    });\r\n\r\n    canvas.addEventListener(\"touchstart\", (event: TouchEvent) => {\r\n      event.preventDefault();\r\n      isMouseDown = true;\r\n      const touch = event.touches[0];\r\n      const { x: clickX, y: clickY } = getScaledMousePos(touch);\r\n\r\n      if (this._mouseMode === \"click\") {\r\n        this.iMouse.clickX = clickX;\r\n        this.iMouse.clickY = clickY;\r\n      }\r\n    });\r\n\r\n    canvas.addEventListener(\"touchend\", () => {\r\n      isMouseDown = false;\r\n    });\r\n  }\r\n\r\n  private setupResizeHandler(): void {\r\n    const resizeObserver = new ResizeObserver(() => {\r\n      const width = this.container.clientWidth;\r\n      const height = this.container.clientHeight;\r\n\r\n      // Update renderer size\r\n      this.renderer.setSize(width, height);\r\n\r\n      // Update viewport\r\n      this.renderer.gl.viewport(\r\n        0,\r\n        0,\r\n        width * window.devicePixelRatio,\r\n        height * window.devicePixelRatio,\r\n      );\r\n\r\n      // Update resolution uniform if program exists\r\n      if (this.program) {\r\n        this.program.uniforms.iResolution.value = [\r\n          width * window.devicePixelRatio,\r\n          height * window.devicePixelRatio,\r\n          window.devicePixelRatio,\r\n        ];\r\n      }\r\n    });\r\n\r\n    resizeObserver.observe(this.container);\r\n  }\r\n\r\n  private compileProgram(): boolean {\r\n    if (!this.shaderSource) return false;\r\n\r\n    const fullFragmentShader = this.fragmentShaderHeader + this.shaderSource;\r\n\r\n    try {\r\n      const program = new Program(this.renderer.gl, {\r\n        vertex: this.vertexShader,\r\n        fragment: fullFragmentShader,\r\n        uniforms: {\r\n          iResolution: {\r\n            value: [\r\n              this.container.clientWidth * window.devicePixelRatio,\r\n              this.container.clientHeight * window.devicePixelRatio,\r\n              window.devicePixelRatio,\r\n            ],\r\n          },\r\n          iTime: { value: 0 },\r\n          iTimeDelta: { value: 0 },\r\n          iFrameRate: { value: this.targetFPS },\r\n          iFrame: { value: 0 },\r\n          iMouse: { value: [0, 0, 0, 0] },\r\n          iDate: { value: [0, 0, 0, 0] },\r\n          iHSV: { value: [this.hsv.hue, this.hsv.saturation, this.hsv.brightness] },\r\n          iSpeed: { value: this._speed },\r\n        },\r\n      });\r\n\r\n      this.program = program;\r\n      this.mesh = new Mesh(this.renderer.gl, {\r\n        geometry: this.geometry,\r\n        program,\r\n      });\r\n\r\n      return true;\r\n    } catch (error) {\r\n      console.error(\"Failed to compile shader:\", error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  private draw(): void {\r\n    if (!this.program || !this.mesh) {\r\n      console.warn(\"Program or mesh not initialized\");\r\n      return;\r\n    }\r\n\r\n    const now = this.isPlaying ? Date.now() : this.prevDrawTime;\r\n\r\n    // Frame rate limiting\r\n    if (this.isPlaying && this.targetFPS < 60) {\r\n      const elapsed = now - this.lastFrameTime;\r\n      if (elapsed < this.frameInterval) {\r\n        requestAnimationFrame(() => this.animate());\r\n        return;\r\n      }\r\n      this.lastFrameTime = now - (elapsed % this.frameInterval);\r\n    }\r\n\r\n    const date = new Date(now);\r\n\r\n    if (this.firstDrawTime === 0) {\r\n      this.firstDrawTime = now;\r\n    }\r\n\r\n    if (this.onDrawCallback) {\r\n      this.onDrawCallback();\r\n    }\r\n\r\n    const iTimeDelta = (now - this.prevDrawTime) * 0.001 * this._speed;\r\n    const iTime = (now - this.firstDrawTime) * 0.001 * this._speed;\r\n    const iDate = [date.getFullYear(), date.getMonth(), date.getDate(), date.getTime() * 0.001];\r\n\r\n    if (this.program && this.mesh) {\r\n      // Update uniforms\r\n      this.program.uniforms.iResolution.value = [\r\n        this.container.clientWidth * window.devicePixelRatio,\r\n        this.container.clientHeight * window.devicePixelRatio,\r\n        window.devicePixelRatio,\r\n      ];\r\n      this.program.uniforms.iTime.value = iTime;\r\n      this.program.uniforms.iTimeDelta.value = iTimeDelta;\r\n      this.program.uniforms.iFrameRate.value = this.targetFPS;\r\n      this.program.uniforms.iFrame.value = this.iFrame;\r\n      this.program.uniforms.iMouse.value = [\r\n        this.iMouse.x,\r\n        this.iMouse.y,\r\n        this.iMouse.clickX,\r\n        this.iMouse.clickY,\r\n      ];\r\n      this.program.uniforms.iDate.value = iDate;\r\n      this.program.uniforms.iHSV.value = [this.hsv.hue, this.hsv.saturation, this.hsv.brightness];\r\n      this.program.uniforms.iSpeed.value = this._speed;\r\n\r\n      // Render\r\n      this.renderer.render({ scene: this.mesh, camera: this.camera });\r\n    }\r\n\r\n    this.prevDrawTime = now;\r\n    this.iFrame++;\r\n  }\r\n\r\n  private animate = (): void => {\r\n    if (this.isPlaying) {\r\n      this.draw();\r\n      requestAnimationFrame(this.animate);\r\n    }\r\n  };\r\n\r\n  // Public methods\r\n  public setShader(config: ShaderConfig): boolean {\r\n    this.shaderSource = config.source;\r\n    const success = this.compileProgram();\r\n\r\n    // If playing, trigger a redraw\r\n    if (success && this.isPlaying) {\r\n      this.draw();\r\n    }\r\n\r\n    return success;\r\n  }\r\n\r\n  public setHSV(hsv: Partial<HSVControls>): void {\r\n    if (hsv.hue !== undefined) this.hsv.hue = hsv.hue;\r\n    if (hsv.saturation !== undefined) this.hsv.saturation = hsv.saturation;\r\n    if (hsv.brightness !== undefined) this.hsv.brightness = hsv.brightness;\r\n\r\n    // Update immediately if not playing\r\n    if (!this.isPlaying && this.program && this.mesh) {\r\n      this.draw();\r\n    }\r\n  }\r\n\r\n  public setHue(val: number) {\r\n    this.hsv.hue = val;\r\n\r\n    // Update immediately if not playing\r\n    if (!this.isPlaying && this.program && this.mesh) {\r\n      this.draw();\r\n    }\r\n  }\r\n\r\n  public setSaturation(val: number) {\r\n    this.hsv.saturation = val;\r\n\r\n    // Update immediately if not playing\r\n    if (!this.isPlaying && this.program && this.mesh) {\r\n      this.draw();\r\n    }\r\n  }\r\n\r\n  public setBrightness(val: number) {\r\n    this.hsv.brightness = val;\r\n\r\n    // Update immediately if not playing\r\n    if (!this.isPlaying && this.program && this.mesh) {\r\n      this.draw();\r\n    }\r\n  }\r\n\r\n  public getHSV(): HSVControls {\r\n    return { ...this.hsv };\r\n  }\r\n  // New speed methods\r\n  public setSpeed(val: number): void {\r\n    this._speed = Math.max(0, val);\r\n\r\n    // Update immediately if not playing\r\n    if (!this.isPlaying && this.program && this.mesh) {\r\n      this.draw();\r\n    }\r\n  }\r\n\r\n  public getSpeed(): number {\r\n    return this._speed;\r\n  }\r\n\r\n  public setFrameRate(fps: number): void {\r\n    this.targetFPS = Math.max(1, Math.min(60, fps));\r\n    this.frameInterval = 1000 / this.targetFPS;\r\n  }\r\n\r\n  public getFrameRate(): number {\r\n    return this.targetFPS;\r\n  }\r\n\r\n  public setOnDraw(callback: () => void): void {\r\n    this.onDrawCallback = callback;\r\n  }\r\n\r\n  public time(): number {\r\n    return (this.prevDrawTime - this.firstDrawTime) * 0.001 * this._speed;\r\n  }\r\n\r\n  public isPlayingState(): boolean {\r\n    return this.isPlaying;\r\n  }\r\n\r\n  public reset(): void {\r\n    const now = Date.now();\r\n    this.firstDrawTime = now;\r\n    this.prevDrawTime = now;\r\n    this.lastFrameTime = now;\r\n    this.iFrame = 0;\r\n    this.draw();\r\n  }\r\n\r\n  public pause(): void {\r\n    this.isPlaying = false;\r\n  }\r\n\r\n  public play(): void {\r\n    if (!this.isPlaying) {\r\n      this.isPlaying = true;\r\n      const now = Date.now();\r\n      const elapsed = this.prevDrawTime - this.firstDrawTime;\r\n      this.firstDrawTime = now - elapsed;\r\n      this.prevDrawTime = now;\r\n      this.lastFrameTime = now;\r\n      this.animate();\r\n    }\r\n  }\r\n\r\n  public dispose(): void {\r\n    this.pause();\r\n    if (this.renderer.gl.canvas.parentElement) {\r\n      this.renderer.gl.canvas.parentElement.removeChild(this.renderer.gl.canvas);\r\n    }\r\n  }\r\n\r\n  // Getters and Setters\r\n  public get mouseMode(): MouseMode {\r\n    return this._mouseMode;\r\n  }\r\n\r\n  public set mouseMode(val: MouseMode) {\r\n    this._mouseMode = val;\r\n  }\r\n  public get speed(): number {\r\n    return this._speed;\r\n  }\r\n\r\n  public set speed(val: number) {\r\n    this.setSpeed(val);\r\n  }\r\n\r\n  // New mouse sensitivity methods\r\n  public setMouseSensitivity(sensitivity: number): void {\r\n    this._mouseSensitivity = Math.max(0.1, Math.min(5.0, sensitivity)); // Clamp between 0.1 and 5.0\r\n  }\r\n\r\n  public getMouseSensitivity(): number {\r\n    return this._mouseSensitivity;\r\n  }\r\n\r\n  // New mouse damping methods\r\n  public setMouseDamping(damping: number): void {\r\n    this._mouseDamping = Math.max(0, Math.min(0.99, damping)); // Clamp between 0 and 0.99\r\n  }\r\n\r\n  public getMouseDamping(): number {\r\n    return this._mouseDamping;\r\n  }\r\n}\r\n"
    },
    {
      "path": "ShaderToy.vue",
      "content": "<template>\r\n  <div\r\n    ref=\"containerRef\"\r\n    :class=\"['shadertoy-container', props.class]\"\r\n  />\r\n</template>\r\n\r\n<script setup lang=\"ts\">\r\nimport { ref, onMounted, onUnmounted, watch, type HTMLAttributes } from \"vue\";\r\nimport { InspiraShaderToy, type MouseMode } from \"./InspiraShaderToy\";\r\n\r\ninterface Props {\r\n  mouseMode?: MouseMode;\r\n  class?: HTMLAttributes[\"class\"];\r\n  shaderCode: string;\r\n  hue?: number;\r\n  saturation?: number;\r\n  brightness?: number;\r\n  speed?: number;\r\n  mouseSensitivity?: number;\r\n  damping?: number;\r\n}\r\n\r\nconst props = withDefaults(defineProps<Props>(), {\r\n  mouseMode: \"click\",\r\n  hue: 0,\r\n  saturation: 1,\r\n  brightness: 1,\r\n  speed: 1,\r\n  mouseSensitivity: 1,\r\n  damping: 0,\r\n});\r\n\r\nconst containerRef = ref<HTMLElement>();\r\nlet shader: InspiraShaderToy | undefined = undefined;\r\n\r\nonMounted(() => {\r\n  if (!containerRef.value) return;\r\n\r\n  shader = new InspiraShaderToy(containerRef.value, props.mouseMode);\r\n\r\n  const success = shader.setShader({\r\n    source: props.shaderCode,\r\n  });\r\n\r\n  if (!success) {\r\n    console.error(\"Failed to compile shader\");\r\n    return;\r\n  }\r\n\r\n  shader.setHSV({\r\n    hue: props.hue,\r\n    saturation: props.saturation,\r\n    brightness: props.brightness,\r\n  });\r\n\r\n  shader.setSpeed(props.speed);\r\n\r\n  shader.setMouseSensitivity(props.mouseSensitivity);\r\n  shader.setMouseDamping(props.damping);\r\n\r\n  shader.play();\r\n});\r\n\r\nonUnmounted(() => {\r\n  shader?.dispose();\r\n});\r\n\r\nwatch(\r\n  () => props.hue,\r\n  (v) => {\r\n    if (v !== undefined && shader) {\r\n      shader.setHue(v);\r\n    }\r\n  },\r\n);\r\n\r\nwatch(\r\n  () => props.saturation,\r\n  (v) => {\r\n    if (v !== undefined && shader) {\r\n      shader.setSaturation(v);\r\n    }\r\n  },\r\n);\r\n\r\nwatch(\r\n  () => props.brightness,\r\n  (v) => {\r\n    if (v !== undefined && shader) {\r\n      shader.setBrightness(v);\r\n    }\r\n  },\r\n);\r\n\r\nwatch(\r\n  () => props.speed,\r\n  (v) => {\r\n    if (v !== undefined && shader) {\r\n      shader.setSpeed(v);\r\n    }\r\n  },\r\n);\r\n\r\nwatch(\r\n  () => props.mouseSensitivity,\r\n  (v) => {\r\n    if (v !== undefined && shader) {\r\n      shader.setMouseSensitivity(v);\r\n    }\r\n  },\r\n);\r\n\r\nwatch(\r\n  () => props.damping,\r\n  (v) => {\r\n    if (v !== undefined && shader) {\r\n      shader.setMouseDamping(v);\r\n    }\r\n  },\r\n);\r\n</script>\r\n\r\n<style scoped>\r\n.shadertoy-container {\r\n  display: block;\r\n  position: relative;\r\n  height: 100%;\r\n  width: 100%;\r\n}\r\n\r\n.shadertoy-container canvas {\r\n  display: block;\r\n  max-width: 100%;\r\n  width: 100%;\r\n  height: 100%;\r\n  cursor: pointer;\r\n}\r\n</style>\r\n",
      "target": "web"
    },
    {
      "path": "ShaderToy.vue",
      "content": "<template>\r\n  <view\r\n    ref=\"containerRef\"\r\n    :class=\"['shadertoy-container', props.class]\"\r\n  />\r\n</template>\r\n\r\n<script setup lang=\"ts\">\r\nimport { ref, onMounted, onUnmounted, watch, type HTMLAttributes } from \"vue\";\r\nimport { InspiraShaderToy, type MouseMode } from \"./InspiraShaderToy\";\r\n\r\ninterface Props {\r\n  mouseMode?: MouseMode;\r\n  class?: HTMLAttributes[\"class\"];\r\n  shaderCode: string;\r\n  hue?: number;\r\n  saturation?: number;\r\n  brightness?: number;\r\n  speed?: number;\r\n  mouseSensitivity?: number;\r\n  damping?: number;\r\n}\r\n\r\nconst props = withDefaults(defineProps<Props>(), {\r\n  mouseMode: \"click\",\r\n  hue: 0,\r\n  saturation: 1,\r\n  brightness: 1,\r\n  speed: 1,\r\n  mouseSensitivity: 1,\r\n  damping: 0,\r\n});\r\n\r\nconst containerRef = ref<HTMLElement>();\r\nlet shader: InspiraShaderToy | undefined = undefined;\r\n\r\nonMounted(() => {\r\n  if (!containerRef.value) return;\r\n\r\n  shader = new InspiraShaderToy(containerRef.value, props.mouseMode);\r\n\r\n  const success = shader.setShader({\r\n    source: props.shaderCode,\r\n  });\r\n\r\n  if (!success) {\r\n    console.error(\"Failed to compile shader\");\r\n    return;\r\n  }\r\n\r\n  shader.setHSV({\r\n    hue: props.hue,\r\n    saturation: props.saturation,\r\n    brightness: props.brightness,\r\n  });\r\n\r\n  shader.setSpeed(props.speed);\r\n\r\n  shader.setMouseSensitivity(props.mouseSensitivity);\r\n  shader.setMouseDamping(props.damping);\r\n\r\n  shader.play();\r\n});\r\n\r\nonUnmounted(() => {\r\n  shader?.dispose();\r\n});\r\n\r\nwatch(\r\n  () => props.hue,\r\n  (v) => {\r\n    if (v !== undefined && shader) {\r\n      shader.setHue(v);\r\n    }\r\n  },\r\n);\r\n\r\nwatch(\r\n  () => props.saturation,\r\n  (v) => {\r\n    if (v !== undefined && shader) {\r\n      shader.setSaturation(v);\r\n    }\r\n  },\r\n);\r\n\r\nwatch(\r\n  () => props.brightness,\r\n  (v) => {\r\n    if (v !== undefined && shader) {\r\n      shader.setBrightness(v);\r\n    }\r\n  },\r\n);\r\n\r\nwatch(\r\n  () => props.speed,\r\n  (v) => {\r\n    if (v !== undefined && shader) {\r\n      shader.setSpeed(v);\r\n    }\r\n  },\r\n);\r\n\r\nwatch(\r\n  () => props.mouseSensitivity,\r\n  (v) => {\r\n    if (v !== undefined && shader) {\r\n      shader.setMouseSensitivity(v);\r\n    }\r\n  },\r\n);\r\n\r\nwatch(\r\n  () => props.damping,\r\n  (v) => {\r\n    if (v !== undefined && shader) {\r\n      shader.setMouseDamping(v);\r\n    }\r\n  },\r\n);\r\n</script>\r\n\r\n<style scoped>\r\n.shadertoy-container {\r\n  display: block;\r\n  position: relative;\r\n  height: 100%;\r\n  width: 100%;\r\n}\r\n\r\n.shadertoy-container canvas {\r\n  display: block;\r\n  max-width: 100%;\r\n  width: 100%;\r\n  height: 100%;\r\n  cursor: pointer;\r\n}\r\n</style>\r\n",
      "target": "uniapp"
    }
  ],
  "fileCount": 4,
  "contentHash": "1bb9b8b4e405223729e0f05ef82fcaf10a32fca0"
}
