{
  "name": "bg-stractium",
  "dependencies": [],
  "files": [
    {
      "path": "index.ts",
      "content": "export { default as StractiumBackground } from \"./StractiumBackground.vue\";\r\n"
    },
    {
      "path": "StractiumBackground.vue",
      "content": "<template>\r\n  <div :class=\"cn('absolute inset-0', props.class)\">\r\n    <ShaderToy\r\n      :shader-code=\"shader\"\r\n      :hue=\"props.hue\"\r\n      :saturation=\"props.saturation\"\r\n      :brightness=\"props.brightness\"\r\n      :speed=\"props.speed\"\r\n      :mouse-sensitivity=\"props.mouseSensitivity\"\r\n      :damping=\"props.damping\"\r\n    />\r\n  </div>\r\n</template>\r\n\r\n<script lang=\"ts\" setup>\r\nimport type { HTMLAttributes } from \"vue\";\r\nimport { cn } from \"~/lib/utils\";\r\n\r\ninterface Props {\r\n  class?: HTMLAttributes[\"class\"];\r\n  hue?: number;\r\n  saturation?: number;\r\n  brightness?: number;\r\n  speed?: number;\r\n  mouseSensitivity?: number;\r\n  damping?: number;\r\n}\r\n\r\nconst props = withDefaults(defineProps<Props>(), {\r\n  hue: 0,\r\n  saturation: 1,\r\n  brightness: 1,\r\n  speed: 1,\r\n  mouseSensitivity: 0.5,\r\n  damping: 1,\r\n});\r\n\r\nconst shader = `\r\n// ShaderToy URL: https://www.shadertoy.com/view/Mlf3R4\r\n\r\n// Set this to change detail level. [1 - 10] is a good range.\r\nconst int NUM_SIN_REPS = 9;\r\nconst int MAX_MARCH_REPS = 250;\r\nconst float MARCH_DISTANCE_MULTIPLIER = 0.1;\r\n\r\nfloat localTime = 0.0;\r\n\r\n// some noise functions\r\nfloat Hash(float f)\r\n{\r\n    return fract(cos(f)*7561.0);\r\n}\r\nfloat Hash2d(vec2 uv)\r\n{\r\n    float f = uv.x + uv.y * 521.0;\t// repeats after this value\r\n    float rand = fract(cos(f)*104729.0);\r\n    return rand;\r\n}\r\nvec2 Hash2(vec2 v)\r\n{\r\n    return fract(cos(v*3.333)*vec2(100003.9, 37049.7));\r\n}\r\nfloat Hash3d(vec3 uv)\r\n{\r\n    float f = uv.x + uv.y * 37.0 + uv.z * 521.0;\r\n    return fract(sin(f)*110003.9);\r\n}\r\n\r\nfloat mixS(float f0, float f1, float a)\r\n{\r\n    if (a < 0.5) return f0;\r\n    return f1;\r\n}\r\n\r\nfloat mixC(float f0, float f1, float a)\r\n{\r\n    return mix(f1, f0, cos(a*3.1415926) *0.5+0.5);\r\n}\r\n\r\nfloat mixP(float f0, float f1, float a)\r\n{\r\n    return mix(f0, f1, a*a*(3.0-2.0*a));\r\n}\r\nvec2 mixP2(vec2 v0, vec2 v1, float a)\r\n{\r\n    return mix(v0, v1, a*a*(3.0-2.0*a));\r\n}\r\n\r\nfloat mixSS(float f0, float f1, float a)\r\n{\r\n    return mix(f0, f1, smoothstep(0.0, 1.0, a));\r\n}\r\n\r\nconst vec2 zeroOne = vec2(0.0, 1.0);\r\nfloat noise2dVec(vec2 uv)\r\n{\r\n    vec2 fr = fract(uv);\r\n    vec2 fl = floor(uv);\r\n    vec2 h0 = vec2(Hash2d(fl), Hash2d(fl + zeroOne));\r\n    vec2 h1 = vec2(Hash2d(fl + zeroOne.yx), Hash2d(fl + zeroOne.yy));\r\n    vec2 xMix = mixP2(h0, h1, fr.x);\r\n    return mixC(xMix.x, xMix.y, fr.y);\r\n}\r\nfloat noise2d(vec2 uv)\r\n{\r\n    vec2 fr = fract(uv);\r\n    vec2 fl = floor(uv);\r\n    float h00 = Hash2d(fl);\r\n    float h10 = Hash2d(fl + zeroOne.yx);\r\n    float h01 = Hash2d(fl + zeroOne);\r\n    float h11 = Hash2d(fl + zeroOne.yy);\r\n    return mixP(mixP(h00, h10, fr.x), mixP(h01, h11, fr.x), fr.y);\r\n}\r\nfloat noise(vec3 uv)\r\n{\r\n    vec3 fr = fract(uv.xyz);\r\n    vec3 fl = floor(uv.xyz);\r\n    float h000 = Hash3d(fl);\r\n    float h100 = Hash3d(fl + zeroOne.yxx);\r\n    float h010 = Hash3d(fl + zeroOne.xyx);\r\n    float h110 = Hash3d(fl + zeroOne.yyx);\r\n    float h001 = Hash3d(fl + zeroOne.xxy);\r\n    float h101 = Hash3d(fl + zeroOne.yxy);\r\n    float h011 = Hash3d(fl + zeroOne.xyy);\r\n    float h111 = Hash3d(fl + zeroOne.yyy);\r\n    return mixP(\r\n        mixP(mixP(h000, h100, fr.x),\r\n             mixP(h010, h110, fr.x), fr.y),\r\n        mixP(mixP(h001, h101, fr.x),\r\n             mixP(h011, h111, fr.x), fr.y)\r\n        , fr.z);\r\n}\r\n\r\nfloat PI=3.14159265;\r\n\r\nvec3 saturate(vec3 a) { return clamp(a, 0.0, 1.0); }\r\nvec2 saturate(vec2 a) { return clamp(a, 0.0, 1.0); }\r\nfloat saturate(float a) { return clamp(a, 0.0, 1.0); }\r\n\r\nvec3 RotateX(vec3 v, float rad)\r\n{\r\n  float cos = cos(rad);\r\n  float sin = sin(rad);\r\n  //if (RIGHT_HANDED_COORD)\r\n  return vec3(v.x, cos * v.y + sin * v.z, -sin * v.y + cos * v.z);\r\n  //else return new float3(x, cos * y - sin * z, sin * y + cos * z);\r\n}\r\nvec3 RotateY(vec3 v, float rad)\r\n{\r\n  float cos = cos(rad);\r\n  float sin = sin(rad);\r\n  //if (RIGHT_HANDED_COORD)\r\n  return vec3(cos * v.x - sin * v.z, v.y, sin * v.x + cos * v.z);\r\n  //else return new float3(cos * x + sin * z, y, -sin * x + cos * z);\r\n}\r\nvec3 RotateZ(vec3 v, float rad)\r\n{\r\n  float cos = cos(rad);\r\n  float sin = sin(rad);\r\n  //if (RIGHT_HANDED_COORD)\r\n  return vec3(cos * v.x + sin * v.y, -sin * v.x + cos * v.y, v.z);\r\n}\r\n\r\n\r\n// This function basically is a procedural environment map that makes the sun\r\nvec3 sunCol = vec3(258.0, 228.0, 170.0) / 3555.0;//unfortunately, i seem to have 2 different sun colors. :(\r\nvec3 GetSunColorReflection(vec3 rayDir, vec3 sunDir)\r\n{\r\n\tvec3 localRay = normalize(rayDir);\r\n\tfloat dist = 1.0 - (dot(localRay, sunDir) * 0.5 + 0.5);\r\n\tfloat sunIntensity = 0.015 / dist;\r\n\tsunIntensity = pow(sunIntensity, 0.3)*100.0;\r\n\r\n    sunIntensity += exp(-dist*12.0)*300.0;\r\n\tsunIntensity = min(sunIntensity, 40000.0);\r\n    //vec3 skyColor = mix(vec3(1.0, 0.95, 0.85), vec3(0.2,0.3,0.95), pow(saturate(rayDir.y), 0.7))*skyMultiplier*0.95;\r\n\treturn sunCol * sunIntensity*0.0425;\r\n}\r\nvec3 GetSunColorSmall(vec3 rayDir, vec3 sunDir)\r\n{\r\n\tvec3 localRay = normalize(rayDir);\r\n\tfloat dist = 1.0 - (dot(localRay, sunDir) * 0.5 + 0.5);\r\n\tfloat sunIntensity = 0.05 / dist;\r\n    sunIntensity += exp(-dist*12.0)*300.0;\r\n\tsunIntensity = min(sunIntensity, 40000.0);\r\n\treturn sunCol * sunIntensity*0.025;\r\n}\r\n\r\nvec4 cXX = vec4(0.0, 3.0, 0.0, 0.0);\r\n\r\nvec3 camPos = vec3(0.0), camFacing;\r\nvec3 camLookat=vec3(0,0.0,0);\r\n\r\nfloat SinRep(float a)\r\n{\r\n    float h = 0.0;\r\n    float mult = 1.0;\r\n    for (int i = 0; i < NUM_SIN_REPS; i++)\r\n    {\r\n        h += (cos(a*mult)/(mult));\r\n        mult *= 2.0;\r\n    }\r\n    return h;\r\n}\r\n\r\nvec2 DistanceToObject(vec3 p)\r\n{\r\n    float material = 0.0;\r\n    float h = 0.0;\r\n    p = RotateY(p, p.y*0.4 - cos(localTime)*0.4);\r\n    h += SinRep(RotateY(p, p.z*3.14*0.25).x);\r\n    h += SinRep(RotateZ(p, p.x*3.14*0.25).y);\r\n    h += SinRep(RotateX(p, p.y*3.14*0.25).z);\r\n    material = h;\r\n    //h += SinRep(RotateX(p, p.y).z);\r\n    //h += SinRep(RotateZ(p, sin(h)).y);\r\n    //h += SinRep(RotateY(p, h*1.0).x);\r\n    //h += SinRep(p.x+h)*0.5;\r\n    //h += SinRep(p.y+h)*0.5;\r\n    float final = (length(p)-4.0 - h*(0.25 + sin(localTime)*0.35));\r\n    return vec2(final, material);\r\n}\r\n\r\nfloat distFromSphere;\r\nfloat IntersectSphereAndRay(vec3 pos, float radius, vec3 posA, vec3 posB, out vec3 intersectA2, out vec3 intersectB2)\r\n{\r\n\t// Use dot product along line to find closest point on line\r\n\tvec3 eyeVec2 = normalize(posB-posA);\r\n\tfloat dp = dot(eyeVec2, pos - posA);\r\n\tvec3 pointOnLine = eyeVec2 * dp + posA;\r\n\t// Clamp that point to line end points if outside\r\n\t//if ((dp - radius) < 0) pointOnLine = posA;\r\n\t//if ((dp + radius) > (posB-posA).Length()) pointOnLine = posB;\r\n\t// Distance formula from that point to sphere center, compare with radius.\r\n\tfloat distance = length(pointOnLine - pos);\r\n\tfloat ac = radius*radius - distance*distance;\r\n\tfloat rightLen = 0.0;\r\n\tif (ac >= 0.0) rightLen = sqrt(ac);\r\n\tintersectA2 = pointOnLine - eyeVec2 * rightLen;\r\n\tintersectB2 = pointOnLine + eyeVec2 * rightLen;\r\n\tdistFromSphere = distance - radius;\r\n\tif (distance <= radius) return 1.0;\r\n\treturn 0.0;\r\n}\r\n\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    localTime = iTime - 1.6;\r\n\t// ---------------- First, set up the camera rays for ray marching ----------------\r\n\tvec2 uv = fragCoord.xy/iResolution.xy * 2.0 - 1.0;\r\n\r\n\t// Camera up vector.\r\n\tvec3 camUp=vec3(0,1,0); // vuv\r\n\r\n\t// Camera lookat.\r\n\tcamLookat=vec3(0,0.0,0);\t// vrp\r\n\r\n    // debugging camera\r\n    float mx=iMouse.x/iResolution.x*PI*2.0-0.7 + localTime * 0.123;\r\n\tfloat my=-iMouse.y/iResolution.y*10.0 - sin(localTime * 0.31)*0.5;//*PI/2.01;\r\n\tcamPos += vec3(cos(my)*cos(mx),sin(my),cos(my)*sin(mx))*(9.2); \t// prp\r\n\r\n\r\n    // add randomness to camera for depth-of-field look close up.\r\n    //camPos += vec3(Hash2d(uv)*0.91, Hash2d(uv+37.0), Hash2d(uv+47.0))*0.01;\r\n\r\n\t// Camera setup.\r\n\tvec3 camVec=normalize(camLookat - camPos);//vpn\r\n\tvec3 sideNorm=normalize(cross(camUp, camVec));\t// u\r\n\tvec3 upNorm=cross(camVec, sideNorm);//v\r\n\tvec3 worldFacing=(camPos + camVec);//vcv\r\n\tvec3 worldPix = worldFacing + uv.x * sideNorm * (iResolution.x/iResolution.y) + uv.y * upNorm;//scrCoord\r\n\tvec3 relVec = normalize(worldPix - camPos);//scp\r\n\r\n\t// --------------------------------------------------------------------------------\r\n\t// I put a bounding sphere around the whole object. If the ray is outside\r\n\t// of the bounding sphere, I don't bother ray marching. It's just an optimization.\r\n\tvec3 iA, iB;\r\n\tfloat hit = IntersectSphereAndRay(vec3(0,0,0), 7.6, camPos, camPos+relVec, iA, iB);\r\n\r\n\t// --------------------------------------------------------------------------------\r\n\tvec2 distAndMat = vec2(0.05, 0.0);\r\n\tfloat t = 0.0;\r\n\tfloat inc = 0.02;\r\n\tfloat maxDepth = 110.0;\r\n\tvec3 pos = vec3(0,0,0);\r\n    // start and end the camera ray at the sphere intersections.\r\n    camPos = iA;\r\n    maxDepth = distance(iA, iB);\r\n\t// ray marching time\r\n\tif (hit > 0.5)\t// check if inside bounding sphere before wasting time ray marching.\r\n\t{\r\n        for (int i = 0; i < MAX_MARCH_REPS; i++)\t// This is the count of the max times the ray actually marches.\r\n        {\r\n            if ((t > maxDepth) || (abs(distAndMat.x) < 0.0075)) break;\r\n            pos = camPos + relVec * t;\r\n            // *******************************************************\r\n            // This is _the_ function that defines the \"distance field\".\r\n            // It's really what makes the scene geometry.\r\n            // *******************************************************\r\n            distAndMat = DistanceToObject(pos);\r\n            // adjust by constant because deformations mess up distance function.\r\n            t += distAndMat.x * MARCH_DISTANCE_MULTIPLIER;\r\n        }\r\n    }\r\n    else\r\n    {\r\n\t\tt = maxDepth + 1.0;\r\n        distAndMat.x = 1.0;\r\n    }\r\n\t// --------------------------------------------------------------------------------\r\n\t// Now that we have done our ray marching, let's put some color on this geometry.\r\n\r\n\tvec3 sunDir = normalize(vec3(0.93, 1.0, -1.5));\r\n\tvec3 finalColor = vec3(0.0);\r\n\r\n\t// If a ray actually hit the object, let's light it.\r\n\tif (abs(distAndMat.x) < 0.75)\r\n    //if (t <= maxDepth)\r\n\t{\r\n        // calculate the normal from the distance field. The distance field is a volume, so if you\r\n        // sample the current point and neighboring points, you can use the difference to get\r\n        // the normal.\r\n        vec3 smallVec = vec3(0.005, 0, 0);\r\n        vec3 normalU = vec3(distAndMat.x - DistanceToObject(pos - smallVec.xyy).x,\r\n                           distAndMat.x - DistanceToObject(pos - smallVec.yxy).x,\r\n                           distAndMat.x - DistanceToObject(pos - smallVec.yyx).x);\r\n\r\n        vec3 normal = normalize(normalU);\r\n\r\n        // calculate 2 ambient occlusion values. One for global stuff and one\r\n        // for local stuff - so the green sphere light source can also have ambient.\r\n        float ambientS = 1.0;\r\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.1).x*10.0);\r\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.2).x*5.0);\r\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.4).x*2.5);\r\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.8).x*1.25);\r\n        float ambient = ambientS * saturate(DistanceToObject(pos + normal * 1.6).x*1.25*0.5);\r\n        ambient *= saturate(DistanceToObject(pos + normal * 3.2).x*1.25*0.25);\r\n        ambient *= saturate(DistanceToObject(pos + normal * 6.4).x*1.25*0.125);\r\n        ambient = max(0.15, pow(ambient, 0.3));\t// tone down ambient with a pow and min clamp it.\r\n        ambient = saturate(ambient);\r\n\r\n        // Trace a ray toward the sun for sun shadows\r\n        float sunShadow = 1.0;\r\n        float iter = 0.2;\r\n\t\tfor (int i = 0; i < 10; i++)\r\n        {\r\n            float tempDist = DistanceToObject(pos + sunDir * iter).x;\r\n\t        sunShadow *= saturate(tempDist*10.0);\r\n            if (tempDist <= 0.0) break;\r\n            iter *= 1.5;\t// constant is more reliable than distance-based\r\n            //iter += max(0.2, tempDist)*1.2;\r\n        }\r\n        sunShadow = saturate(sunShadow);\r\n\r\n        // calculate the reflection vector for highlights\r\n        vec3 ref = reflect(relVec, normal);\r\n\r\n        // ------ Calculate texture color of the rock ------\r\n        // base texture can be swirled noise.\r\n\t\tvec3 rp = RotateY(pos, pos.y*0.4 - cos(localTime)*0.4);\r\n        float n = noise(rp*4.0) + noise(rp*8.0) + noise(rp*16.0) + noise(rp*32.0);\r\n        n = saturate(n*0.25 * 0.95 + 0.05);\r\n        vec3 texColor = vec3(0.2,0.3,0.3)*n;\r\n\r\n        // fade to reddish texture on outside\r\n        texColor += vec3(0.99, 0.21, 0.213) * clamp(length(pos)-4.0, 0.0, 0.4);\r\n        // give it green-blue texture that matches the shape using normal length\r\n        texColor += vec3(1.0, 21.0, 26.0)*0.6 * saturate(length(normalU)-0.01);\r\n        // Give it a reddish-rust color in the middle\r\n        texColor -= vec3(0.0, 0.3, 0.5)*saturate(-distAndMat.y*(0.9+sin(localTime+0.5)*0.9));\r\n        // make sure it's not too saturated so it looks realistic\r\n        texColor = max(vec3(0.02),texColor);\r\n\r\n        // ------ Calculate lighting color ------\r\n        // Start with sun color, standard lighting equation, and shadow\r\n        vec3 lightColor = sunCol * saturate(dot(sunDir, normal)) * sunShadow*14.0;\r\n        // sky color, hemisphere light equation approximation, anbient occlusion\r\n        lightColor += vec3(0.1,0.35,0.95) * (normal.y * 0.5 + 0.5) * ambient * 0.25;\r\n        // ground color - another hemisphere light\r\n        lightColor += vec3(1.0) * ((-normal.y) * 0.5 + 0.5) * ambient * 0.2;\r\n\r\n        // finally, apply the light to the texture.\r\n        finalColor = texColor * lightColor;\r\n\r\n        // specular highlights - just a little\r\n        vec3 refColor = GetSunColorReflection(ref, sunDir)*0.68;\r\n        finalColor += refColor * sunCol * sunShadow * 9.0 * texColor.g;\r\n\r\n        // fog that fades to sun color so that fog is brightest towards sun\r\n        finalColor = mix(vec3(0.98, 0.981, 0.981) + min(vec3(0.25),GetSunColorSmall(relVec, sunDir))*2.0, finalColor, exp(-t*0.007));\r\n        //finalColor = vec3(1.0, 21.0, 26.0) * saturate(length(normalU)-0.01);\r\n\t}\r\n    else\r\n    {\r\n        // Our ray trace hit nothing, so draw sky.\r\n        // fade the sky color, multiply sunset dimming\r\n        finalColor = mix(vec3(1.0, 0.95, 0.85), vec3(0.2,0.5,0.95), pow(saturate(relVec.y), 0.7))*0.95;\r\n        // add the sun\r\n        finalColor += GetSunColorSmall(relVec, sunDir);// + vec3(0.1, 0.1, 0.1);\r\n    }\r\n\r\n    // vignette?\r\n    finalColor *= vec3(1.0) * saturate(1.0 - length(uv/2.5));\r\n    finalColor *= 1.95;\r\n\r\n\t// output the final color with sqrt for \"gamma correction\"\r\n\tfragColor = vec4(sqrt(clamp(finalColor, 0.0, 1.0)),1.0);\r\n}\r\n`;\r\n</script>\r\n",
      "target": "web"
    },
    {
      "path": "StractiumBackground.vue",
      "content": "<template>\r\n  <view :class=\"cn('absolute inset-0', props.class)\">\r\n    <ShaderToy\r\n      :shader-code=\"shader\"\r\n      :hue=\"props.hue\"\r\n      :saturation=\"props.saturation\"\r\n      :brightness=\"props.brightness\"\r\n      :speed=\"props.speed\"\r\n      :mouse-sensitivity=\"props.mouseSensitivity\"\r\n      :damping=\"props.damping\"\r\n    />\r\n  </view>\r\n</template>\r\n\r\n<script lang=\"ts\" setup>\r\nimport type { HTMLAttributes } from \"vue\";\r\nimport { cn } from \"~/lib/utils\";\r\n\r\ninterface Props {\r\n  class?: HTMLAttributes[\"class\"];\r\n  hue?: number;\r\n  saturation?: number;\r\n  brightness?: number;\r\n  speed?: number;\r\n  mouseSensitivity?: number;\r\n  damping?: number;\r\n}\r\n\r\nconst props = withDefaults(defineProps<Props>(), {\r\n  hue: 0,\r\n  saturation: 1,\r\n  brightness: 1,\r\n  speed: 1,\r\n  mouseSensitivity: 0.5,\r\n  damping: 1,\r\n});\r\n\r\nconst shader = `\r\n// ShaderToy URL: https://www.shadertoy.com/view/Mlf3R4\r\n\r\n// Set this to change detail level. [1 - 10] is a good range.\r\nconst int NUM_SIN_REPS = 9;\r\nconst int MAX_MARCH_REPS = 250;\r\nconst float MARCH_DISTANCE_MULTIPLIER = 0.1;\r\n\r\nfloat localTime = 0.0;\r\n\r\n// some noise functions\r\nfloat Hash(float f)\r\n{\r\n    return fract(cos(f)*7561.0);\r\n}\r\nfloat Hash2d(vec2 uv)\r\n{\r\n    float f = uv.x + uv.y * 521.0;\t// repeats after this value\r\n    float rand = fract(cos(f)*104729.0);\r\n    return rand;\r\n}\r\nvec2 Hash2(vec2 v)\r\n{\r\n    return fract(cos(v*3.333)*vec2(100003.9, 37049.7));\r\n}\r\nfloat Hash3d(vec3 uv)\r\n{\r\n    float f = uv.x + uv.y * 37.0 + uv.z * 521.0;\r\n    return fract(sin(f)*110003.9);\r\n}\r\n\r\nfloat mixS(float f0, float f1, float a)\r\n{\r\n    if (a < 0.5) return f0;\r\n    return f1;\r\n}\r\n\r\nfloat mixC(float f0, float f1, float a)\r\n{\r\n    return mix(f1, f0, cos(a*3.1415926) *0.5+0.5);\r\n}\r\n\r\nfloat mixP(float f0, float f1, float a)\r\n{\r\n    return mix(f0, f1, a*a*(3.0-2.0*a));\r\n}\r\nvec2 mixP2(vec2 v0, vec2 v1, float a)\r\n{\r\n    return mix(v0, v1, a*a*(3.0-2.0*a));\r\n}\r\n\r\nfloat mixSS(float f0, float f1, float a)\r\n{\r\n    return mix(f0, f1, smoothstep(0.0, 1.0, a));\r\n}\r\n\r\nconst vec2 zeroOne = vec2(0.0, 1.0);\r\nfloat noise2dVec(vec2 uv)\r\n{\r\n    vec2 fr = fract(uv);\r\n    vec2 fl = floor(uv);\r\n    vec2 h0 = vec2(Hash2d(fl), Hash2d(fl + zeroOne));\r\n    vec2 h1 = vec2(Hash2d(fl + zeroOne.yx), Hash2d(fl + zeroOne.yy));\r\n    vec2 xMix = mixP2(h0, h1, fr.x);\r\n    return mixC(xMix.x, xMix.y, fr.y);\r\n}\r\nfloat noise2d(vec2 uv)\r\n{\r\n    vec2 fr = fract(uv);\r\n    vec2 fl = floor(uv);\r\n    float h00 = Hash2d(fl);\r\n    float h10 = Hash2d(fl + zeroOne.yx);\r\n    float h01 = Hash2d(fl + zeroOne);\r\n    float h11 = Hash2d(fl + zeroOne.yy);\r\n    return mixP(mixP(h00, h10, fr.x), mixP(h01, h11, fr.x), fr.y);\r\n}\r\nfloat noise(vec3 uv)\r\n{\r\n    vec3 fr = fract(uv.xyz);\r\n    vec3 fl = floor(uv.xyz);\r\n    float h000 = Hash3d(fl);\r\n    float h100 = Hash3d(fl + zeroOne.yxx);\r\n    float h010 = Hash3d(fl + zeroOne.xyx);\r\n    float h110 = Hash3d(fl + zeroOne.yyx);\r\n    float h001 = Hash3d(fl + zeroOne.xxy);\r\n    float h101 = Hash3d(fl + zeroOne.yxy);\r\n    float h011 = Hash3d(fl + zeroOne.xyy);\r\n    float h111 = Hash3d(fl + zeroOne.yyy);\r\n    return mixP(\r\n        mixP(mixP(h000, h100, fr.x),\r\n             mixP(h010, h110, fr.x), fr.y),\r\n        mixP(mixP(h001, h101, fr.x),\r\n             mixP(h011, h111, fr.x), fr.y)\r\n        , fr.z);\r\n}\r\n\r\nfloat PI=3.14159265;\r\n\r\nvec3 saturate(vec3 a) { return clamp(a, 0.0, 1.0); }\r\nvec2 saturate(vec2 a) { return clamp(a, 0.0, 1.0); }\r\nfloat saturate(float a) { return clamp(a, 0.0, 1.0); }\r\n\r\nvec3 RotateX(vec3 v, float rad)\r\n{\r\n  float cos = cos(rad);\r\n  float sin = sin(rad);\r\n  //if (RIGHT_HANDED_COORD)\r\n  return vec3(v.x, cos * v.y + sin * v.z, -sin * v.y + cos * v.z);\r\n  //else return new float3(x, cos * y - sin * z, sin * y + cos * z);\r\n}\r\nvec3 RotateY(vec3 v, float rad)\r\n{\r\n  float cos = cos(rad);\r\n  float sin = sin(rad);\r\n  //if (RIGHT_HANDED_COORD)\r\n  return vec3(cos * v.x - sin * v.z, v.y, sin * v.x + cos * v.z);\r\n  //else return new float3(cos * x + sin * z, y, -sin * x + cos * z);\r\n}\r\nvec3 RotateZ(vec3 v, float rad)\r\n{\r\n  float cos = cos(rad);\r\n  float sin = sin(rad);\r\n  //if (RIGHT_HANDED_COORD)\r\n  return vec3(cos * v.x + sin * v.y, -sin * v.x + cos * v.y, v.z);\r\n}\r\n\r\n\r\n// This function basically is a procedural environment map that makes the sun\r\nvec3 sunCol = vec3(258.0, 228.0, 170.0) / 3555.0;//unfortunately, i seem to have 2 different sun colors. :(\r\nvec3 GetSunColorReflection(vec3 rayDir, vec3 sunDir)\r\n{\r\n\tvec3 localRay = normalize(rayDir);\r\n\tfloat dist = 1.0 - (dot(localRay, sunDir) * 0.5 + 0.5);\r\n\tfloat sunIntensity = 0.015 / dist;\r\n\tsunIntensity = pow(sunIntensity, 0.3)*100.0;\r\n\r\n    sunIntensity += exp(-dist*12.0)*300.0;\r\n\tsunIntensity = min(sunIntensity, 40000.0);\r\n    //vec3 skyColor = mix(vec3(1.0, 0.95, 0.85), vec3(0.2,0.3,0.95), pow(saturate(rayDir.y), 0.7))*skyMultiplier*0.95;\r\n\treturn sunCol * sunIntensity*0.0425;\r\n}\r\nvec3 GetSunColorSmall(vec3 rayDir, vec3 sunDir)\r\n{\r\n\tvec3 localRay = normalize(rayDir);\r\n\tfloat dist = 1.0 - (dot(localRay, sunDir) * 0.5 + 0.5);\r\n\tfloat sunIntensity = 0.05 / dist;\r\n    sunIntensity += exp(-dist*12.0)*300.0;\r\n\tsunIntensity = min(sunIntensity, 40000.0);\r\n\treturn sunCol * sunIntensity*0.025;\r\n}\r\n\r\nvec4 cXX = vec4(0.0, 3.0, 0.0, 0.0);\r\n\r\nvec3 camPos = vec3(0.0), camFacing;\r\nvec3 camLookat=vec3(0,0.0,0);\r\n\r\nfloat SinRep(float a)\r\n{\r\n    float h = 0.0;\r\n    float mult = 1.0;\r\n    for (int i = 0; i < NUM_SIN_REPS; i++)\r\n    {\r\n        h += (cos(a*mult)/(mult));\r\n        mult *= 2.0;\r\n    }\r\n    return h;\r\n}\r\n\r\nvec2 DistanceToObject(vec3 p)\r\n{\r\n    float material = 0.0;\r\n    float h = 0.0;\r\n    p = RotateY(p, p.y*0.4 - cos(localTime)*0.4);\r\n    h += SinRep(RotateY(p, p.z*3.14*0.25).x);\r\n    h += SinRep(RotateZ(p, p.x*3.14*0.25).y);\r\n    h += SinRep(RotateX(p, p.y*3.14*0.25).z);\r\n    material = h;\r\n    //h += SinRep(RotateX(p, p.y).z);\r\n    //h += SinRep(RotateZ(p, sin(h)).y);\r\n    //h += SinRep(RotateY(p, h*1.0).x);\r\n    //h += SinRep(p.x+h)*0.5;\r\n    //h += SinRep(p.y+h)*0.5;\r\n    float final = (length(p)-4.0 - h*(0.25 + sin(localTime)*0.35));\r\n    return vec2(final, material);\r\n}\r\n\r\nfloat distFromSphere;\r\nfloat IntersectSphereAndRay(vec3 pos, float radius, vec3 posA, vec3 posB, out vec3 intersectA2, out vec3 intersectB2)\r\n{\r\n\t// Use dot product along line to find closest point on line\r\n\tvec3 eyeVec2 = normalize(posB-posA);\r\n\tfloat dp = dot(eyeVec2, pos - posA);\r\n\tvec3 pointOnLine = eyeVec2 * dp + posA;\r\n\t// Clamp that point to line end points if outside\r\n\t//if ((dp - radius) < 0) pointOnLine = posA;\r\n\t//if ((dp + radius) > (posB-posA).Length()) pointOnLine = posB;\r\n\t// Distance formula from that point to sphere center, compare with radius.\r\n\tfloat distance = length(pointOnLine - pos);\r\n\tfloat ac = radius*radius - distance*distance;\r\n\tfloat rightLen = 0.0;\r\n\tif (ac >= 0.0) rightLen = sqrt(ac);\r\n\tintersectA2 = pointOnLine - eyeVec2 * rightLen;\r\n\tintersectB2 = pointOnLine + eyeVec2 * rightLen;\r\n\tdistFromSphere = distance - radius;\r\n\tif (distance <= radius) return 1.0;\r\n\treturn 0.0;\r\n}\r\n\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    localTime = iTime - 1.6;\r\n\t// ---------------- First, set up the camera rays for ray marching ----------------\r\n\tvec2 uv = fragCoord.xy/iResolution.xy * 2.0 - 1.0;\r\n\r\n\t// Camera up vector.\r\n\tvec3 camUp=vec3(0,1,0); // vuv\r\n\r\n\t// Camera lookat.\r\n\tcamLookat=vec3(0,0.0,0);\t// vrp\r\n\r\n    // debugging camera\r\n    float mx=iMouse.x/iResolution.x*PI*2.0-0.7 + localTime * 0.123;\r\n\tfloat my=-iMouse.y/iResolution.y*10.0 - sin(localTime * 0.31)*0.5;//*PI/2.01;\r\n\tcamPos += vec3(cos(my)*cos(mx),sin(my),cos(my)*sin(mx))*(9.2); \t// prp\r\n\r\n\r\n    // add randomness to camera for depth-of-field look close up.\r\n    //camPos += vec3(Hash2d(uv)*0.91, Hash2d(uv+37.0), Hash2d(uv+47.0))*0.01;\r\n\r\n\t// Camera setup.\r\n\tvec3 camVec=normalize(camLookat - camPos);//vpn\r\n\tvec3 sideNorm=normalize(cross(camUp, camVec));\t// u\r\n\tvec3 upNorm=cross(camVec, sideNorm);//v\r\n\tvec3 worldFacing=(camPos + camVec);//vcv\r\n\tvec3 worldPix = worldFacing + uv.x * sideNorm * (iResolution.x/iResolution.y) + uv.y * upNorm;//scrCoord\r\n\tvec3 relVec = normalize(worldPix - camPos);//scp\r\n\r\n\t// --------------------------------------------------------------------------------\r\n\t// I put a bounding sphere around the whole object. If the ray is outside\r\n\t// of the bounding sphere, I don't bother ray marching. It's just an optimization.\r\n\tvec3 iA, iB;\r\n\tfloat hit = IntersectSphereAndRay(vec3(0,0,0), 7.6, camPos, camPos+relVec, iA, iB);\r\n\r\n\t// --------------------------------------------------------------------------------\r\n\tvec2 distAndMat = vec2(0.05, 0.0);\r\n\tfloat t = 0.0;\r\n\tfloat inc = 0.02;\r\n\tfloat maxDepth = 110.0;\r\n\tvec3 pos = vec3(0,0,0);\r\n    // start and end the camera ray at the sphere intersections.\r\n    camPos = iA;\r\n    maxDepth = distance(iA, iB);\r\n\t// ray marching time\r\n\tif (hit > 0.5)\t// check if inside bounding sphere before wasting time ray marching.\r\n\t{\r\n        for (int i = 0; i < MAX_MARCH_REPS; i++)\t// This is the count of the max times the ray actually marches.\r\n        {\r\n            if ((t > maxDepth) || (abs(distAndMat.x) < 0.0075)) break;\r\n            pos = camPos + relVec * t;\r\n            // *******************************************************\r\n            // This is _the_ function that defines the \"distance field\".\r\n            // It's really what makes the scene geometry.\r\n            // *******************************************************\r\n            distAndMat = DistanceToObject(pos);\r\n            // adjust by constant because deformations mess up distance function.\r\n            t += distAndMat.x * MARCH_DISTANCE_MULTIPLIER;\r\n        }\r\n    }\r\n    else\r\n    {\r\n\t\tt = maxDepth + 1.0;\r\n        distAndMat.x = 1.0;\r\n    }\r\n\t// --------------------------------------------------------------------------------\r\n\t// Now that we have done our ray marching, let's put some color on this geometry.\r\n\r\n\tvec3 sunDir = normalize(vec3(0.93, 1.0, -1.5));\r\n\tvec3 finalColor = vec3(0.0);\r\n\r\n\t// If a ray actually hit the object, let's light it.\r\n\tif (abs(distAndMat.x) < 0.75)\r\n    //if (t <= maxDepth)\r\n\t{\r\n        // calculate the normal from the distance field. The distance field is a volume, so if you\r\n        // sample the current point and neighboring points, you can use the difference to get\r\n        // the normal.\r\n        vec3 smallVec = vec3(0.005, 0, 0);\r\n        vec3 normalU = vec3(distAndMat.x - DistanceToObject(pos - smallVec.xyy).x,\r\n                           distAndMat.x - DistanceToObject(pos - smallVec.yxy).x,\r\n                           distAndMat.x - DistanceToObject(pos - smallVec.yyx).x);\r\n\r\n        vec3 normal = normalize(normalU);\r\n\r\n        // calculate 2 ambient occlusion values. One for global stuff and one\r\n        // for local stuff - so the green sphere light source can also have ambient.\r\n        float ambientS = 1.0;\r\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.1).x*10.0);\r\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.2).x*5.0);\r\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.4).x*2.5);\r\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.8).x*1.25);\r\n        float ambient = ambientS * saturate(DistanceToObject(pos + normal * 1.6).x*1.25*0.5);\r\n        ambient *= saturate(DistanceToObject(pos + normal * 3.2).x*1.25*0.25);\r\n        ambient *= saturate(DistanceToObject(pos + normal * 6.4).x*1.25*0.125);\r\n        ambient = max(0.15, pow(ambient, 0.3));\t// tone down ambient with a pow and min clamp it.\r\n        ambient = saturate(ambient);\r\n\r\n        // Trace a ray toward the sun for sun shadows\r\n        float sunShadow = 1.0;\r\n        float iter = 0.2;\r\n\t\tfor (int i = 0; i < 10; i++)\r\n        {\r\n            float tempDist = DistanceToObject(pos + sunDir * iter).x;\r\n\t        sunShadow *= saturate(tempDist*10.0);\r\n            if (tempDist <= 0.0) break;\r\n            iter *= 1.5;\t// constant is more reliable than distance-based\r\n            //iter += max(0.2, tempDist)*1.2;\r\n        }\r\n        sunShadow = saturate(sunShadow);\r\n\r\n        // calculate the reflection vector for highlights\r\n        vec3 ref = reflect(relVec, normal);\r\n\r\n        // ------ Calculate texture color of the rock ------\r\n        // base texture can be swirled noise.\r\n\t\tvec3 rp = RotateY(pos, pos.y*0.4 - cos(localTime)*0.4);\r\n        float n = noise(rp*4.0) + noise(rp*8.0) + noise(rp*16.0) + noise(rp*32.0);\r\n        n = saturate(n*0.25 * 0.95 + 0.05);\r\n        vec3 texColor = vec3(0.2,0.3,0.3)*n;\r\n\r\n        // fade to reddish texture on outside\r\n        texColor += vec3(0.99, 0.21, 0.213) * clamp(length(pos)-4.0, 0.0, 0.4);\r\n        // give it green-blue texture that matches the shape using normal length\r\n        texColor += vec3(1.0, 21.0, 26.0)*0.6 * saturate(length(normalU)-0.01);\r\n        // Give it a reddish-rust color in the middle\r\n        texColor -= vec3(0.0, 0.3, 0.5)*saturate(-distAndMat.y*(0.9+sin(localTime+0.5)*0.9));\r\n        // make sure it's not too saturated so it looks realistic\r\n        texColor = max(vec3(0.02),texColor);\r\n\r\n        // ------ Calculate lighting color ------\r\n        // Start with sun color, standard lighting equation, and shadow\r\n        vec3 lightColor = sunCol * saturate(dot(sunDir, normal)) * sunShadow*14.0;\r\n        // sky color, hemisphere light equation approximation, anbient occlusion\r\n        lightColor += vec3(0.1,0.35,0.95) * (normal.y * 0.5 + 0.5) * ambient * 0.25;\r\n        // ground color - another hemisphere light\r\n        lightColor += vec3(1.0) * ((-normal.y) * 0.5 + 0.5) * ambient * 0.2;\r\n\r\n        // finally, apply the light to the texture.\r\n        finalColor = texColor * lightColor;\r\n\r\n        // specular highlights - just a little\r\n        vec3 refColor = GetSunColorReflection(ref, sunDir)*0.68;\r\n        finalColor += refColor * sunCol * sunShadow * 9.0 * texColor.g;\r\n\r\n        // fog that fades to sun color so that fog is brightest towards sun\r\n        finalColor = mix(vec3(0.98, 0.981, 0.981) + min(vec3(0.25),GetSunColorSmall(relVec, sunDir))*2.0, finalColor, exp(-t*0.007));\r\n        //finalColor = vec3(1.0, 21.0, 26.0) * saturate(length(normalU)-0.01);\r\n\t}\r\n    else\r\n    {\r\n        // Our ray trace hit nothing, so draw sky.\r\n        // fade the sky color, multiply sunset dimming\r\n        finalColor = mix(vec3(1.0, 0.95, 0.85), vec3(0.2,0.5,0.95), pow(saturate(relVec.y), 0.7))*0.95;\r\n        // add the sun\r\n        finalColor += GetSunColorSmall(relVec, sunDir);// + vec3(0.1, 0.1, 0.1);\r\n    }\r\n\r\n    // vignette?\r\n    finalColor *= vec3(1.0) * saturate(1.0 - length(uv/2.5));\r\n    finalColor *= 1.95;\r\n\r\n\t// output the final color with sqrt for \"gamma correction\"\r\n\tfragColor = vec4(sqrt(clamp(finalColor, 0.0, 1.0)),1.0);\r\n}\r\n`;\r\n</script>\r\n",
      "target": "uniapp"
    }
  ],
  "fileCount": 3,
  "contentHash": "f355d6da66d6122931f2a3038e93805877245fcd"
}
