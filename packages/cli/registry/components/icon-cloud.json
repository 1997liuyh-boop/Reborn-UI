{
  "name": "icon-cloud",
  "dependencies": [],
  "files": [
    {
      "path": "IconCloud.vue",
      "content": "<template>\r\n  <canvas\r\n    ref=\"canvasRef\"\r\n    width=\"300\"\r\n    height=\"300\"\r\n    :class=\"cn('rounded-lg', $props.class)\"\r\n    role=\"img\"\r\n    aria-label=\"Interactive 3D Image Cloud\"\r\n    @mousedown=\"handleMouseDown\"\r\n    @mousemove=\"handleMouseMove\"\r\n    @mouseup=\"handleMouseUp\"\r\n    @mouseleave=\"handleMouseUp\"\r\n  />\r\n</template>\r\n\r\n<script lang=\"ts\" setup>\r\nimport type { SphereIcon, IconCloudProps } from \"./index\";\r\nimport { cn } from \"@/lib/utils\";\r\nimport { ref, onMounted, onBeforeUnmount, reactive, watchEffect } from \"vue\";\r\n\r\nconst props = defineProps<IconCloudProps>();\r\n\r\nconst { images } = props;\r\n\r\nconst canvasRef = ref<HTMLCanvasElement | null>(null);\r\nconst animationFrameRef = ref<number>(0);\r\n\r\nconst imageCanvasesRef = ref<HTMLCanvasElement[]>([]);\r\nconst imagesLoadedRef = ref<boolean[]>([]);\r\n\r\nconst imagePositions = ref<SphereIcon[]>([]);\r\n\r\nconst rotation = reactive({ x: 0, y: 0 });\r\nconst isDragging = ref(false);\r\nconst lastMousePos = reactive({ x: 0, y: 0 });\r\nconst mousePos = reactive({ x: 0, y: 0 });\r\n\r\nconst targetRotation = ref<{\r\n  x: number;\r\n  y: number;\r\n  startX: number;\r\n  startY: number;\r\n  distance: number;\r\n  startTime: number;\r\n  duration: number;\r\n} | null>(null);\r\n\r\nfunction easeOutCubic(t: number): number {\r\n  return 1 - (1 - t) ** 3;\r\n}\r\n\r\nwatchEffect(() => {\r\n  if (!images) return;\r\n  imagesLoadedRef.value = new Array(images.length).fill(false);\r\n\r\n  const newImageCanvases = images.map((url, idx) => {\r\n    const offscreen = document.createElement(\"canvas\");\r\n    offscreen.width = 40;\r\n    offscreen.height = 40;\r\n    const offCtx = offscreen.getContext(\"2d\");\r\n    if (!offCtx) return offscreen;\r\n\r\n    const img = new Image();\r\n    img.crossOrigin = \"anonymous\";\r\n    img.src = url;\r\n    img.onload = () => {\r\n      offCtx.clearRect(0, 0, offscreen.width, offscreen.height);\r\n\r\n      // circular clipping\r\n      offCtx.beginPath();\r\n      offCtx.arc(20, 20, 20, 0, Math.PI * 2);\r\n      offCtx.closePath();\r\n      offCtx.clip();\r\n\r\n      // draw the image\r\n      offCtx.drawImage(img, 0, 0, 40, 40);\r\n      imagesLoadedRef.value[idx] = true;\r\n    };\r\n\r\n    return offscreen;\r\n  });\r\n\r\n  imageCanvasesRef.value = newImageCanvases;\r\n});\r\n\r\nwatchEffect(() => {\r\n  const count = images?.length || 0;\r\n  if (count === 0) {\r\n    imagePositions.value = [];\r\n    return;\r\n  }\r\n\r\n  const newPositions: SphereIcon[] = [];\r\n  const offset = 2 / count;\r\n  const increment = Math.PI * (3 - Math.sqrt(5)); // ~2.3999632\r\n\r\n  for (let i = 0; i < count; i++) {\r\n    const y = i * offset - 1 + offset / 2;\r\n    const r = Math.sqrt(1 - y * y);\r\n    const phi = i * increment;\r\n    const x = Math.cos(phi) * r;\r\n    const z = Math.sin(phi) * r;\r\n\r\n    newPositions.push({\r\n      x: x * 100,\r\n      y: y * 100,\r\n      z: z * 100,\r\n      scale: 1,\r\n      opacity: 1,\r\n      id: i,\r\n    });\r\n  }\r\n  imagePositions.value = newPositions;\r\n});\r\n\r\nfunction handleMouseDown(e: MouseEvent) {\r\n  const canvas = canvasRef.value;\r\n  if (!canvas) return;\r\n  const rect = canvas.getBoundingClientRect();\r\n  const x = e.clientX - rect.left;\r\n  const y = e.clientY - rect.top;\r\n  const ctx = canvas.getContext(\"2d\");\r\n  if (!ctx) return;\r\n\r\n  imagePositions.value.forEach((icon) => {\r\n    const cosX = Math.cos(rotation.x);\r\n    const sinX = Math.sin(rotation.x);\r\n    const cosY = Math.cos(rotation.y);\r\n    const sinY = Math.sin(rotation.y);\r\n\r\n    const rotatedX = icon.x * cosY - icon.z * sinY;\r\n    const rotatedZ = icon.x * sinY + icon.z * cosY;\r\n    const rotatedY = icon.y * cosX + rotatedZ * sinX;\r\n\r\n    const screenX = canvas.width / 2 + rotatedX;\r\n    const screenY = canvas.height / 2 + rotatedY;\r\n\r\n    const scale = (rotatedZ + 200) / 300;\r\n    const radius = 20 * scale;\r\n    const dx = x - screenX;\r\n    const dy = y - screenY;\r\n\r\n    if (dx * dx + dy * dy < radius * radius) {\r\n      const targetX = -Math.atan2(icon.y, Math.sqrt(icon.x * icon.x + icon.z * icon.z));\r\n      const targetY = Math.atan2(icon.x, icon.z);\r\n      const currentX = rotation.x;\r\n      const currentY = rotation.y;\r\n      const distance = Math.sqrt((targetX - currentX) ** 2 + (targetY - currentY) ** 2);\r\n\r\n      const duration = Math.min(2000, Math.max(800, distance * 1000));\r\n      targetRotation.value = {\r\n        x: targetX,\r\n        y: targetY,\r\n        startX: currentX,\r\n        startY: currentY,\r\n        distance,\r\n        startTime: performance.now(),\r\n        duration,\r\n      };\r\n      return;\r\n    }\r\n  });\r\n\r\n  isDragging.value = true;\r\n  lastMousePos.x = e.clientX;\r\n  lastMousePos.y = e.clientY;\r\n}\r\n\r\nfunction handleMouseMove(e: MouseEvent) {\r\n  const canvas = canvasRef.value;\r\n  if (!canvas) return;\r\n  const rect = canvas.getBoundingClientRect();\r\n  mousePos.x = e.clientX - rect.left;\r\n  mousePos.y = e.clientY - rect.top;\r\n\r\n  if (isDragging.value) {\r\n    const deltaX = e.clientX - lastMousePos.x;\r\n    const deltaY = e.clientY - lastMousePos.y;\r\n\r\n    rotation.x += deltaY * 0.002;\r\n    rotation.y += deltaX * 0.002;\r\n\r\n    lastMousePos.x = e.clientX;\r\n    lastMousePos.y = e.clientY;\r\n  }\r\n}\r\n\r\nfunction handleMouseUp() {\r\n  isDragging.value = false;\r\n}\r\n\r\nonMounted(() => {\r\n  const canvas = canvasRef.value;\r\n  if (!canvas) return;\r\n  const ctx = canvas.getContext(\"2d\");\r\n  if (!ctx) return;\r\n\r\n  function animate() {\r\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\r\n\r\n    const centerX = canvas.width / 2;\r\n    const centerY = canvas.height / 2;\r\n    const dx = mousePos.x - centerX;\r\n    const dy = mousePos.y - centerY;\r\n    const maxDistance = Math.sqrt(centerX * centerX + centerY * centerY);\r\n    const distance = Math.sqrt(dx * dx + dy * dy);\r\n\r\n    const speed = 0.003 + (distance / maxDistance) * 0.01;\r\n\r\n    if (targetRotation.value) {\r\n      const { startX, startY, x: tx, y: ty, startTime, duration } = targetRotation.value;\r\n      const elapsed = performance.now() - startTime;\r\n      const progress = Math.min(1, elapsed / duration);\r\n      const eased = easeOutCubic(progress);\r\n\r\n      rotation.x = startX + (tx - startX) * eased;\r\n      rotation.y = startY + (ty - startY) * eased;\r\n\r\n      if (progress >= 1) {\r\n        targetRotation.value = null;\r\n      }\r\n    } else if (!isDragging.value) {\r\n      rotation.x += (dy / canvas.height) * speed;\r\n      rotation.y += (dx / canvas.width) * speed;\r\n    }\r\n\r\n    imagePositions.value.forEach((icon, index) => {\r\n      const cosX = Math.cos(rotation.x);\r\n      const sinX = Math.sin(rotation.x);\r\n      const cosY = Math.cos(rotation.y);\r\n      const sinY = Math.sin(rotation.y);\r\n\r\n      const rotatedX = icon.x * cosY - icon.z * sinY;\r\n      const rotatedZ = icon.x * sinY + icon.z * cosY;\r\n      const rotatedY = icon.y * cosX + rotatedZ * sinX;\r\n\r\n      const scale = (rotatedZ + 200) / 300;\r\n      const opacity = Math.max(0.2, Math.min(1, (rotatedZ + 150) / 200));\r\n\r\n      ctx.save();\r\n      ctx.translate(centerX + rotatedX, centerY + rotatedY);\r\n      ctx.scale(scale, scale);\r\n      ctx.globalAlpha = opacity;\r\n\r\n      if (imageCanvasesRef.value[index] && imagesLoadedRef.value[index]) {\r\n        ctx.drawImage(imageCanvasesRef.value[index], -20, -20, 40, 40);\r\n      }\r\n      ctx.restore();\r\n    });\r\n\r\n    animationFrameRef.value = requestAnimationFrame(animate);\r\n  }\r\n\r\n  animationFrameRef.value = requestAnimationFrame(animate);\r\n});\r\n\r\nonBeforeUnmount(() => {\r\n  if (animationFrameRef.value) {\r\n    cancelAnimationFrame(animationFrameRef.value);\r\n  }\r\n});\r\n</script>\r\n",
      "target": "web"
    },
    {
      "path": "IconCloud.vue",
      "content": "<template>\r\n  <canvas\r\n    ref=\"canvasRef\"\r\n    width=\"300\"\r\n    height=\"300\"\r\n    :class=\"cn('rounded-lg', $props.class)\"\r\n    role=\"img\"\r\n    aria-label=\"Interactive 3D Image Cloud\"\r\n    @mousedown=\"handleMouseDown\"\r\n    @mousemove=\"handleMouseMove\"\r\n    @mouseup=\"handleMouseUp\"\r\n    @mouseleave=\"handleMouseUp\"\r\n  />\r\n</template>\r\n\r\n<script lang=\"ts\" setup>\r\nimport type { SphereIcon, IconCloudProps } from \"./index\";\r\nimport { cn } from \"@/lib/utils\";\r\nimport { ref, onMounted, onBeforeUnmount, reactive, watchEffect } from \"vue\";\r\n\r\nconst props = defineProps<IconCloudProps>();\r\n\r\nconst { images } = props;\r\n\r\nconst canvasRef = ref<HTMLCanvasElement | null>(null);\r\nconst animationFrameRef = ref<number>(0);\r\n\r\nconst imageCanvasesRef = ref<HTMLCanvasElement[]>([]);\r\nconst imagesLoadedRef = ref<boolean[]>([]);\r\n\r\nconst imagePositions = ref<SphereIcon[]>([]);\r\n\r\nconst rotation = reactive({ x: 0, y: 0 });\r\nconst isDragging = ref(false);\r\nconst lastMousePos = reactive({ x: 0, y: 0 });\r\nconst mousePos = reactive({ x: 0, y: 0 });\r\n\r\nconst targetRotation = ref<{\r\n  x: number;\r\n  y: number;\r\n  startX: number;\r\n  startY: number;\r\n  distance: number;\r\n  startTime: number;\r\n  duration: number;\r\n} | null>(null);\r\n\r\nfunction easeOutCubic(t: number): number {\r\n  return 1 - (1 - t) ** 3;\r\n}\r\n\r\nwatchEffect(() => {\r\n  if (!images) return;\r\n  imagesLoadedRef.value = new Array(images.length).fill(false);\r\n\r\n  const newImageCanvases = images.map((url, idx) => {\r\n    const offscreen = document.createElement(\"canvas\");\r\n    offscreen.width = 40;\r\n    offscreen.height = 40;\r\n    const offCtx = offscreen.getContext(\"2d\");\r\n    if (!offCtx) return offscreen;\r\n\r\n    const img = new Image();\r\n    img.crossOrigin = \"anonymous\";\r\n    img.src = url;\r\n    img.onload = () => {\r\n      offCtx.clearRect(0, 0, offscreen.width, offscreen.height);\r\n\r\n      // circular clipping\r\n      offCtx.beginPath();\r\n      offCtx.arc(20, 20, 20, 0, Math.PI * 2);\r\n      offCtx.closePath();\r\n      offCtx.clip();\r\n\r\n      // draw the image\r\n      offCtx.drawImage(img, 0, 0, 40, 40);\r\n      imagesLoadedRef.value[idx] = true;\r\n    };\r\n\r\n    return offscreen;\r\n  });\r\n\r\n  imageCanvasesRef.value = newImageCanvases;\r\n});\r\n\r\nwatchEffect(() => {\r\n  const count = images?.length || 0;\r\n  if (count === 0) {\r\n    imagePositions.value = [];\r\n    return;\r\n  }\r\n\r\n  const newPositions: SphereIcon[] = [];\r\n  const offset = 2 / count;\r\n  const increment = Math.PI * (3 - Math.sqrt(5)); // ~2.3999632\r\n\r\n  for (let i = 0; i < count; i++) {\r\n    const y = i * offset - 1 + offset / 2;\r\n    const r = Math.sqrt(1 - y * y);\r\n    const phi = i * increment;\r\n    const x = Math.cos(phi) * r;\r\n    const z = Math.sin(phi) * r;\r\n\r\n    newPositions.push({\r\n      x: x * 100,\r\n      y: y * 100,\r\n      z: z * 100,\r\n      scale: 1,\r\n      opacity: 1,\r\n      id: i,\r\n    });\r\n  }\r\n  imagePositions.value = newPositions;\r\n});\r\n\r\nfunction handleMouseDown(e: MouseEvent) {\r\n  const canvas = canvasRef.value;\r\n  if (!canvas) return;\r\n  const rect = canvas.getBoundingClientRect();\r\n  const x = e.clientX - rect.left;\r\n  const y = e.clientY - rect.top;\r\n  const ctx = canvas.getContext(\"2d\");\r\n  if (!ctx) return;\r\n\r\n  imagePositions.value.forEach((icon) => {\r\n    const cosX = Math.cos(rotation.x);\r\n    const sinX = Math.sin(rotation.x);\r\n    const cosY = Math.cos(rotation.y);\r\n    const sinY = Math.sin(rotation.y);\r\n\r\n    const rotatedX = icon.x * cosY - icon.z * sinY;\r\n    const rotatedZ = icon.x * sinY + icon.z * cosY;\r\n    const rotatedY = icon.y * cosX + rotatedZ * sinX;\r\n\r\n    const screenX = canvas.width / 2 + rotatedX;\r\n    const screenY = canvas.height / 2 + rotatedY;\r\n\r\n    const scale = (rotatedZ + 200) / 300;\r\n    const radius = 20 * scale;\r\n    const dx = x - screenX;\r\n    const dy = y - screenY;\r\n\r\n    if (dx * dx + dy * dy < radius * radius) {\r\n      const targetX = -Math.atan2(icon.y, Math.sqrt(icon.x * icon.x + icon.z * icon.z));\r\n      const targetY = Math.atan2(icon.x, icon.z);\r\n      const currentX = rotation.x;\r\n      const currentY = rotation.y;\r\n      const distance = Math.sqrt((targetX - currentX) ** 2 + (targetY - currentY) ** 2);\r\n\r\n      const duration = Math.min(2000, Math.max(800, distance * 1000));\r\n      targetRotation.value = {\r\n        x: targetX,\r\n        y: targetY,\r\n        startX: currentX,\r\n        startY: currentY,\r\n        distance,\r\n        startTime: performance.now(),\r\n        duration,\r\n      };\r\n      return;\r\n    }\r\n  });\r\n\r\n  isDragging.value = true;\r\n  lastMousePos.x = e.clientX;\r\n  lastMousePos.y = e.clientY;\r\n}\r\n\r\nfunction handleMouseMove(e: MouseEvent) {\r\n  const canvas = canvasRef.value;\r\n  if (!canvas) return;\r\n  const rect = canvas.getBoundingClientRect();\r\n  mousePos.x = e.clientX - rect.left;\r\n  mousePos.y = e.clientY - rect.top;\r\n\r\n  if (isDragging.value) {\r\n    const deltaX = e.clientX - lastMousePos.x;\r\n    const deltaY = e.clientY - lastMousePos.y;\r\n\r\n    rotation.x += deltaY * 0.002;\r\n    rotation.y += deltaX * 0.002;\r\n\r\n    lastMousePos.x = e.clientX;\r\n    lastMousePos.y = e.clientY;\r\n  }\r\n}\r\n\r\nfunction handleMouseUp() {\r\n  isDragging.value = false;\r\n}\r\n\r\nonMounted(() => {\r\n  const canvas = canvasRef.value;\r\n  if (!canvas) return;\r\n  const ctx = canvas.getContext(\"2d\");\r\n  if (!ctx) return;\r\n\r\n  function animate() {\r\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\r\n\r\n    const centerX = canvas.width / 2;\r\n    const centerY = canvas.height / 2;\r\n    const dx = mousePos.x - centerX;\r\n    const dy = mousePos.y - centerY;\r\n    const maxDistance = Math.sqrt(centerX * centerX + centerY * centerY);\r\n    const distance = Math.sqrt(dx * dx + dy * dy);\r\n\r\n    const speed = 0.003 + (distance / maxDistance) * 0.01;\r\n\r\n    if (targetRotation.value) {\r\n      const { startX, startY, x: tx, y: ty, startTime, duration } = targetRotation.value;\r\n      const elapsed = performance.now() - startTime;\r\n      const progress = Math.min(1, elapsed / duration);\r\n      const eased = easeOutCubic(progress);\r\n\r\n      rotation.x = startX + (tx - startX) * eased;\r\n      rotation.y = startY + (ty - startY) * eased;\r\n\r\n      if (progress >= 1) {\r\n        targetRotation.value = null;\r\n      }\r\n    } else if (!isDragging.value) {\r\n      rotation.x += (dy / canvas.height) * speed;\r\n      rotation.y += (dx / canvas.width) * speed;\r\n    }\r\n\r\n    imagePositions.value.forEach((icon, index) => {\r\n      const cosX = Math.cos(rotation.x);\r\n      const sinX = Math.sin(rotation.x);\r\n      const cosY = Math.cos(rotation.y);\r\n      const sinY = Math.sin(rotation.y);\r\n\r\n      const rotatedX = icon.x * cosY - icon.z * sinY;\r\n      const rotatedZ = icon.x * sinY + icon.z * cosY;\r\n      const rotatedY = icon.y * cosX + rotatedZ * sinX;\r\n\r\n      const scale = (rotatedZ + 200) / 300;\r\n      const opacity = Math.max(0.2, Math.min(1, (rotatedZ + 150) / 200));\r\n\r\n      ctx.save();\r\n      ctx.translate(centerX + rotatedX, centerY + rotatedY);\r\n      ctx.scale(scale, scale);\r\n      ctx.globalAlpha = opacity;\r\n\r\n      if (imageCanvasesRef.value[index] && imagesLoadedRef.value[index]) {\r\n        ctx.drawImage(imageCanvasesRef.value[index], -20, -20, 40, 40);\r\n      }\r\n      ctx.restore();\r\n    });\r\n\r\n    animationFrameRef.value = requestAnimationFrame(animate);\r\n  }\r\n\r\n  animationFrameRef.value = requestAnimationFrame(animate);\r\n});\r\n\r\nonBeforeUnmount(() => {\r\n  if (animationFrameRef.value) {\r\n    cancelAnimationFrame(animationFrameRef.value);\r\n  }\r\n});\r\n</script>\r\n",
      "target": "uniapp"
    },
    {
      "path": "index.ts",
      "content": "import type { HTMLAttributes } from \"vue\";\r\n\r\nexport interface SphereIcon {\r\n  x: number;\r\n  y: number;\r\n  z: number;\r\n  scale: number;\r\n  opacity: number;\r\n  id: number;\r\n}\r\n\r\nexport interface IconCloudProps {\r\n  class?: HTMLAttributes[\"class\"];\r\n  images?: string[];\r\n}\r\n\r\nexport { default as IconCloud } from \"./IconCloud.vue\";\r\n"
    }
  ],
  "fileCount": 3,
  "contentHash": "f459656731f4a8d870aa8292bc79ff0d50f25712"
}
