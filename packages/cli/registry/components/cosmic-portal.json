{
  "name": "cosmic-portal",
  "dependencies": [
    "three"
  ],
  "files": [
    {
      "path": "CosmicPortal.vue",
      "content": "<template>\r\n  <div :class=\"['relative overflow-hidden h-full w-full', props.containerClass]\">\r\n    <canvas\r\n      ref=\"canvasRef\"\r\n      :class=\"['absolute inset-0 h-full w-full block', props.class]\"\r\n    />\r\n  </div>\r\n</template>\r\n\r\n<script setup lang=\"ts\">\r\nimport * as THREE from \"three\";\r\nimport { OrbitControls } from \"three/addons/controls/OrbitControls.js\";\r\nimport { EffectComposer } from \"three/addons/postprocessing/EffectComposer.js\";\r\nimport { RenderPass } from \"three/addons/postprocessing/RenderPass.js\";\r\nimport { UnrealBloomPass } from \"three/addons/postprocessing/UnrealBloomPass.js\";\r\nimport { ShaderPass } from \"three/addons/postprocessing/ShaderPass.js\";\r\nimport { FXAAShader } from \"three/addons/shaders/FXAAShader.js\";\r\n\r\ninterface PortalParams {\r\n  portalComplexity: number;\r\n  crystalCount: number;\r\n  primaryColor: string;\r\n  secondaryColor: string;\r\n  accentColor: string;\r\n  vortexColor: string;\r\n  rotationSpeed: number;\r\n  bloomStrength: number;\r\n  bloomRadius: number;\r\n  bloomThreshold: number;\r\n  dimensionShift: number;\r\n}\r\n\r\nconst props = withDefaults(\r\n  defineProps<Partial<PortalParams> & { class?: string; containerClass?: string }>(),\r\n  {\r\n    portalComplexity: 4,\r\n    crystalCount: 12,\r\n    primaryColor: \"#9b59b6\",\r\n    secondaryColor: \"#3498db\",\r\n    accentColor: \"#e74c3c\",\r\n    vortexColor: \"#2ecc71\",\r\n    rotationSpeed: 0.3,\r\n    bloomStrength: 1.2,\r\n    bloomRadius: 0.7,\r\n    bloomThreshold: 0.2,\r\n    dimensionShift: 4,\r\n    class: \"\",\r\n    containerClass: \"\",\r\n  },\r\n);\r\n\r\nconst params = ref<PortalParams>({\r\n  portalComplexity: props.portalComplexity,\r\n  crystalCount: props.crystalCount,\r\n  primaryColor: props.primaryColor,\r\n  secondaryColor: props.secondaryColor,\r\n  accentColor: props.accentColor,\r\n  vortexColor: props.vortexColor,\r\n  rotationSpeed: props.rotationSpeed,\r\n  bloomStrength: props.bloomStrength,\r\n  bloomRadius: props.bloomRadius,\r\n  bloomThreshold: props.bloomThreshold,\r\n  dimensionShift: props.dimensionShift,\r\n});\r\n\r\nconst canvasRef = ref<HTMLCanvasElement>();\r\n\r\n// Three.js core objects\r\nlet scene: THREE.Scene;\r\nlet camera: THREE.PerspectiveCamera;\r\nlet renderer: THREE.WebGLRenderer;\r\nlet composer: EffectComposer;\r\nlet controls: OrbitControls;\r\nlet bloomPass: UnrealBloomPass;\r\nlet fxaaPass: ShaderPass;\r\nlet clock: THREE.Clock;\r\n\r\n// Portal objects\r\nlet meshes: THREE.Object3D[] = [];\r\nlet materials: THREE.Material[] = [];\r\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\nlet portalMaterials: any[] = [];\r\nlet portalLights: THREE.Light[] = [];\r\nlet animationId: number;\r\nlet time = 0;\r\n\r\nlet resizeObserver: ResizeObserver;\r\n\r\nfunction initThreeJS() {\r\n  if (!canvasRef.value) return;\r\n\r\n  // Scene setup\r\n  scene = new THREE.Scene();\r\n  scene.background = new THREE.Color(0x0a0015);\r\n  scene.fog = new THREE.FogExp2(0x1a0033, 0.001);\r\n\r\n  // Camera setup - get container dimensions first\r\n  const container = canvasRef.value.parentElement;\r\n  const width = container ? container.clientWidth : window.innerWidth;\r\n  const height = container ? container.clientHeight : window.innerHeight;\r\n\r\n  camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);\r\n  camera.position.set(0, 0, 15);\r\n\r\n  // Lighting\r\n  scene.add(new THREE.AmbientLight(0x330066, 0.2));\r\n  const mainLight = new THREE.DirectionalLight(0xffffff, 0.6);\r\n  mainLight.position.set(10, 10, 5);\r\n  scene.add(mainLight);\r\n\r\n  // Portal lights\r\n  const lightColors = [\r\n    params.value.primaryColor,\r\n    params.value.secondaryColor,\r\n    params.value.accentColor,\r\n    params.value.vortexColor,\r\n  ];\r\n  for (let i = 0; i < 6; i++) {\r\n    const light = new THREE.PointLight(new THREE.Color(lightColors[i % 4]), 0.8, 20);\r\n    scene.add(light);\r\n    portalLights.push(light);\r\n  }\r\n\r\n  // Renderer setup - use the container dimensions\r\n  renderer = new THREE.WebGLRenderer({\r\n    canvas: canvasRef.value,\r\n    antialias: true,\r\n    powerPreference: \"high-performance\",\r\n  });\r\n  renderer.setSize(width, height);\r\n  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));\r\n  renderer.outputColorSpace = THREE.SRGBColorSpace;\r\n  renderer.toneMapping = THREE.ACESFilmicToneMapping;\r\n  renderer.toneMappingExposure = 1.2;\r\n\r\n  // Controls\r\n  controls = new OrbitControls(camera, canvasRef.value);\r\n  controls.enableDamping = true;\r\n  controls.dampingFactor = 0.08;\r\n  controls.autoRotate = true;\r\n  controls.autoRotateSpeed = 0.5;\r\n  controls.minDistance = 8;\r\n  controls.maxDistance = 40;\r\n\r\n  // Post-processing\r\n  composer = new EffectComposer(renderer);\r\n  composer.addPass(new RenderPass(scene, camera));\r\n\r\n  bloomPass = new UnrealBloomPass(\r\n    new THREE.Vector2(width, height),\r\n    params.value.bloomStrength,\r\n    params.value.bloomRadius,\r\n    params.value.bloomThreshold,\r\n  );\r\n  composer.addPass(bloomPass);\r\n\r\n  fxaaPass = new ShaderPass(FXAAShader);\r\n  const pixelRatio = renderer.getPixelRatio();\r\n  fxaaPass.material.uniforms[\"resolution\"].value.set(\r\n    1 / (width * pixelRatio),\r\n    1 / (height * pixelRatio),\r\n  );\r\n  composer.addPass(fxaaPass);\r\n\r\n  clock = new THREE.Clock();\r\n}\r\n\r\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\nfunction addPortalShader(material: any) {\r\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n  material.onBeforeCompile = (shader: any) => {\r\n    shader.uniforms.time = { value: 0 };\r\n    shader.uniforms.pulseTime = { value: -1000 };\r\n    shader.uniforms.portalSpeed = { value: 8.0 };\r\n    shader.uniforms.portalColor = { value: new THREE.Color(params.value.accentColor) };\r\n    shader.uniforms.dimensionShift = { value: 0 };\r\n\r\n    shader.vertexShader = `varying vec3 vWorldPosition;\\n` + shader.vertexShader;\r\n\r\n    shader.fragmentShader =\r\n      `\r\n        uniform float time;\r\n        uniform float pulseTime;\r\n        uniform float portalSpeed;\r\n        uniform vec3 portalColor;\r\n        uniform float dimensionShift;\r\n        varying vec3 vWorldPosition;\\n` + shader.fragmentShader;\r\n\r\n    shader.vertexShader = shader.vertexShader.replace(\r\n      \"#include <begin_vertex>\",\r\n      `#include <begin_vertex>\r\n       vWorldPosition = (modelMatrix * vec4(transformed, 1.0)).xyz;`,\r\n    );\r\n\r\n    shader.fragmentShader = shader.fragmentShader.replace(\r\n      \"#include <emissivemap_fragment>\",\r\n      `#include <emissivemap_fragment>\r\n       float timeSincePortal = time - pulseTime;\r\n       if(timeSincePortal > 0.0 && timeSincePortal < 3.0) {\r\n         float portalRadius = timeSincePortal * portalSpeed;\r\n         float currentRadius = length(vWorldPosition);\r\n         float portalWidth = 1.5;\r\n         float portalEffect = smoothstep(portalRadius - portalWidth, portalRadius, currentRadius) -\r\n                             smoothstep(portalRadius, portalRadius + portalWidth, currentRadius);\r\n         vec3 dimensionalColor = mix(portalColor, vec3(1.0, 0.5, 1.0), sin(dimensionShift * 3.14159) * 0.5 + 0.5);\r\n         totalEmissiveRadiance += dimensionalColor * portalEffect * 4.0;\r\n       }`,\r\n    );\r\n    portalMaterials.push(shader);\r\n  };\r\n}\r\n\r\nfunction createCosmicBackground() {\r\n  const count = 4000;\r\n  const geo = new THREE.BufferGeometry();\r\n  const positions = new Float32Array(count * 3);\r\n  const colors = new Float32Array(count * 3);\r\n\r\n  for (let i = 0; i < count; i++) {\r\n    const i3 = i * 3;\r\n    const radius = 80 + Math.random() * 50;\r\n    const theta = Math.random() * Math.PI * 2;\r\n    const phi = Math.acos(2 * Math.random() - 1);\r\n\r\n    positions[i3] = radius * Math.sin(phi) * Math.cos(theta);\r\n    positions[i3 + 1] = radius * Math.sin(phi) * Math.sin(theta);\r\n    positions[i3 + 2] = radius * Math.cos(phi);\r\n\r\n    const temp = Math.random();\r\n    const color = new THREE.Color();\r\n    if (temp < 0.15) color.setHSL(0.8, 0.8, 0.9);\r\n    else if (temp < 0.4) color.setHSL(0.6, 0.6, 0.8);\r\n    else if (temp < 0.7) color.setHSL(0.1, 0.3, 0.9);\r\n    else color.setHSL(0.3, 0.7, 0.6);\r\n\r\n    color.toArray(colors, i3);\r\n  }\r\n\r\n  geo.setAttribute(\"position\", new THREE.BufferAttribute(positions, 3));\r\n  geo.setAttribute(\"color\", new THREE.BufferAttribute(colors, 3));\r\n\r\n  const mat = new THREE.PointsMaterial({\r\n    size: 0.3,\r\n    vertexColors: true,\r\n    sizeAttenuation: true,\r\n    blending: THREE.AdditiveBlending,\r\n    depthWrite: false,\r\n    transparent: true,\r\n  });\r\n\r\n  const stars = new THREE.Points(geo, mat);\r\n  scene.add(stars);\r\n  meshes.push(stars);\r\n  materials.push(mat);\r\n}\r\n\r\nfunction createPortalCore() {\r\n  const geo = new THREE.SphereGeometry(0.8, 32, 32);\r\n  const mat = new THREE.ShaderMaterial({\r\n    uniforms: {\r\n      time: { value: 0 },\r\n      pulseTime: { value: -1000 },\r\n      dimensionShift: { value: 0 },\r\n      color1: { value: new THREE.Color(params.value.primaryColor) },\r\n      color2: { value: new THREE.Color(params.value.secondaryColor) },\r\n      color3: { value: new THREE.Color(params.value.accentColor) },\r\n    },\r\n    vertexShader: `\r\n      uniform float time;\r\n      uniform float dimensionShift;\r\n      varying vec3 vPos;\r\n      varying vec3 vNorm;\r\n      void main() {\r\n        vPos = position;\r\n        vNorm = normal;\r\n        float warp = sin(position.x * 10.0 + time * 3.0) * 0.1;\r\n        float shift = sin(dimensionShift * 6.28318) * 0.3;\r\n        vec3 p = position * (1.0 + warp + shift);\r\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(p, 1.0);\r\n      }\r\n    `,\r\n    fragmentShader: `\r\n      uniform float time;\r\n      uniform float pulseTime;\r\n      uniform float dimensionShift;\r\n      uniform vec3 color1;\r\n      uniform vec3 color2;\r\n      uniform vec3 color3;\r\n      varying vec3 vPos;\r\n      varying vec3 vNorm;\r\n      void main() {\r\n        float noise = sin(vPos.x * 20.0 + time * 4.0) * cos(vPos.z * 15.0 + time * 3.0);\r\n        vec3 baseColor = mix(color1, color2, 0.5 + 0.5 * sin(time * 2.0 + dimensionShift));\r\n        vec3 finalColor = mix(baseColor, color3, noise * 0.3);\r\n\r\n        float fresnel = pow(1.0 - abs(dot(vNorm, normalize(cameraPosition - vPos))), 3.0);\r\n        finalColor = mix(finalColor, vec3(1.0), fresnel * 0.5);\r\n\r\n        float timeSincePortal = time - pulseTime;\r\n        if(timeSincePortal > 0.0 && timeSincePortal < 1.0) {\r\n          float burst = 1.0 - timeSincePortal;\r\n          finalColor += vec3(1.0) * burst * 3.0;\r\n        }\r\n\r\n        gl_FragColor = vec4(finalColor, 0.9);\r\n      }\r\n    `,\r\n    transparent: true,\r\n  });\r\n\r\n  portalMaterials.push(mat);\r\n  const mesh = new THREE.Mesh(geo, mat);\r\n  scene.add(mesh);\r\n  meshes.push(mesh);\r\n}\r\n\r\nfunction createVortexRings() {\r\n  const colors = [\r\n    params.value.primaryColor,\r\n    params.value.secondaryColor,\r\n    params.value.accentColor,\r\n    params.value.vortexColor,\r\n  ];\r\n\r\n  for (let ring = 0; ring < 5; ring++) {\r\n    const radius = 2 + ring * 0.8;\r\n    const geo = new THREE.TorusGeometry(radius, 0.05, 16, 64);\r\n    const mat = new THREE.MeshPhysicalMaterial({\r\n      color: new THREE.Color(colors[ring % colors.length]),\r\n      transparent: true,\r\n      opacity: 0.7,\r\n      metalness: 0.8,\r\n      roughness: 0.2,\r\n      clearcoat: 0.8,\r\n      clearcoatRoughness: 0.1,\r\n      emissive: new THREE.Color(colors[ring % colors.length]).multiplyScalar(0.2),\r\n    });\r\n\r\n    addPortalShader(mat);\r\n    const mesh = new THREE.Mesh(geo, mat);\r\n    mesh.rotation.x = Math.PI * 0.1 * ring;\r\n    mesh.rotation.z = Math.PI * 0.15 * ring;\r\n    scene.add(mesh);\r\n    meshes.push(mesh);\r\n  }\r\n}\r\n\r\nfunction createFloatingCrystals() {\r\n  const colors = [\r\n    params.value.accentColor,\r\n    params.value.vortexColor,\r\n    params.value.primaryColor,\r\n    params.value.secondaryColor,\r\n  ];\r\n\r\n  for (let i = 0; i < params.value.crystalCount; i++) {\r\n    const geo = new THREE.OctahedronGeometry(0.3 + Math.random() * 0.4, 1);\r\n    const mat = new THREE.MeshPhysicalMaterial({\r\n      color: new THREE.Color(colors[i % colors.length]),\r\n      transparent: true,\r\n      opacity: 0.8,\r\n      metalness: 0.9,\r\n      roughness: 0.1,\r\n      clearcoat: 1.0,\r\n      clearcoatRoughness: 0.0,\r\n      emissive: new THREE.Color(colors[i % colors.length]).multiplyScalar(0.3),\r\n    });\r\n\r\n    addPortalShader(mat);\r\n    const mesh = new THREE.Mesh(geo, mat);\r\n    const angle = (i / params.value.crystalCount) * Math.PI * 2;\r\n    const radius = 6 + Math.random() * 4;\r\n    mesh.position.set(\r\n      Math.cos(angle) * radius,\r\n      (Math.random() - 0.5) * 8,\r\n      Math.sin(angle) * radius,\r\n    );\r\n    mesh.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);\r\n    scene.add(mesh);\r\n    meshes.push(mesh);\r\n  }\r\n}\r\n\r\nfunction createDimensionalStreams() {\r\n  const colors = [params.value.vortexColor, params.value.primaryColor, params.value.secondaryColor];\r\n\r\n  for (let i = 0; i < 8; i++) {\r\n    const points = [];\r\n    const segments = 120;\r\n\r\n    for (let j = 0; j <= segments; j++) {\r\n      const t = j / segments;\r\n      const angle = t * Math.PI * 12 + i * Math.PI * 0.25;\r\n      const radius = 3 + Math.sin(t * Math.PI * 6) * 1.5;\r\n      const height = (t - 0.5) * 15;\r\n\r\n      points.push(new THREE.Vector3(Math.cos(angle) * radius, height, Math.sin(angle) * radius));\r\n    }\r\n\r\n    const curve = new THREE.CatmullRomCurve3(points);\r\n    const geo = new THREE.TubeGeometry(curve, segments, 0.02, 8, false);\r\n    const mat = new THREE.MeshPhysicalMaterial({\r\n      color: new THREE.Color(colors[i % colors.length]),\r\n      transparent: true,\r\n      opacity: 0.6,\r\n      metalness: 1.0,\r\n      roughness: 0.0,\r\n      emissive: new THREE.Color(colors[i % colors.length]).multiplyScalar(0.4),\r\n    });\r\n\r\n    addPortalShader(mat);\r\n    const stream = new THREE.Mesh(geo, mat);\r\n    scene.add(stream);\r\n    meshes.push(stream);\r\n  }\r\n}\r\n\r\nfunction createPortalFrame() {\r\n  const frameGeo = new THREE.TorusGeometry(7, 0.2, 16, 64);\r\n  const frameMat = new THREE.MeshPhysicalMaterial({\r\n    color: new THREE.Color(params.value.primaryColor),\r\n    transparent: true,\r\n    opacity: 0.4,\r\n    metalness: 1.0,\r\n    roughness: 0.1,\r\n    clearcoat: 1.0,\r\n    clearcoatRoughness: 0.0,\r\n    emissive: new THREE.Color(params.value.primaryColor).multiplyScalar(0.5),\r\n  });\r\n\r\n  addPortalShader(frameMat);\r\n  const frame = new THREE.Mesh(frameGeo, frameMat);\r\n  scene.add(frame);\r\n  meshes.push(frame);\r\n}\r\n\r\nfunction createEnergyParticles() {\r\n  const count = 1500;\r\n  const geo = new THREE.BufferGeometry();\r\n  const positions = new Float32Array(count * 3);\r\n\r\n  for (let i = 0; i < count; i++) {\r\n    const r = 2 + Math.random() * 8;\r\n    const theta = Math.random() * Math.PI * 2;\r\n    const phi = Math.acos(2 * Math.random() - 1);\r\n\r\n    positions[i * 3] = r * Math.sin(phi) * Math.cos(theta);\r\n    positions[i * 3 + 1] = r * Math.sin(phi) * Math.sin(theta);\r\n    positions[i * 3 + 2] = r * Math.cos(phi);\r\n  }\r\n\r\n  geo.setAttribute(\"position\", new THREE.BufferAttribute(positions, 3));\r\n\r\n  const mat = new THREE.PointsMaterial({\r\n    size: 0.08,\r\n    color: params.value.vortexColor,\r\n    blending: THREE.AdditiveBlending,\r\n    transparent: true,\r\n    opacity: 0.8,\r\n  });\r\n\r\n  const particles = new THREE.Points(geo, mat);\r\n  scene.add(particles);\r\n  meshes.push(particles);\r\n  materials.push(mat);\r\n}\r\n\r\nfunction createSpaceDistortion() {\r\n  const geo = new THREE.SphereGeometry(12, 64, 64);\r\n  const mat = new THREE.ShaderMaterial({\r\n    uniforms: {\r\n      time: { value: 0 },\r\n      dimensionShift: { value: 0 },\r\n      color1: { value: new THREE.Color(params.value.primaryColor) },\r\n      color2: { value: new THREE.Color(params.value.vortexColor) },\r\n    },\r\n    vertexShader: `\r\n      uniform float time;\r\n      uniform float dimensionShift;\r\n      varying vec3 vNorm;\r\n      varying vec3 vPos;\r\n      void main() {\r\n        vNorm = normal;\r\n        vPos = position;\r\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n      }\r\n    `,\r\n    fragmentShader: `\r\n      uniform float time;\r\n      uniform float dimensionShift;\r\n      uniform vec3 color1;\r\n      uniform vec3 color2;\r\n      varying vec3 vNorm;\r\n      varying vec3 vPos;\r\n      void main() {\r\n        vec3 viewDir = normalize(cameraPosition - vPos);\r\n        float fresnel = pow(1.0 - abs(dot(vNorm, viewDir)), 4.0);\r\n\r\n        float distortion = sin(vPos.x * 0.5 + time * 2.0) * cos(vPos.y * 0.7 + time * 1.5);\r\n        vec3 color = mix(color1, color2, distortion * 0.5 + 0.5 + dimensionShift * 0.3);\r\n\r\n        gl_FragColor = vec4(color, fresnel * 0.3);\r\n      }\r\n    `,\r\n    transparent: true,\r\n    blending: THREE.AdditiveBlending,\r\n    depthWrite: false,\r\n  });\r\n\r\n  const distortion = new THREE.Mesh(geo, mat);\r\n  scene.add(distortion);\r\n  meshes.push(distortion);\r\n  materials.push(mat);\r\n}\r\n\r\nfunction createPortalScene() {\r\n  // Clean up existing meshes\r\n  meshes.forEach((mesh) => scene.remove(mesh));\r\n  materials.forEach((mat) => mat.dispose());\r\n  meshes = [];\r\n  materials = [];\r\n  portalMaterials = [];\r\n\r\n  // Create portal components\r\n  createCosmicBackground();\r\n  createPortalCore();\r\n  createVortexRings();\r\n  createFloatingCrystals();\r\n  createDimensionalStreams();\r\n  createPortalFrame();\r\n  createEnergyParticles();\r\n  createSpaceDistortion();\r\n}\r\n\r\nfunction handleResize() {\r\n  if (!camera || !renderer || !composer || !canvasRef.value) return;\r\n\r\n  const container = canvasRef.value.parentElement;\r\n  if (!container) return;\r\n\r\n  const width = container.clientWidth;\r\n  const height = container.clientHeight;\r\n\r\n  // Update camera\r\n  camera.aspect = width / height;\r\n  camera.updateProjectionMatrix();\r\n\r\n  // Update renderer and composer\r\n  renderer.setSize(width, height);\r\n  composer.setSize(width, height);\r\n\r\n  // Update FXAA pass\r\n  const pixelRatio = renderer.getPixelRatio();\r\n  fxaaPass.material.uniforms[\"resolution\"].value.set(\r\n    1 / (width * pixelRatio),\r\n    1 / (height * pixelRatio),\r\n  );\r\n}\r\n\r\nfunction animate() {\r\n  animationId = requestAnimationFrame(animate);\r\n\r\n  const delta = clock.getDelta();\r\n  time = clock.getElapsedTime();\r\n\r\n  // Update shader uniforms\r\n  portalMaterials.forEach((shader) => {\r\n    if (shader.uniforms) {\r\n      if (shader.uniforms.time) shader.uniforms.time.value = time;\r\n      if (shader.uniforms.dimensionShift)\r\n        shader.uniforms.dimensionShift.value = params.value.dimensionShift;\r\n    }\r\n  });\r\n\r\n  materials.forEach((mat) => {\r\n    if (mat.uniforms) {\r\n      if (mat.uniforms.time) mat.uniforms.time.value = time;\r\n      if (mat.uniforms.dimensionShift)\r\n        mat.uniforms.dimensionShift.value = params.value.dimensionShift;\r\n    }\r\n  });\r\n\r\n  // Animate portal lights\r\n  portalLights.forEach((light, i) => {\r\n    const angle = time * 0.3 + (i / 6) * Math.PI * 2;\r\n    const radius = 10 + Math.sin(time * 0.5 + i) * 3;\r\n    light.position.x = Math.cos(angle) * radius;\r\n    light.position.z = Math.sin(angle) * radius;\r\n    light.position.y = Math.sin(time * 0.4 + i * 0.7) * 5;\r\n  });\r\n\r\n  // Animate meshes\r\n  meshes.forEach((mesh, i) => {\r\n    if (!mesh.rotation) return;\r\n    const speed = params.value.rotationSpeed;\r\n    mesh.rotation.y += delta * speed * (i % 2 ? -1 : 1) * 0.3;\r\n    mesh.rotation.x += delta * speed * 0.1;\r\n\r\n    // Animate particle positions\r\n    if (mesh.material && mesh.material.type === \"PointsMaterial\") {\r\n      const positions = mesh.geometry.attributes.position.array;\r\n      for (let j = 0; j < positions.length; j += 3) {\r\n        positions[j] += Math.sin(time + j) * 0.001;\r\n        positions[j + 1] += Math.cos(time + j) * 0.001;\r\n        positions[j + 2] += Math.sin(time * 0.7 + j) * 0.001;\r\n      }\r\n      mesh.geometry.attributes.position.needsUpdate = true;\r\n    }\r\n  });\r\n\r\n  controls.update();\r\n  composer.render();\r\n}\r\n\r\nfunction cleanup() {\r\n  if (animationId) {\r\n    cancelAnimationFrame(animationId);\r\n  }\r\n\r\n  // Dispose of Three.js objects\r\n  meshes.forEach((mesh) => {\r\n    if (mesh.geometry) mesh.geometry.dispose();\r\n    if (mesh.material) {\r\n      if (Array.isArray(mesh.material)) {\r\n        mesh.material.forEach((mat) => mat.dispose());\r\n      } else {\r\n        mesh.material.dispose();\r\n      }\r\n    }\r\n  });\r\n\r\n  materials.forEach((mat) => mat.dispose());\r\n\r\n  if (renderer) {\r\n    renderer.dispose();\r\n  }\r\n\r\n  if (controls) {\r\n    controls.dispose();\r\n  }\r\n\r\n  window.removeEventListener(\"resize\", handleResize);\r\n}\r\n\r\n// Exposed methods\r\nfunction activatePortal() {\r\n  portalMaterials.forEach((mat) => {\r\n    if (mat.uniforms && mat.uniforms.pulseTime) {\r\n      mat.uniforms.pulseTime.value = time;\r\n    }\r\n  });\r\n}\r\n\r\nfunction shiftDimensions() {\r\n  const colors = [\r\n    \"#9b59b6\",\r\n    \"#3498db\",\r\n    \"#e74c3c\",\r\n    \"#2ecc71\",\r\n    \"#f39c12\",\r\n    \"#e67e22\",\r\n    \"#1abc9c\",\r\n    \"#34495e\",\r\n  ];\r\n  params.value.primaryColor = colors[Math.floor(Math.random() * colors.length)];\r\n  params.value.secondaryColor = colors[Math.floor(Math.random() * colors.length)];\r\n  params.value.accentColor = colors[Math.floor(Math.random() * colors.length)];\r\n  params.value.vortexColor = colors[Math.floor(Math.random() * colors.length)];\r\n  params.value.dimensionShift = Math.random();\r\n  createPortalScene();\r\n}\r\n\r\n// Expose methods to parent component\r\ndefineExpose({\r\n  activatePortal,\r\n  shiftDimensions,\r\n});\r\n\r\nonMounted(() => {\r\n  initThreeJS();\r\n  createPortalScene();\r\n  // Use ResizeObserver instead of window resize\r\n  if (canvasRef.value?.parentElement) {\r\n    resizeObserver = new ResizeObserver(() => {\r\n      handleResize();\r\n    });\r\n    resizeObserver.observe(canvasRef.value.parentElement);\r\n  }\r\n  animate();\r\n});\r\n\r\nonUnmounted(() => {\r\n  cleanup();\r\n  if (resizeObserver) {\r\n    resizeObserver.disconnect();\r\n  }\r\n});\r\n</script>\r\n",
      "target": "web"
    },
    {
      "path": "CosmicPortal.vue",
      "content": "<template>\r\n  <view :class=\"['relative overflow-hidden h-full w-full', props.containerClass]\">\r\n    <canvas\r\n      ref=\"canvasRef\"\r\n      :class=\"['absolute inset-0 h-full w-full block', props.class]\"\r\n    />\r\n  </view>\r\n</template>\r\n\r\n<script setup lang=\"ts\">\r\nimport * as THREE from \"three\";\r\nimport { OrbitControls } from \"three/addons/controls/OrbitControls.js\";\r\nimport { EffectComposer } from \"three/addons/postprocessing/EffectComposer.js\";\r\nimport { RenderPass } from \"three/addons/postprocessing/RenderPass.js\";\r\nimport { UnrealBloomPass } from \"three/addons/postprocessing/UnrealBloomPass.js\";\r\nimport { ShaderPass } from \"three/addons/postprocessing/ShaderPass.js\";\r\nimport { FXAAShader } from \"three/addons/shaders/FXAAShader.js\";\r\n\r\ninterface PortalParams {\r\n  portalComplexity: number;\r\n  crystalCount: number;\r\n  primaryColor: string;\r\n  secondaryColor: string;\r\n  accentColor: string;\r\n  vortexColor: string;\r\n  rotationSpeed: number;\r\n  bloomStrength: number;\r\n  bloomRadius: number;\r\n  bloomThreshold: number;\r\n  dimensionShift: number;\r\n}\r\n\r\nconst props = withDefaults(\r\n  defineProps<Partial<PortalParams> & { class?: string; containerClass?: string }>(),\r\n  {\r\n    portalComplexity: 4,\r\n    crystalCount: 12,\r\n    primaryColor: \"#9b59b6\",\r\n    secondaryColor: \"#3498db\",\r\n    accentColor: \"#e74c3c\",\r\n    vortexColor: \"#2ecc71\",\r\n    rotationSpeed: 0.3,\r\n    bloomStrength: 1.2,\r\n    bloomRadius: 0.7,\r\n    bloomThreshold: 0.2,\r\n    dimensionShift: 4,\r\n    class: \"\",\r\n    containerClass: \"\",\r\n  },\r\n);\r\n\r\nconst params = ref<PortalParams>({\r\n  portalComplexity: props.portalComplexity,\r\n  crystalCount: props.crystalCount,\r\n  primaryColor: props.primaryColor,\r\n  secondaryColor: props.secondaryColor,\r\n  accentColor: props.accentColor,\r\n  vortexColor: props.vortexColor,\r\n  rotationSpeed: props.rotationSpeed,\r\n  bloomStrength: props.bloomStrength,\r\n  bloomRadius: props.bloomRadius,\r\n  bloomThreshold: props.bloomThreshold,\r\n  dimensionShift: props.dimensionShift,\r\n});\r\n\r\nconst canvasRef = ref<HTMLCanvasElement>();\r\n\r\n// Three.js core objects\r\nlet scene: THREE.Scene;\r\nlet camera: THREE.PerspectiveCamera;\r\nlet renderer: THREE.WebGLRenderer;\r\nlet composer: EffectComposer;\r\nlet controls: OrbitControls;\r\nlet bloomPass: UnrealBloomPass;\r\nlet fxaaPass: ShaderPass;\r\nlet clock: THREE.Clock;\r\n\r\n// Portal objects\r\nlet meshes: THREE.Object3D[] = [];\r\nlet materials: THREE.Material[] = [];\r\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\nlet portalMaterials: any[] = [];\r\nlet portalLights: THREE.Light[] = [];\r\nlet animationId: number;\r\nlet time = 0;\r\n\r\nlet resizeObserver: ResizeObserver;\r\n\r\nfunction initThreeJS() {\r\n  if (!canvasRef.value) return;\r\n\r\n  // Scene setup\r\n  scene = new THREE.Scene();\r\n  scene.background = new THREE.Color(0x0a0015);\r\n  scene.fog = new THREE.FogExp2(0x1a0033, 0.001);\r\n\r\n  // Camera setup - get container dimensions first\r\n  const container = canvasRef.value.parentElement;\r\n  const width = container ? container.clientWidth : window.innerWidth;\r\n  const height = container ? container.clientHeight : window.innerHeight;\r\n\r\n  camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);\r\n  camera.position.set(0, 0, 15);\r\n\r\n  // Lighting\r\n  scene.add(new THREE.AmbientLight(0x330066, 0.2));\r\n  const mainLight = new THREE.DirectionalLight(0xffffff, 0.6);\r\n  mainLight.position.set(10, 10, 5);\r\n  scene.add(mainLight);\r\n\r\n  // Portal lights\r\n  const lightColors = [\r\n    params.value.primaryColor,\r\n    params.value.secondaryColor,\r\n    params.value.accentColor,\r\n    params.value.vortexColor,\r\n  ];\r\n  for (let i = 0; i < 6; i++) {\r\n    const light = new THREE.PointLight(new THREE.Color(lightColors[i % 4]), 0.8, 20);\r\n    scene.add(light);\r\n    portalLights.push(light);\r\n  }\r\n\r\n  // Renderer setup - use the container dimensions\r\n  renderer = new THREE.WebGLRenderer({\r\n    canvas: canvasRef.value,\r\n    antialias: true,\r\n    powerPreference: \"high-performance\",\r\n  });\r\n  renderer.setSize(width, height);\r\n  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));\r\n  renderer.outputColorSpace = THREE.SRGBColorSpace;\r\n  renderer.toneMapping = THREE.ACESFilmicToneMapping;\r\n  renderer.toneMappingExposure = 1.2;\r\n\r\n  // Controls\r\n  controls = new OrbitControls(camera, canvasRef.value);\r\n  controls.enableDamping = true;\r\n  controls.dampingFactor = 0.08;\r\n  controls.autoRotate = true;\r\n  controls.autoRotateSpeed = 0.5;\r\n  controls.minDistance = 8;\r\n  controls.maxDistance = 40;\r\n\r\n  // Post-processing\r\n  composer = new EffectComposer(renderer);\r\n  composer.addPass(new RenderPass(scene, camera));\r\n\r\n  bloomPass = new UnrealBloomPass(\r\n    new THREE.Vector2(width, height),\r\n    params.value.bloomStrength,\r\n    params.value.bloomRadius,\r\n    params.value.bloomThreshold,\r\n  );\r\n  composer.addPass(bloomPass);\r\n\r\n  fxaaPass = new ShaderPass(FXAAShader);\r\n  const pixelRatio = renderer.getPixelRatio();\r\n  fxaaPass.material.uniforms[\"resolution\"].value.set(\r\n    1 / (width * pixelRatio),\r\n    1 / (height * pixelRatio),\r\n  );\r\n  composer.addPass(fxaaPass);\r\n\r\n  clock = new THREE.Clock();\r\n}\r\n\r\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\nfunction addPortalShader(material: any) {\r\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n  material.onBeforeCompile = (shader: any) => {\r\n    shader.uniforms.time = { value: 0 };\r\n    shader.uniforms.pulseTime = { value: -1000 };\r\n    shader.uniforms.portalSpeed = { value: 8.0 };\r\n    shader.uniforms.portalColor = { value: new THREE.Color(params.value.accentColor) };\r\n    shader.uniforms.dimensionShift = { value: 0 };\r\n\r\n    shader.vertexShader = `varying vec3 vWorldPosition;\\n` + shader.vertexShader;\r\n\r\n    shader.fragmentShader =\r\n      `\r\n        uniform float time;\r\n        uniform float pulseTime;\r\n        uniform float portalSpeed;\r\n        uniform vec3 portalColor;\r\n        uniform float dimensionShift;\r\n        varying vec3 vWorldPosition;\\n` + shader.fragmentShader;\r\n\r\n    shader.vertexShader = shader.vertexShader.replace(\r\n      \"#include <begin_vertex>\",\r\n      `#include <begin_vertex>\r\n       vWorldPosition = (modelMatrix * vec4(transformed, 1.0)).xyz;`,\r\n    );\r\n\r\n    shader.fragmentShader = shader.fragmentShader.replace(\r\n      \"#include <emissivemap_fragment>\",\r\n      `#include <emissivemap_fragment>\r\n       float timeSincePortal = time - pulseTime;\r\n       if(timeSincePortal > 0.0 && timeSincePortal < 3.0) {\r\n         float portalRadius = timeSincePortal * portalSpeed;\r\n         float currentRadius = length(vWorldPosition);\r\n         float portalWidth = 1.5;\r\n         float portalEffect = smoothstep(portalRadius - portalWidth, portalRadius, currentRadius) -\r\n                             smoothstep(portalRadius, portalRadius + portalWidth, currentRadius);\r\n         vec3 dimensionalColor = mix(portalColor, vec3(1.0, 0.5, 1.0), sin(dimensionShift * 3.14159) * 0.5 + 0.5);\r\n         totalEmissiveRadiance += dimensionalColor * portalEffect * 4.0;\r\n       }`,\r\n    );\r\n    portalMaterials.push(shader);\r\n  };\r\n}\r\n\r\nfunction createCosmicBackground() {\r\n  const count = 4000;\r\n  const geo = new THREE.BufferGeometry();\r\n  const positions = new Float32Array(count * 3);\r\n  const colors = new Float32Array(count * 3);\r\n\r\n  for (let i = 0; i < count; i++) {\r\n    const i3 = i * 3;\r\n    const radius = 80 + Math.random() * 50;\r\n    const theta = Math.random() * Math.PI * 2;\r\n    const phi = Math.acos(2 * Math.random() - 1);\r\n\r\n    positions[i3] = radius * Math.sin(phi) * Math.cos(theta);\r\n    positions[i3 + 1] = radius * Math.sin(phi) * Math.sin(theta);\r\n    positions[i3 + 2] = radius * Math.cos(phi);\r\n\r\n    const temp = Math.random();\r\n    const color = new THREE.Color();\r\n    if (temp < 0.15) color.setHSL(0.8, 0.8, 0.9);\r\n    else if (temp < 0.4) color.setHSL(0.6, 0.6, 0.8);\r\n    else if (temp < 0.7) color.setHSL(0.1, 0.3, 0.9);\r\n    else color.setHSL(0.3, 0.7, 0.6);\r\n\r\n    color.toArray(colors, i3);\r\n  }\r\n\r\n  geo.setAttribute(\"position\", new THREE.BufferAttribute(positions, 3));\r\n  geo.setAttribute(\"color\", new THREE.BufferAttribute(colors, 3));\r\n\r\n  const mat = new THREE.PointsMaterial({\r\n    size: 0.3,\r\n    vertexColors: true,\r\n    sizeAttenuation: true,\r\n    blending: THREE.AdditiveBlending,\r\n    depthWrite: false,\r\n    transparent: true,\r\n  });\r\n\r\n  const stars = new THREE.Points(geo, mat);\r\n  scene.add(stars);\r\n  meshes.push(stars);\r\n  materials.push(mat);\r\n}\r\n\r\nfunction createPortalCore() {\r\n  const geo = new THREE.SphereGeometry(0.8, 32, 32);\r\n  const mat = new THREE.ShaderMaterial({\r\n    uniforms: {\r\n      time: { value: 0 },\r\n      pulseTime: { value: -1000 },\r\n      dimensionShift: { value: 0 },\r\n      color1: { value: new THREE.Color(params.value.primaryColor) },\r\n      color2: { value: new THREE.Color(params.value.secondaryColor) },\r\n      color3: { value: new THREE.Color(params.value.accentColor) },\r\n    },\r\n    vertexShader: `\r\n      uniform float time;\r\n      uniform float dimensionShift;\r\n      varying vec3 vPos;\r\n      varying vec3 vNorm;\r\n      void main() {\r\n        vPos = position;\r\n        vNorm = normal;\r\n        float warp = sin(position.x * 10.0 + time * 3.0) * 0.1;\r\n        float shift = sin(dimensionShift * 6.28318) * 0.3;\r\n        vec3 p = position * (1.0 + warp + shift);\r\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(p, 1.0);\r\n      }\r\n    `,\r\n    fragmentShader: `\r\n      uniform float time;\r\n      uniform float pulseTime;\r\n      uniform float dimensionShift;\r\n      uniform vec3 color1;\r\n      uniform vec3 color2;\r\n      uniform vec3 color3;\r\n      varying vec3 vPos;\r\n      varying vec3 vNorm;\r\n      void main() {\r\n        float noise = sin(vPos.x * 20.0 + time * 4.0) * cos(vPos.z * 15.0 + time * 3.0);\r\n        vec3 baseColor = mix(color1, color2, 0.5 + 0.5 * sin(time * 2.0 + dimensionShift));\r\n        vec3 finalColor = mix(baseColor, color3, noise * 0.3);\r\n\r\n        float fresnel = pow(1.0 - abs(dot(vNorm, normalize(cameraPosition - vPos))), 3.0);\r\n        finalColor = mix(finalColor, vec3(1.0), fresnel * 0.5);\r\n\r\n        float timeSincePortal = time - pulseTime;\r\n        if(timeSincePortal > 0.0 && timeSincePortal < 1.0) {\r\n          float burst = 1.0 - timeSincePortal;\r\n          finalColor += vec3(1.0) * burst * 3.0;\r\n        }\r\n\r\n        gl_FragColor = vec4(finalColor, 0.9);\r\n      }\r\n    `,\r\n    transparent: true,\r\n  });\r\n\r\n  portalMaterials.push(mat);\r\n  const mesh = new THREE.Mesh(geo, mat);\r\n  scene.add(mesh);\r\n  meshes.push(mesh);\r\n}\r\n\r\nfunction createVortexRings() {\r\n  const colors = [\r\n    params.value.primaryColor,\r\n    params.value.secondaryColor,\r\n    params.value.accentColor,\r\n    params.value.vortexColor,\r\n  ];\r\n\r\n  for (let ring = 0; ring < 5; ring++) {\r\n    const radius = 2 + ring * 0.8;\r\n    const geo = new THREE.TorusGeometry(radius, 0.05, 16, 64);\r\n    const mat = new THREE.MeshPhysicalMaterial({\r\n      color: new THREE.Color(colors[ring % colors.length]),\r\n      transparent: true,\r\n      opacity: 0.7,\r\n      metalness: 0.8,\r\n      roughness: 0.2,\r\n      clearcoat: 0.8,\r\n      clearcoatRoughness: 0.1,\r\n      emissive: new THREE.Color(colors[ring % colors.length]).multiplyScalar(0.2),\r\n    });\r\n\r\n    addPortalShader(mat);\r\n    const mesh = new THREE.Mesh(geo, mat);\r\n    mesh.rotation.x = Math.PI * 0.1 * ring;\r\n    mesh.rotation.z = Math.PI * 0.15 * ring;\r\n    scene.add(mesh);\r\n    meshes.push(mesh);\r\n  }\r\n}\r\n\r\nfunction createFloatingCrystals() {\r\n  const colors = [\r\n    params.value.accentColor,\r\n    params.value.vortexColor,\r\n    params.value.primaryColor,\r\n    params.value.secondaryColor,\r\n  ];\r\n\r\n  for (let i = 0; i < params.value.crystalCount; i++) {\r\n    const geo = new THREE.OctahedronGeometry(0.3 + Math.random() * 0.4, 1);\r\n    const mat = new THREE.MeshPhysicalMaterial({\r\n      color: new THREE.Color(colors[i % colors.length]),\r\n      transparent: true,\r\n      opacity: 0.8,\r\n      metalness: 0.9,\r\n      roughness: 0.1,\r\n      clearcoat: 1.0,\r\n      clearcoatRoughness: 0.0,\r\n      emissive: new THREE.Color(colors[i % colors.length]).multiplyScalar(0.3),\r\n    });\r\n\r\n    addPortalShader(mat);\r\n    const mesh = new THREE.Mesh(geo, mat);\r\n    const angle = (i / params.value.crystalCount) * Math.PI * 2;\r\n    const radius = 6 + Math.random() * 4;\r\n    mesh.position.set(\r\n      Math.cos(angle) * radius,\r\n      (Math.random() - 0.5) * 8,\r\n      Math.sin(angle) * radius,\r\n    );\r\n    mesh.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);\r\n    scene.add(mesh);\r\n    meshes.push(mesh);\r\n  }\r\n}\r\n\r\nfunction createDimensionalStreams() {\r\n  const colors = [params.value.vortexColor, params.value.primaryColor, params.value.secondaryColor];\r\n\r\n  for (let i = 0; i < 8; i++) {\r\n    const points = [];\r\n    const segments = 120;\r\n\r\n    for (let j = 0; j <= segments; j++) {\r\n      const t = j / segments;\r\n      const angle = t * Math.PI * 12 + i * Math.PI * 0.25;\r\n      const radius = 3 + Math.sin(t * Math.PI * 6) * 1.5;\r\n      const height = (t - 0.5) * 15;\r\n\r\n      points.push(new THREE.Vector3(Math.cos(angle) * radius, height, Math.sin(angle) * radius));\r\n    }\r\n\r\n    const curve = new THREE.CatmullRomCurve3(points);\r\n    const geo = new THREE.TubeGeometry(curve, segments, 0.02, 8, false);\r\n    const mat = new THREE.MeshPhysicalMaterial({\r\n      color: new THREE.Color(colors[i % colors.length]),\r\n      transparent: true,\r\n      opacity: 0.6,\r\n      metalness: 1.0,\r\n      roughness: 0.0,\r\n      emissive: new THREE.Color(colors[i % colors.length]).multiplyScalar(0.4),\r\n    });\r\n\r\n    addPortalShader(mat);\r\n    const stream = new THREE.Mesh(geo, mat);\r\n    scene.add(stream);\r\n    meshes.push(stream);\r\n  }\r\n}\r\n\r\nfunction createPortalFrame() {\r\n  const frameGeo = new THREE.TorusGeometry(7, 0.2, 16, 64);\r\n  const frameMat = new THREE.MeshPhysicalMaterial({\r\n    color: new THREE.Color(params.value.primaryColor),\r\n    transparent: true,\r\n    opacity: 0.4,\r\n    metalness: 1.0,\r\n    roughness: 0.1,\r\n    clearcoat: 1.0,\r\n    clearcoatRoughness: 0.0,\r\n    emissive: new THREE.Color(params.value.primaryColor).multiplyScalar(0.5),\r\n  });\r\n\r\n  addPortalShader(frameMat);\r\n  const frame = new THREE.Mesh(frameGeo, frameMat);\r\n  scene.add(frame);\r\n  meshes.push(frame);\r\n}\r\n\r\nfunction createEnergyParticles() {\r\n  const count = 1500;\r\n  const geo = new THREE.BufferGeometry();\r\n  const positions = new Float32Array(count * 3);\r\n\r\n  for (let i = 0; i < count; i++) {\r\n    const r = 2 + Math.random() * 8;\r\n    const theta = Math.random() * Math.PI * 2;\r\n    const phi = Math.acos(2 * Math.random() - 1);\r\n\r\n    positions[i * 3] = r * Math.sin(phi) * Math.cos(theta);\r\n    positions[i * 3 + 1] = r * Math.sin(phi) * Math.sin(theta);\r\n    positions[i * 3 + 2] = r * Math.cos(phi);\r\n  }\r\n\r\n  geo.setAttribute(\"position\", new THREE.BufferAttribute(positions, 3));\r\n\r\n  const mat = new THREE.PointsMaterial({\r\n    size: 0.08,\r\n    color: params.value.vortexColor,\r\n    blending: THREE.AdditiveBlending,\r\n    transparent: true,\r\n    opacity: 0.8,\r\n  });\r\n\r\n  const particles = new THREE.Points(geo, mat);\r\n  scene.add(particles);\r\n  meshes.push(particles);\r\n  materials.push(mat);\r\n}\r\n\r\nfunction createSpaceDistortion() {\r\n  const geo = new THREE.SphereGeometry(12, 64, 64);\r\n  const mat = new THREE.ShaderMaterial({\r\n    uniforms: {\r\n      time: { value: 0 },\r\n      dimensionShift: { value: 0 },\r\n      color1: { value: new THREE.Color(params.value.primaryColor) },\r\n      color2: { value: new THREE.Color(params.value.vortexColor) },\r\n    },\r\n    vertexShader: `\r\n      uniform float time;\r\n      uniform float dimensionShift;\r\n      varying vec3 vNorm;\r\n      varying vec3 vPos;\r\n      void main() {\r\n        vNorm = normal;\r\n        vPos = position;\r\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n      }\r\n    `,\r\n    fragmentShader: `\r\n      uniform float time;\r\n      uniform float dimensionShift;\r\n      uniform vec3 color1;\r\n      uniform vec3 color2;\r\n      varying vec3 vNorm;\r\n      varying vec3 vPos;\r\n      void main() {\r\n        vec3 viewDir = normalize(cameraPosition - vPos);\r\n        float fresnel = pow(1.0 - abs(dot(vNorm, viewDir)), 4.0);\r\n\r\n        float distortion = sin(vPos.x * 0.5 + time * 2.0) * cos(vPos.y * 0.7 + time * 1.5);\r\n        vec3 color = mix(color1, color2, distortion * 0.5 + 0.5 + dimensionShift * 0.3);\r\n\r\n        gl_FragColor = vec4(color, fresnel * 0.3);\r\n      }\r\n    `,\r\n    transparent: true,\r\n    blending: THREE.AdditiveBlending,\r\n    depthWrite: false,\r\n  });\r\n\r\n  const distortion = new THREE.Mesh(geo, mat);\r\n  scene.add(distortion);\r\n  meshes.push(distortion);\r\n  materials.push(mat);\r\n}\r\n\r\nfunction createPortalScene() {\r\n  // Clean up existing meshes\r\n  meshes.forEach((mesh) => scene.remove(mesh));\r\n  materials.forEach((mat) => mat.dispose());\r\n  meshes = [];\r\n  materials = [];\r\n  portalMaterials = [];\r\n\r\n  // Create portal components\r\n  createCosmicBackground();\r\n  createPortalCore();\r\n  createVortexRings();\r\n  createFloatingCrystals();\r\n  createDimensionalStreams();\r\n  createPortalFrame();\r\n  createEnergyParticles();\r\n  createSpaceDistortion();\r\n}\r\n\r\nfunction handleResize() {\r\n  if (!camera || !renderer || !composer || !canvasRef.value) return;\r\n\r\n  const container = canvasRef.value.parentElement;\r\n  if (!container) return;\r\n\r\n  const width = container.clientWidth;\r\n  const height = container.clientHeight;\r\n\r\n  // Update camera\r\n  camera.aspect = width / height;\r\n  camera.updateProjectionMatrix();\r\n\r\n  // Update renderer and composer\r\n  renderer.setSize(width, height);\r\n  composer.setSize(width, height);\r\n\r\n  // Update FXAA pass\r\n  const pixelRatio = renderer.getPixelRatio();\r\n  fxaaPass.material.uniforms[\"resolution\"].value.set(\r\n    1 / (width * pixelRatio),\r\n    1 / (height * pixelRatio),\r\n  );\r\n}\r\n\r\nfunction animate() {\r\n  animationId = requestAnimationFrame(animate);\r\n\r\n  const delta = clock.getDelta();\r\n  time = clock.getElapsedTime();\r\n\r\n  // Update shader uniforms\r\n  portalMaterials.forEach((shader) => {\r\n    if (shader.uniforms) {\r\n      if (shader.uniforms.time) shader.uniforms.time.value = time;\r\n      if (shader.uniforms.dimensionShift)\r\n        shader.uniforms.dimensionShift.value = params.value.dimensionShift;\r\n    }\r\n  });\r\n\r\n  materials.forEach((mat) => {\r\n    if (mat.uniforms) {\r\n      if (mat.uniforms.time) mat.uniforms.time.value = time;\r\n      if (mat.uniforms.dimensionShift)\r\n        mat.uniforms.dimensionShift.value = params.value.dimensionShift;\r\n    }\r\n  });\r\n\r\n  // Animate portal lights\r\n  portalLights.forEach((light, i) => {\r\n    const angle = time * 0.3 + (i / 6) * Math.PI * 2;\r\n    const radius = 10 + Math.sin(time * 0.5 + i) * 3;\r\n    light.position.x = Math.cos(angle) * radius;\r\n    light.position.z = Math.sin(angle) * radius;\r\n    light.position.y = Math.sin(time * 0.4 + i * 0.7) * 5;\r\n  });\r\n\r\n  // Animate meshes\r\n  meshes.forEach((mesh, i) => {\r\n    if (!mesh.rotation) return;\r\n    const speed = params.value.rotationSpeed;\r\n    mesh.rotation.y += delta * speed * (i % 2 ? -1 : 1) * 0.3;\r\n    mesh.rotation.x += delta * speed * 0.1;\r\n\r\n    // Animate particle positions\r\n    if (mesh.material && mesh.material.type === \"PointsMaterial\") {\r\n      const positions = mesh.geometry.attributes.position.array;\r\n      for (let j = 0; j < positions.length; j += 3) {\r\n        positions[j] += Math.sin(time + j) * 0.001;\r\n        positions[j + 1] += Math.cos(time + j) * 0.001;\r\n        positions[j + 2] += Math.sin(time * 0.7 + j) * 0.001;\r\n      }\r\n      mesh.geometry.attributes.position.needsUpdate = true;\r\n    }\r\n  });\r\n\r\n  controls.update();\r\n  composer.render();\r\n}\r\n\r\nfunction cleanup() {\r\n  if (animationId) {\r\n    cancelAnimationFrame(animationId);\r\n  }\r\n\r\n  // Dispose of Three.js objects\r\n  meshes.forEach((mesh) => {\r\n    if (mesh.geometry) mesh.geometry.dispose();\r\n    if (mesh.material) {\r\n      if (Array.isArray(mesh.material)) {\r\n        mesh.material.forEach((mat) => mat.dispose());\r\n      } else {\r\n        mesh.material.dispose();\r\n      }\r\n    }\r\n  });\r\n\r\n  materials.forEach((mat) => mat.dispose());\r\n\r\n  if (renderer) {\r\n    renderer.dispose();\r\n  }\r\n\r\n  if (controls) {\r\n    controls.dispose();\r\n  }\r\n\r\n  window.removeEventListener(\"resize\", handleResize);\r\n}\r\n\r\n// Exposed methods\r\nfunction activatePortal() {\r\n  portalMaterials.forEach((mat) => {\r\n    if (mat.uniforms && mat.uniforms.pulseTime) {\r\n      mat.uniforms.pulseTime.value = time;\r\n    }\r\n  });\r\n}\r\n\r\nfunction shiftDimensions() {\r\n  const colors = [\r\n    \"#9b59b6\",\r\n    \"#3498db\",\r\n    \"#e74c3c\",\r\n    \"#2ecc71\",\r\n    \"#f39c12\",\r\n    \"#e67e22\",\r\n    \"#1abc9c\",\r\n    \"#34495e\",\r\n  ];\r\n  params.value.primaryColor = colors[Math.floor(Math.random() * colors.length)];\r\n  params.value.secondaryColor = colors[Math.floor(Math.random() * colors.length)];\r\n  params.value.accentColor = colors[Math.floor(Math.random() * colors.length)];\r\n  params.value.vortexColor = colors[Math.floor(Math.random() * colors.length)];\r\n  params.value.dimensionShift = Math.random();\r\n  createPortalScene();\r\n}\r\n\r\n// Expose methods to parent component\r\ndefineExpose({\r\n  activatePortal,\r\n  shiftDimensions,\r\n});\r\n\r\nonMounted(() => {\r\n  initThreeJS();\r\n  createPortalScene();\r\n  // Use ResizeObserver instead of window resize\r\n  if (canvasRef.value?.parentElement) {\r\n    resizeObserver = new ResizeObserver(() => {\r\n      handleResize();\r\n    });\r\n    resizeObserver.observe(canvasRef.value.parentElement);\r\n  }\r\n  animate();\r\n});\r\n\r\nonUnmounted(() => {\r\n  cleanup();\r\n  if (resizeObserver) {\r\n    resizeObserver.disconnect();\r\n  }\r\n});\r\n</script>\r\n",
      "target": "uniapp"
    },
    {
      "path": "index.ts",
      "content": "export { default as CosmicPortal } from \"./CosmicPortal.vue\";\r\n"
    }
  ],
  "fileCount": 3,
  "contentHash": "3493a28855b5ddae0a7d781a9f19304a15eaeea9"
}
