{
  "name": "bg-neural",
  "dependencies": [
    "ogl"
  ],
  "files": [
    {
      "path": "NeuralBg.vue",
      "content": "<template>\r\n  <canvas\r\n    ref=\"canvasRef\"\r\n    :class=\"cn('absolute inset-0 size-full pointer-events-none opacity-95', props.class)\"\r\n  />\r\n</template>\r\n\r\n<script setup lang=\"ts\">\r\nimport { ref, onMounted, onUnmounted, watch, type HTMLAttributes } from \"vue\";\r\nimport { Renderer, Camera, Transform, Program, Mesh, Plane } from \"ogl\";\r\nimport { cn } from \"~/lib/utils\";\r\n\r\ninterface Props {\r\n  hue?: number;\r\n  saturation?: number;\r\n  chroma?: number;\r\n  class?: HTMLAttributes[\"class\"];\r\n}\r\n\r\nconst props = withDefaults(defineProps<Props>(), {\r\n  hue: 200, // Blue hue by default\r\n  saturation: 0.8,\r\n  chroma: 0.6,\r\n});\r\n\r\nconst canvasRef = ref<HTMLCanvasElement | null>(null);\r\nconst animationRef = ref<number | null>(null);\r\nconst rendererRef = ref<Renderer | null>(null);\r\nconst sceneRef = ref<Transform | null>(null);\r\nconst meshRef = ref<Mesh | null>(null);\r\nconst cameraRef = ref<Camera | null>(null);\r\n\r\nconst pointerRef = ref({\r\n  x: 0,\r\n  y: 0,\r\n  tX: 0,\r\n  tY: 0,\r\n});\r\n\r\nconst vertexShader = `\r\n  precision mediump float;\r\n\r\n  attribute vec2 position;\r\n  attribute vec2 uv;\r\n\r\n  varying vec2 vUv;\r\n\r\n  void main() {\r\n      vUv = uv;\r\n      gl_Position = vec4(position, 0.0, 1.0);\r\n  }\r\n`;\r\n\r\nconst fragmentShader = `\r\n  precision mediump float;\r\n\r\n  varying vec2 vUv;\r\n  uniform float u_time;\r\n  uniform float u_ratio;\r\n  uniform vec2 u_pointer_position;\r\n  uniform float u_scroll_progress;\r\n  uniform float u_hue;\r\n  uniform float u_saturation;\r\n  uniform float u_chroma;\r\n\r\n  vec2 rotate(vec2 uv, float th) {\r\n      return mat2(cos(th), sin(th), -sin(th), cos(th)) * uv;\r\n  }\r\n\r\n  float neuro_shape(vec2 uv, float t, float p) {\r\n      vec2 sine_acc = vec2(0.);\r\n      vec2 res = vec2(0.);\r\n      float scale = 8.;\r\n\r\n      for (int j = 0; j < 15; j++) {\r\n          uv = rotate(uv, 1.);\r\n          sine_acc = rotate(sine_acc, 1.);\r\n          vec2 layer = uv * scale + float(j) + sine_acc - t;\r\n          sine_acc += sin(layer) + 2.4 * p;\r\n          res += (.5 + .5 * cos(layer)) / scale;\r\n          scale *= (1.2);\r\n      }\r\n      return res.x + res.y;\r\n  }\r\n\r\n  // HSL to RGB conversion\r\n  vec3 hsl2rgb(vec3 c) {\r\n      vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0);\r\n      return c.z + c.y * (rgb - 0.5) * (1.0 - abs(2.0 * c.z - 1.0));\r\n  }\r\n\r\n  void main() {\r\n      vec2 uv = .5 * vUv;\r\n      uv.x *= u_ratio;\r\n\r\n      vec2 pointer = vUv - u_pointer_position;\r\n      pointer.x *= u_ratio;\r\n      float p = clamp(length(pointer), 0., 1.);\r\n      p = .5 * pow(1. - p, 2.);\r\n\r\n      float t = .001 * u_time;\r\n      vec3 color = vec3(0.);\r\n\r\n      float noise = neuro_shape(uv, t, p);\r\n\r\n      noise = 1.2 * pow(noise, 3.);\r\n      noise += pow(noise, 10.);\r\n      noise = max(.0, noise - .5);\r\n      noise *= (1. - length(vUv - .5));\r\n\r\n      // Convert hue from degrees to 0-1 range\r\n      float normalizedHue = u_hue / 360.0;\r\n      \r\n      // Create HSL color with animation\r\n      vec3 hsl = vec3(\r\n          normalizedHue + 0.1 * sin(3.0 * u_scroll_progress + 1.5),\r\n          u_saturation,\r\n          u_chroma * 0.5 + 0.2 * sin(2.0 * u_scroll_progress)\r\n      );\r\n\r\n      // Convert to RGB\r\n      color = hsl2rgb(hsl);\r\n      color = color * noise;\r\n\r\n      gl_FragColor = vec4(color, noise);\r\n  }\r\n`;\r\n\r\nfunction initOGL() {\r\n  const canvas = canvasRef.value;\r\n  if (!canvas) return false;\r\n\r\n  try {\r\n    const renderer = new Renderer({\r\n      canvas,\r\n      width: canvas.clientWidth,\r\n      height: canvas.clientHeight,\r\n      dpr: Math.min(window.devicePixelRatio, 2),\r\n    });\r\n\r\n    const camera = new Camera(renderer.gl);\r\n    const scene = new Transform();\r\n\r\n    const geometry = new Plane(renderer.gl, {\r\n      width: 2,\r\n      height: 2,\r\n    });\r\n\r\n    const program = new Program(renderer.gl, {\r\n      vertex: vertexShader,\r\n      fragment: fragmentShader,\r\n      uniforms: {\r\n        u_time: { value: 0 },\r\n        u_ratio: { value: window.innerWidth / window.innerHeight },\r\n        u_pointer_position: { value: [0, 0] },\r\n        u_scroll_progress: { value: 0 },\r\n        u_hue: { value: props.hue },\r\n        u_saturation: { value: props.saturation },\r\n        u_chroma: { value: props.chroma },\r\n      },\r\n    });\r\n\r\n    const mesh = new Mesh(renderer.gl, {\r\n      geometry,\r\n      program,\r\n    });\r\n\r\n    mesh.setParent(scene);\r\n\r\n    rendererRef.value = renderer;\r\n    cameraRef.value = camera;\r\n    sceneRef.value = scene;\r\n    meshRef.value = mesh;\r\n\r\n    return true;\r\n  } catch (error) {\r\n    console.error(\"Error initializing OGL:\", error);\r\n    return false;\r\n  }\r\n}\r\n\r\nfunction resizeCanvas() {\r\n  const renderer = rendererRef.value;\r\n  const mesh = meshRef.value;\r\n  const canvas = canvasRef.value;\r\n\r\n  if (!canvas) return;\r\n\r\n  if (!renderer || !mesh) return;\r\n\r\n  const width = canvas.clientWidth;\r\n  const height = canvas.clientHeight;\r\n\r\n  renderer.setSize(width, height);\r\n\r\n  // Update ratio uniform\r\n  if (mesh.program && mesh.program.uniforms.u_ratio) {\r\n    mesh.program.uniforms.u_ratio.value = width / height;\r\n  }\r\n}\r\n\r\nfunction render() {\r\n  const renderer = rendererRef.value;\r\n  const scene = sceneRef.value;\r\n  const camera = cameraRef.value;\r\n  const mesh = meshRef.value;\r\n  const pointer = pointerRef.value;\r\n\r\n  if (!renderer || !scene || !camera || !mesh) return;\r\n\r\n  const currentTime = performance.now();\r\n\r\n  // Smooth pointer interpolation\r\n  pointer.x += (pointer.tX - pointer.x) * 0.2;\r\n  pointer.y += (pointer.tY - pointer.y) * 0.2;\r\n\r\n  // Update uniforms\r\n  if (mesh.program && mesh.program.uniforms) {\r\n    const uniforms = mesh.program.uniforms;\r\n\r\n    if (uniforms.u_time) uniforms.u_time.value = currentTime;\r\n    if (uniforms.u_pointer_position) {\r\n      uniforms.u_pointer_position.value = [\r\n        pointer.x / window.innerWidth,\r\n        1 - pointer.y / window.innerHeight,\r\n      ];\r\n    }\r\n    if (uniforms.u_scroll_progress) {\r\n      uniforms.u_scroll_progress.value = window.pageYOffset / (2 * window.innerHeight);\r\n    }\r\n  }\r\n\r\n  renderer.render({ scene, camera });\r\n  animationRef.value = requestAnimationFrame(render);\r\n}\r\n\r\nfunction updateMousePosition(x: number, y: number) {\r\n  pointerRef.value.tX = x;\r\n  pointerRef.value.tY = y;\r\n}\r\n\r\nfunction handlePointerMove(e: PointerEvent) {\r\n  updateMousePosition(e.clientX, e.clientY);\r\n}\r\n\r\nfunction handleTouchMove(e: TouchEvent) {\r\n  updateMousePosition(e.touches[0].clientX, e.touches[0].clientY);\r\n}\r\n\r\nfunction handleClick(e: MouseEvent) {\r\n  updateMousePosition(e.clientX, e.clientY);\r\n}\r\n\r\n// Watch for prop changes and update uniforms\r\nwatch(\r\n  () => props.hue,\r\n  (newHue) => {\r\n    const mesh = meshRef.value;\r\n    if (mesh && mesh.program && mesh.program.uniforms.u_hue) {\r\n      mesh.program.uniforms.u_hue.value = newHue;\r\n    }\r\n  },\r\n);\r\n\r\nwatch(\r\n  () => props.saturation,\r\n  (newSaturation) => {\r\n    const mesh = meshRef.value;\r\n    if (mesh && mesh.program && mesh.program.uniforms.u_saturation) {\r\n      mesh.program.uniforms.u_saturation.value = newSaturation;\r\n    }\r\n  },\r\n);\r\n\r\nwatch(\r\n  () => props.chroma,\r\n  (newChroma) => {\r\n    const mesh = meshRef.value;\r\n    if (mesh && mesh.program && mesh.program.uniforms.u_chroma) {\r\n      mesh.program.uniforms.u_chroma.value = newChroma;\r\n    }\r\n  },\r\n);\r\n\r\nonMounted(() => {\r\n  if (initOGL()) {\r\n    resizeCanvas();\r\n    render();\r\n\r\n    window.addEventListener(\"resize\", resizeCanvas);\r\n    window.addEventListener(\"pointermove\", handlePointerMove);\r\n    window.addEventListener(\"touchmove\", handleTouchMove);\r\n    window.addEventListener(\"click\", handleClick);\r\n  }\r\n});\r\n\r\nonUnmounted(() => {\r\n  if (animationRef.value) {\r\n    cancelAnimationFrame(animationRef.value);\r\n  }\r\n\r\n  window.removeEventListener(\"resize\", resizeCanvas);\r\n  window.removeEventListener(\"pointermove\", handlePointerMove);\r\n  window.removeEventListener(\"touchmove\", handleTouchMove);\r\n  window.removeEventListener(\"click\", handleClick);\r\n\r\n  // Clean up OGL resources\r\n  if (rendererRef.value) {\r\n    rendererRef.value = null;\r\n  }\r\n});\r\n</script>\r\n",
      "target": "web"
    },
    {
      "path": "NeuralBg.vue",
      "content": "<template>\r\n  <canvas\r\n    ref=\"canvasRef\"\r\n    :class=\"cn('absolute inset-0 size-full pointer-events-none opacity-95', props.class)\"\r\n  />\r\n</template>\r\n\r\n<script setup lang=\"ts\">\r\nimport { ref, onMounted, onUnmounted, watch, type HTMLAttributes } from \"vue\";\r\nimport { Renderer, Camera, Transform, Program, Mesh, Plane } from \"ogl\";\r\nimport { cn } from \"~/lib/utils\";\r\n\r\ninterface Props {\r\n  hue?: number;\r\n  saturation?: number;\r\n  chroma?: number;\r\n  class?: HTMLAttributes[\"class\"];\r\n}\r\n\r\nconst props = withDefaults(defineProps<Props>(), {\r\n  hue: 200, // Blue hue by default\r\n  saturation: 0.8,\r\n  chroma: 0.6,\r\n});\r\n\r\nconst canvasRef = ref<HTMLCanvasElement | null>(null);\r\nconst animationRef = ref<number | null>(null);\r\nconst rendererRef = ref<Renderer | null>(null);\r\nconst sceneRef = ref<Transform | null>(null);\r\nconst meshRef = ref<Mesh | null>(null);\r\nconst cameraRef = ref<Camera | null>(null);\r\n\r\nconst pointerRef = ref({\r\n  x: 0,\r\n  y: 0,\r\n  tX: 0,\r\n  tY: 0,\r\n});\r\n\r\nconst vertexShader = `\r\n  precision mediump float;\r\n\r\n  attribute vec2 position;\r\n  attribute vec2 uv;\r\n\r\n  varying vec2 vUv;\r\n\r\n  void main() {\r\n      vUv = uv;\r\n      gl_Position = vec4(position, 0.0, 1.0);\r\n  }\r\n`;\r\n\r\nconst fragmentShader = `\r\n  precision mediump float;\r\n\r\n  varying vec2 vUv;\r\n  uniform float u_time;\r\n  uniform float u_ratio;\r\n  uniform vec2 u_pointer_position;\r\n  uniform float u_scroll_progress;\r\n  uniform float u_hue;\r\n  uniform float u_saturation;\r\n  uniform float u_chroma;\r\n\r\n  vec2 rotate(vec2 uv, float th) {\r\n      return mat2(cos(th), sin(th), -sin(th), cos(th)) * uv;\r\n  }\r\n\r\n  float neuro_shape(vec2 uv, float t, float p) {\r\n      vec2 sine_acc = vec2(0.);\r\n      vec2 res = vec2(0.);\r\n      float scale = 8.;\r\n\r\n      for (int j = 0; j < 15; j++) {\r\n          uv = rotate(uv, 1.);\r\n          sine_acc = rotate(sine_acc, 1.);\r\n          vec2 layer = uv * scale + float(j) + sine_acc - t;\r\n          sine_acc += sin(layer) + 2.4 * p;\r\n          res += (.5 + .5 * cos(layer)) / scale;\r\n          scale *= (1.2);\r\n      }\r\n      return res.x + res.y;\r\n  }\r\n\r\n  // HSL to RGB conversion\r\n  vec3 hsl2rgb(vec3 c) {\r\n      vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0);\r\n      return c.z + c.y * (rgb - 0.5) * (1.0 - abs(2.0 * c.z - 1.0));\r\n  }\r\n\r\n  void main() {\r\n      vec2 uv = .5 * vUv;\r\n      uv.x *= u_ratio;\r\n\r\n      vec2 pointer = vUv - u_pointer_position;\r\n      pointer.x *= u_ratio;\r\n      float p = clamp(length(pointer), 0., 1.);\r\n      p = .5 * pow(1. - p, 2.);\r\n\r\n      float t = .001 * u_time;\r\n      vec3 color = vec3(0.);\r\n\r\n      float noise = neuro_shape(uv, t, p);\r\n\r\n      noise = 1.2 * pow(noise, 3.);\r\n      noise += pow(noise, 10.);\r\n      noise = max(.0, noise - .5);\r\n      noise *= (1. - length(vUv - .5));\r\n\r\n      // Convert hue from degrees to 0-1 range\r\n      float normalizedHue = u_hue / 360.0;\r\n      \r\n      // Create HSL color with animation\r\n      vec3 hsl = vec3(\r\n          normalizedHue + 0.1 * sin(3.0 * u_scroll_progress + 1.5),\r\n          u_saturation,\r\n          u_chroma * 0.5 + 0.2 * sin(2.0 * u_scroll_progress)\r\n      );\r\n\r\n      // Convert to RGB\r\n      color = hsl2rgb(hsl);\r\n      color = color * noise;\r\n\r\n      gl_FragColor = vec4(color, noise);\r\n  }\r\n`;\r\n\r\nfunction initOGL() {\r\n  const canvas = canvasRef.value;\r\n  if (!canvas) return false;\r\n\r\n  try {\r\n    const renderer = new Renderer({\r\n      canvas,\r\n      width: canvas.clientWidth,\r\n      height: canvas.clientHeight,\r\n      dpr: Math.min(window.devicePixelRatio, 2),\r\n    });\r\n\r\n    const camera = new Camera(renderer.gl);\r\n    const scene = new Transform();\r\n\r\n    const geometry = new Plane(renderer.gl, {\r\n      width: 2,\r\n      height: 2,\r\n    });\r\n\r\n    const program = new Program(renderer.gl, {\r\n      vertex: vertexShader,\r\n      fragment: fragmentShader,\r\n      uniforms: {\r\n        u_time: { value: 0 },\r\n        u_ratio: { value: window.innerWidth / window.innerHeight },\r\n        u_pointer_position: { value: [0, 0] },\r\n        u_scroll_progress: { value: 0 },\r\n        u_hue: { value: props.hue },\r\n        u_saturation: { value: props.saturation },\r\n        u_chroma: { value: props.chroma },\r\n      },\r\n    });\r\n\r\n    const mesh = new Mesh(renderer.gl, {\r\n      geometry,\r\n      program,\r\n    });\r\n\r\n    mesh.setParent(scene);\r\n\r\n    rendererRef.value = renderer;\r\n    cameraRef.value = camera;\r\n    sceneRef.value = scene;\r\n    meshRef.value = mesh;\r\n\r\n    return true;\r\n  } catch (error) {\r\n    console.error(\"Error initializing OGL:\", error);\r\n    return false;\r\n  }\r\n}\r\n\r\nfunction resizeCanvas() {\r\n  const renderer = rendererRef.value;\r\n  const mesh = meshRef.value;\r\n  const canvas = canvasRef.value;\r\n\r\n  if (!canvas) return;\r\n\r\n  if (!renderer || !mesh) return;\r\n\r\n  const width = canvas.clientWidth;\r\n  const height = canvas.clientHeight;\r\n\r\n  renderer.setSize(width, height);\r\n\r\n  // Update ratio uniform\r\n  if (mesh.program && mesh.program.uniforms.u_ratio) {\r\n    mesh.program.uniforms.u_ratio.value = width / height;\r\n  }\r\n}\r\n\r\nfunction render() {\r\n  const renderer = rendererRef.value;\r\n  const scene = sceneRef.value;\r\n  const camera = cameraRef.value;\r\n  const mesh = meshRef.value;\r\n  const pointer = pointerRef.value;\r\n\r\n  if (!renderer || !scene || !camera || !mesh) return;\r\n\r\n  const currentTime = performance.now();\r\n\r\n  // Smooth pointer interpolation\r\n  pointer.x += (pointer.tX - pointer.x) * 0.2;\r\n  pointer.y += (pointer.tY - pointer.y) * 0.2;\r\n\r\n  // Update uniforms\r\n  if (mesh.program && mesh.program.uniforms) {\r\n    const uniforms = mesh.program.uniforms;\r\n\r\n    if (uniforms.u_time) uniforms.u_time.value = currentTime;\r\n    if (uniforms.u_pointer_position) {\r\n      uniforms.u_pointer_position.value = [\r\n        pointer.x / window.innerWidth,\r\n        1 - pointer.y / window.innerHeight,\r\n      ];\r\n    }\r\n    if (uniforms.u_scroll_progress) {\r\n      uniforms.u_scroll_progress.value = window.pageYOffset / (2 * window.innerHeight);\r\n    }\r\n  }\r\n\r\n  renderer.render({ scene, camera });\r\n  animationRef.value = requestAnimationFrame(render);\r\n}\r\n\r\nfunction updateMousePosition(x: number, y: number) {\r\n  pointerRef.value.tX = x;\r\n  pointerRef.value.tY = y;\r\n}\r\n\r\nfunction handlePointerMove(e: PointerEvent) {\r\n  updateMousePosition(e.clientX, e.clientY);\r\n}\r\n\r\nfunction handleTouchMove(e: TouchEvent) {\r\n  updateMousePosition(e.touches[0].clientX, e.touches[0].clientY);\r\n}\r\n\r\nfunction handleClick(e: MouseEvent) {\r\n  updateMousePosition(e.clientX, e.clientY);\r\n}\r\n\r\n// Watch for prop changes and update uniforms\r\nwatch(\r\n  () => props.hue,\r\n  (newHue) => {\r\n    const mesh = meshRef.value;\r\n    if (mesh && mesh.program && mesh.program.uniforms.u_hue) {\r\n      mesh.program.uniforms.u_hue.value = newHue;\r\n    }\r\n  },\r\n);\r\n\r\nwatch(\r\n  () => props.saturation,\r\n  (newSaturation) => {\r\n    const mesh = meshRef.value;\r\n    if (mesh && mesh.program && mesh.program.uniforms.u_saturation) {\r\n      mesh.program.uniforms.u_saturation.value = newSaturation;\r\n    }\r\n  },\r\n);\r\n\r\nwatch(\r\n  () => props.chroma,\r\n  (newChroma) => {\r\n    const mesh = meshRef.value;\r\n    if (mesh && mesh.program && mesh.program.uniforms.u_chroma) {\r\n      mesh.program.uniforms.u_chroma.value = newChroma;\r\n    }\r\n  },\r\n);\r\n\r\nonMounted(() => {\r\n  if (initOGL()) {\r\n    resizeCanvas();\r\n    render();\r\n\r\n    window.addEventListener(\"resize\", resizeCanvas);\r\n    window.addEventListener(\"pointermove\", handlePointerMove);\r\n    window.addEventListener(\"touchmove\", handleTouchMove);\r\n    window.addEventListener(\"click\", handleClick);\r\n  }\r\n});\r\n\r\nonUnmounted(() => {\r\n  if (animationRef.value) {\r\n    cancelAnimationFrame(animationRef.value);\r\n  }\r\n\r\n  window.removeEventListener(\"resize\", resizeCanvas);\r\n  window.removeEventListener(\"pointermove\", handlePointerMove);\r\n  window.removeEventListener(\"touchmove\", handleTouchMove);\r\n  window.removeEventListener(\"click\", handleClick);\r\n\r\n  // Clean up OGL resources\r\n  if (rendererRef.value) {\r\n    rendererRef.value = null;\r\n  }\r\n});\r\n</script>\r\n",
      "target": "uniapp"
    }
  ],
  "fileCount": 2,
  "contentHash": "a533de58bd95ae02ca3854e7fd3df4a9089cf481"
}
