{
  "name": "particles-bg",
  "dependencies": [
    "@vueuse/core"
  ],
  "files": [
    {
      "path": "index.ts",
      "content": "export { default as ParticlesBg } from \"./ParticlesBg.vue\";\r\n"
    },
    {
      "path": "ParticlesBg.vue",
      "content": "<template>\r\n  <div\r\n    ref=\"canvasContainerRef\"\r\n    :class=\"$props.class\"\r\n    aria-hidden=\"true\"\r\n  >\r\n    <canvas ref=\"canvasRef\"></canvas>\r\n  </div>\r\n</template>\r\n\r\n<script setup lang=\"ts\">\r\nimport { useMouse, useDevicePixelRatio } from \"@vueuse/core\";\r\nimport { ref, onMounted, onBeforeUnmount, watch, computed, reactive } from \"vue\";\r\n\r\ntype Circle = {\r\n  x: number;\r\n  y: number;\r\n  translateX: number;\r\n  translateY: number;\r\n  size: number;\r\n  alpha: number;\r\n  targetAlpha: number;\r\n  dx: number;\r\n  dy: number;\r\n  magnetism: number;\r\n};\r\n\r\ntype Props = {\r\n  color?: string;\r\n  quantity?: number;\r\n  staticity?: number;\r\n  ease?: number;\r\n  class?: string;\r\n};\r\n\r\nconst props = withDefaults(defineProps<Props>(), {\r\n  color: \"#FFF\",\r\n  quantity: 100,\r\n  staticity: 50,\r\n  ease: 50,\r\n  class: \"\",\r\n});\r\n\r\nconst canvasRef = ref<HTMLCanvasElement | null>(null);\r\nconst canvasContainerRef = ref<HTMLDivElement | null>(null);\r\nconst context = ref<CanvasRenderingContext2D | null>(null);\r\nconst circles = ref<Circle[]>([]);\r\nconst mouse = reactive<{ x: number; y: number }>({ x: 0, y: 0 });\r\nconst canvasSize = reactive<{ w: number; h: number }>({ w: 0, h: 0 });\r\nconst { x: mouseX, y: mouseY } = useMouse();\r\nconst { pixelRatio } = useDevicePixelRatio();\r\n\r\nconst color = computed(() => {\r\n  // Remove the leading '#' if it's present\r\n  let hex = props.color.replace(/^#/, \"\");\r\n\r\n  // If the hex code is 3 characters, expand it to 6 characters\r\n  if (hex.length === 3) {\r\n    hex = hex\r\n      .split(\"\")\r\n      .map((char) => char + char)\r\n      .join(\"\");\r\n  }\r\n\r\n  // Parse the r, g, b values from the hex string\r\n  const bigint = parseInt(hex, 16);\r\n  const r = (bigint >> 16) & 255; // Extract the red component\r\n  const g = (bigint >> 8) & 255; // Extract the green component\r\n  const b = bigint & 255; // Extract the blue component\r\n\r\n  // Return the RGB values as a string separated by spaces\r\n  return `${r} ${g} ${b}`;\r\n});\r\n\r\nonMounted(() => {\r\n  if (canvasRef.value) {\r\n    context.value = canvasRef.value.getContext(\"2d\");\r\n  }\r\n\r\n  initCanvas();\r\n  animate();\r\n  window.addEventListener(\"resize\", initCanvas);\r\n});\r\n\r\nonBeforeUnmount(() => {\r\n  window.removeEventListener(\"resize\", initCanvas);\r\n});\r\n\r\nwatch([mouseX, mouseY], () => {\r\n  onMouseMove();\r\n});\r\n\r\nfunction initCanvas() {\r\n  resizeCanvas();\r\n  drawParticles();\r\n}\r\n\r\nfunction onMouseMove() {\r\n  if (canvasRef.value) {\r\n    const rect = canvasRef.value.getBoundingClientRect();\r\n    const { w, h } = canvasSize;\r\n    const x = mouseX.value - rect.left - w / 2;\r\n    const y = mouseY.value - rect.top - h / 2;\r\n\r\n    const inside = x < w / 2 && x > -w / 2 && y < h / 2 && y > -h / 2;\r\n    if (inside) {\r\n      mouse.x = x;\r\n      mouse.y = y;\r\n    }\r\n  }\r\n}\r\n\r\nfunction resizeCanvas() {\r\n  if (canvasContainerRef.value && canvasRef.value && context.value) {\r\n    circles.value.length = 0;\r\n    canvasSize.w = canvasContainerRef.value.offsetWidth;\r\n    canvasSize.h = canvasContainerRef.value.offsetHeight;\r\n    canvasRef.value.width = canvasSize.w * pixelRatio.value;\r\n    canvasRef.value.height = canvasSize.h * pixelRatio.value;\r\n    canvasRef.value.style.width = canvasSize.w + \"px\";\r\n    canvasRef.value.style.height = canvasSize.h + \"px\";\r\n    context.value.scale(pixelRatio.value, pixelRatio.value);\r\n  }\r\n}\r\n\r\nfunction circleParams(): Circle {\r\n  const x = Math.floor(Math.random() * canvasSize.w);\r\n  const y = Math.floor(Math.random() * canvasSize.h);\r\n  const translateX = 0;\r\n  const translateY = 0;\r\n  const size = Math.floor(Math.random() * 2) + 1;\r\n  const alpha = 0;\r\n  const targetAlpha = parseFloat((Math.random() * 0.6 + 0.1).toFixed(1));\r\n  const dx = (Math.random() - 0.5) * 0.2;\r\n  const dy = (Math.random() - 0.5) * 0.2;\r\n  const magnetism = 0.1 + Math.random() * 4;\r\n  return {\r\n    x,\r\n    y,\r\n    translateX,\r\n    translateY,\r\n    size,\r\n    alpha,\r\n    targetAlpha,\r\n    dx,\r\n    dy,\r\n    magnetism,\r\n  };\r\n}\r\n\r\nfunction drawCircle(circle: Circle, update = false) {\r\n  if (context.value) {\r\n    const { x, y, translateX, translateY, size, alpha } = circle;\r\n    context.value.translate(translateX, translateY);\r\n    context.value.beginPath();\r\n    context.value.arc(x, y, size, 0, 2 * Math.PI);\r\n    context.value.fillStyle = `rgba(${color.value.split(\" \").join(\", \")}, ${alpha})`;\r\n    context.value.fill();\r\n    context.value.setTransform(pixelRatio.value, 0, 0, pixelRatio.value, 0, 0);\r\n\r\n    if (!update) {\r\n      circles.value.push(circle);\r\n    }\r\n  }\r\n}\r\n\r\nfunction clearContext() {\r\n  if (context.value) {\r\n    context.value.clearRect(0, 0, canvasSize.w, canvasSize.h);\r\n  }\r\n}\r\n\r\nfunction drawParticles() {\r\n  clearContext();\r\n  const particleCount = props.quantity;\r\n  for (let i = 0; i < particleCount; i++) {\r\n    const circle = circleParams();\r\n    drawCircle(circle);\r\n  }\r\n}\r\n\r\nfunction remapValue(\r\n  value: number,\r\n  start1: number,\r\n  end1: number,\r\n  start2: number,\r\n  end2: number,\r\n): number {\r\n  const remapped = ((value - start1) * (end2 - start2)) / (end1 - start1) + start2;\r\n  return remapped > 0 ? remapped : 0;\r\n}\r\n\r\nfunction animate() {\r\n  clearContext();\r\n  circles.value.forEach((circle, i) => {\r\n    // Handle the alpha value\r\n    const edge = [\r\n      circle.x + circle.translateX - circle.size, // distance from left edge\r\n      canvasSize.w - circle.x - circle.translateX - circle.size, // distance from right edge\r\n      circle.y + circle.translateY - circle.size, // distance from top edge\r\n      canvasSize.h - circle.y - circle.translateY - circle.size, // distance from bottom edge\r\n    ];\r\n\r\n    const closestEdge = edge.reduce((a, b) => Math.min(a, b));\r\n    const remapClosestEdge = parseFloat(remapValue(closestEdge, 0, 20, 0, 1).toFixed(2));\r\n\r\n    if (remapClosestEdge > 1) {\r\n      circle.alpha += 0.02;\r\n      if (circle.alpha > circle.targetAlpha) circle.alpha = circle.targetAlpha;\r\n    } else {\r\n      circle.alpha = circle.targetAlpha * remapClosestEdge;\r\n    }\r\n\r\n    circle.x += circle.dx;\r\n    circle.y += circle.dy;\r\n    circle.translateX +=\r\n      (mouse.x / (props.staticity / circle.magnetism) - circle.translateX) / props.ease;\r\n    circle.translateY +=\r\n      (mouse.y / (props.staticity / circle.magnetism) - circle.translateY) / props.ease;\r\n\r\n    // circle gets out of the canvas\r\n    if (\r\n      circle.x < -circle.size ||\r\n      circle.x > canvasSize.w + circle.size ||\r\n      circle.y < -circle.size ||\r\n      circle.y > canvasSize.h + circle.size\r\n    ) {\r\n      // remove the circle from the array\r\n      circles.value.splice(i, 1);\r\n      // create a new circle\r\n      const newCircle = circleParams();\r\n      drawCircle(newCircle);\r\n      // update the circle position\r\n    } else {\r\n      drawCircle(\r\n        {\r\n          ...circle,\r\n          x: circle.x,\r\n          y: circle.y,\r\n          translateX: circle.translateX,\r\n          translateY: circle.translateY,\r\n          alpha: circle.alpha,\r\n        },\r\n        true,\r\n      );\r\n    }\r\n  });\r\n  window.requestAnimationFrame(animate);\r\n}\r\n</script>\r\n",
      "target": "web"
    },
    {
      "path": "ParticlesBg.vue",
      "content": "<template>\r\n  <view\r\n    ref=\"canvasContainerRef\"\r\n    :class=\"$props.class\"\r\n    aria-hidden=\"true\"\r\n  >\r\n    <canvas ref=\"canvasRef\"></canvas>\r\n  </view>\r\n</template>\r\n\r\n<script setup lang=\"ts\">\r\nimport { useMouse, useDevicePixelRatio } from \"@vueuse/core\";\r\nimport { ref, onMounted, onBeforeUnmount, watch, computed, reactive } from \"vue\";\r\n\r\ntype Circle = {\r\n  x: number;\r\n  y: number;\r\n  translateX: number;\r\n  translateY: number;\r\n  size: number;\r\n  alpha: number;\r\n  targetAlpha: number;\r\n  dx: number;\r\n  dy: number;\r\n  magnetism: number;\r\n};\r\n\r\ntype Props = {\r\n  color?: string;\r\n  quantity?: number;\r\n  staticity?: number;\r\n  ease?: number;\r\n  class?: string;\r\n};\r\n\r\nconst props = withDefaults(defineProps<Props>(), {\r\n  color: \"#FFF\",\r\n  quantity: 100,\r\n  staticity: 50,\r\n  ease: 50,\r\n  class: \"\",\r\n});\r\n\r\nconst canvasRef = ref<HTMLCanvasElement | null>(null);\r\nconst canvasContainerRef = ref<HTMLDivElement | null>(null);\r\nconst context = ref<CanvasRenderingContext2D | null>(null);\r\nconst circles = ref<Circle[]>([]);\r\nconst mouse = reactive<{ x: number; y: number }>({ x: 0, y: 0 });\r\nconst canvasSize = reactive<{ w: number; h: number }>({ w: 0, h: 0 });\r\nconst { x: mouseX, y: mouseY } = useMouse();\r\nconst { pixelRatio } = useDevicePixelRatio();\r\n\r\nconst color = computed(() => {\r\n  // Remove the leading '#' if it's present\r\n  let hex = props.color.replace(/^#/, \"\");\r\n\r\n  // If the hex code is 3 characters, expand it to 6 characters\r\n  if (hex.length === 3) {\r\n    hex = hex\r\n      .split(\"\")\r\n      .map((char) => char + char)\r\n      .join(\"\");\r\n  }\r\n\r\n  // Parse the r, g, b values from the hex string\r\n  const bigint = parseInt(hex, 16);\r\n  const r = (bigint >> 16) & 255; // Extract the red component\r\n  const g = (bigint >> 8) & 255; // Extract the green component\r\n  const b = bigint & 255; // Extract the blue component\r\n\r\n  // Return the RGB values as a string separated by spaces\r\n  return `${r} ${g} ${b}`;\r\n});\r\n\r\nonMounted(() => {\r\n  if (canvasRef.value) {\r\n    context.value = canvasRef.value.getContext(\"2d\");\r\n  }\r\n\r\n  initCanvas();\r\n  animate();\r\n  window.addEventListener(\"resize\", initCanvas);\r\n});\r\n\r\nonBeforeUnmount(() => {\r\n  window.removeEventListener(\"resize\", initCanvas);\r\n});\r\n\r\nwatch([mouseX, mouseY], () => {\r\n  onMouseMove();\r\n});\r\n\r\nfunction initCanvas() {\r\n  resizeCanvas();\r\n  drawParticles();\r\n}\r\n\r\nfunction onMouseMove() {\r\n  if (canvasRef.value) {\r\n    const rect = canvasRef.value.getBoundingClientRect();\r\n    const { w, h } = canvasSize;\r\n    const x = mouseX.value - rect.left - w / 2;\r\n    const y = mouseY.value - rect.top - h / 2;\r\n\r\n    const inside = x < w / 2 && x > -w / 2 && y < h / 2 && y > -h / 2;\r\n    if (inside) {\r\n      mouse.x = x;\r\n      mouse.y = y;\r\n    }\r\n  }\r\n}\r\n\r\nfunction resizeCanvas() {\r\n  if (canvasContainerRef.value && canvasRef.value && context.value) {\r\n    circles.value.length = 0;\r\n    canvasSize.w = canvasContainerRef.value.offsetWidth;\r\n    canvasSize.h = canvasContainerRef.value.offsetHeight;\r\n    canvasRef.value.width = canvasSize.w * pixelRatio.value;\r\n    canvasRef.value.height = canvasSize.h * pixelRatio.value;\r\n    canvasRef.value.style.width = canvasSize.w + \"px\";\r\n    canvasRef.value.style.height = canvasSize.h + \"px\";\r\n    context.value.scale(pixelRatio.value, pixelRatio.value);\r\n  }\r\n}\r\n\r\nfunction circleParams(): Circle {\r\n  const x = Math.floor(Math.random() * canvasSize.w);\r\n  const y = Math.floor(Math.random() * canvasSize.h);\r\n  const translateX = 0;\r\n  const translateY = 0;\r\n  const size = Math.floor(Math.random() * 2) + 1;\r\n  const alpha = 0;\r\n  const targetAlpha = parseFloat((Math.random() * 0.6 + 0.1).toFixed(1));\r\n  const dx = (Math.random() - 0.5) * 0.2;\r\n  const dy = (Math.random() - 0.5) * 0.2;\r\n  const magnetism = 0.1 + Math.random() * 4;\r\n  return {\r\n    x,\r\n    y,\r\n    translateX,\r\n    translateY,\r\n    size,\r\n    alpha,\r\n    targetAlpha,\r\n    dx,\r\n    dy,\r\n    magnetism,\r\n  };\r\n}\r\n\r\nfunction drawCircle(circle: Circle, update = false) {\r\n  if (context.value) {\r\n    const { x, y, translateX, translateY, size, alpha } = circle;\r\n    context.value.translate(translateX, translateY);\r\n    context.value.beginPath();\r\n    context.value.arc(x, y, size, 0, 2 * Math.PI);\r\n    context.value.fillStyle = `rgba(${color.value.split(\" \").join(\", \")}, ${alpha})`;\r\n    context.value.fill();\r\n    context.value.setTransform(pixelRatio.value, 0, 0, pixelRatio.value, 0, 0);\r\n\r\n    if (!update) {\r\n      circles.value.push(circle);\r\n    }\r\n  }\r\n}\r\n\r\nfunction clearContext() {\r\n  if (context.value) {\r\n    context.value.clearRect(0, 0, canvasSize.w, canvasSize.h);\r\n  }\r\n}\r\n\r\nfunction drawParticles() {\r\n  clearContext();\r\n  const particleCount = props.quantity;\r\n  for (let i = 0; i < particleCount; i++) {\r\n    const circle = circleParams();\r\n    drawCircle(circle);\r\n  }\r\n}\r\n\r\nfunction remapValue(\r\n  value: number,\r\n  start1: number,\r\n  end1: number,\r\n  start2: number,\r\n  end2: number,\r\n): number {\r\n  const remapped = ((value - start1) * (end2 - start2)) / (end1 - start1) + start2;\r\n  return remapped > 0 ? remapped : 0;\r\n}\r\n\r\nfunction animate() {\r\n  clearContext();\r\n  circles.value.forEach((circle, i) => {\r\n    // Handle the alpha value\r\n    const edge = [\r\n      circle.x + circle.translateX - circle.size, // distance from left edge\r\n      canvasSize.w - circle.x - circle.translateX - circle.size, // distance from right edge\r\n      circle.y + circle.translateY - circle.size, // distance from top edge\r\n      canvasSize.h - circle.y - circle.translateY - circle.size, // distance from bottom edge\r\n    ];\r\n\r\n    const closestEdge = edge.reduce((a, b) => Math.min(a, b));\r\n    const remapClosestEdge = parseFloat(remapValue(closestEdge, 0, 20, 0, 1).toFixed(2));\r\n\r\n    if (remapClosestEdge > 1) {\r\n      circle.alpha += 0.02;\r\n      if (circle.alpha > circle.targetAlpha) circle.alpha = circle.targetAlpha;\r\n    } else {\r\n      circle.alpha = circle.targetAlpha * remapClosestEdge;\r\n    }\r\n\r\n    circle.x += circle.dx;\r\n    circle.y += circle.dy;\r\n    circle.translateX +=\r\n      (mouse.x / (props.staticity / circle.magnetism) - circle.translateX) / props.ease;\r\n    circle.translateY +=\r\n      (mouse.y / (props.staticity / circle.magnetism) - circle.translateY) / props.ease;\r\n\r\n    // circle gets out of the canvas\r\n    if (\r\n      circle.x < -circle.size ||\r\n      circle.x > canvasSize.w + circle.size ||\r\n      circle.y < -circle.size ||\r\n      circle.y > canvasSize.h + circle.size\r\n    ) {\r\n      // remove the circle from the array\r\n      circles.value.splice(i, 1);\r\n      // create a new circle\r\n      const newCircle = circleParams();\r\n      drawCircle(newCircle);\r\n      // update the circle position\r\n    } else {\r\n      drawCircle(\r\n        {\r\n          ...circle,\r\n          x: circle.x,\r\n          y: circle.y,\r\n          translateX: circle.translateX,\r\n          translateY: circle.translateY,\r\n          alpha: circle.alpha,\r\n        },\r\n        true,\r\n      );\r\n    }\r\n  });\r\n  window.requestAnimationFrame(animate);\r\n}\r\n</script>\r\n",
      "target": "uniapp"
    }
  ],
  "fileCount": 3,
  "contentHash": "00b0104d20821a522b67c9b985acc645ed71374e"
}
