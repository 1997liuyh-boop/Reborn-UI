{
  "name": "animated-beam",
  "dependencies": [],
  "files": [
    {
      "path": "AnimatedBeam.vue",
      "content": "<template>\r\n  <svg\r\n    fill=\"none\"\r\n    :width=\"svgDimensions.width\"\r\n    :height=\"svgDimensions.height\"\r\n    xmlns=\"http://www.w3.org/2000/svg\"\r\n    :class=\"cn('pointer-events-none absolute left-0 top-0 transform-gpu stroke-2', $props.class)\"\r\n    :viewBox=\"`0 0 ${svgDimensions.width} ${svgDimensions.height}`\"\r\n  >\r\n    <path\r\n      :d=\"pathD\"\r\n      :stroke=\"pathColor\"\r\n      :stroke-width=\"pathWidth\"\r\n      :stroke-opacity=\"pathOpacity\"\r\n      stroke-linecap=\"round\"\r\n    />\r\n    <path\r\n      :d=\"pathD\"\r\n      :stroke-width=\"pathWidth\"\r\n      :stroke=\"`url(#${id})`\"\r\n      stroke-opacity=\"1\"\r\n      stroke-linecap=\"round\"\r\n    />\r\n    <defs>\r\n      <linearGradient\r\n        :id=\"id\"\r\n        gradientUnits=\"userSpaceOnUse\"\r\n        x1=\"0%\"\r\n        x2=\"0%\"\r\n        y1=\"0%\"\r\n        y2=\"0%\"\r\n      >\r\n        <stop\r\n          :stop-color=\"gradientStartColor\"\r\n          stop-opacity=\"0\"\r\n        />\r\n        <stop :stop-color=\"gradientStartColor\" />\r\n        <stop\r\n          offset=\"32.5%\"\r\n          :stop-color=\"gradientStopColor\"\r\n        />\r\n        <stop\r\n          offset=\"100%\"\r\n          :stop-color=\"gradientStopColor\"\r\n          stop-opacity=\"0\"\r\n        />\r\n        <animate\r\n          v-if=\"!isVertical\"\r\n          attributeName=\"x1\"\r\n          :values=\"x1\"\r\n          :dur=\"`${duration}s`\"\r\n          keyTimes=\"0; 1\"\r\n          keySplines=\"0.16 1 0.3 1\"\r\n          calcMode=\"spline\"\r\n          repeatCount=\"indefinite\"\r\n        />\r\n        <animate\r\n          v-if=\"!isVertical\"\r\n          attributeName=\"x2\"\r\n          :values=\"x2\"\r\n          :dur=\"`${duration}s`\"\r\n          keyTimes=\"0; 1\"\r\n          keySplines=\"0.16 1 0.3 1\"\r\n          calcMode=\"spline\"\r\n          repeatCount=\"indefinite\"\r\n        />\r\n        <animate\r\n          v-if=\"isVertical\"\r\n          attributeName=\"y1\"\r\n          :values=\"y1\"\r\n          :dur=\"`${duration}s`\"\r\n          keyTimes=\"0; 1\"\r\n          keySplines=\"0.16 1 0.3 1\"\r\n          calcMode=\"spline\"\r\n          repeatCount=\"indefinite\"\r\n        />\r\n        <animate\r\n          v-if=\"isVertical\"\r\n          attributeName=\"y2\"\r\n          :values=\"y2\"\r\n          :dur=\"`${duration}s`\"\r\n          keyTimes=\"0; 1\"\r\n          keySplines=\"0.16 1 0.3 1\"\r\n          calcMode=\"spline\"\r\n          repeatCount=\"indefinite\"\r\n        />\r\n      </linearGradient>\r\n    </defs>\r\n  </svg>\r\n</template>\r\n\r\n<script lang=\"ts\" setup>\r\nimport { onBeforeUnmount, ref, watchEffect } from \"vue\";\r\nimport { cn } from \"@/lib/utils\";\r\n\r\ntype AnimatedBeamProps = {\r\n  class?: string;\r\n  containerRef: HTMLElement;\r\n  fromRef: HTMLElement;\r\n  toRef: HTMLElement;\r\n  curvature?: number;\r\n  reverse?: boolean;\r\n  pathColor?: string;\r\n  pathWidth?: number;\r\n  pathOpacity?: number;\r\n  gradientStartColor?: string;\r\n  gradientStopColor?: string;\r\n  delay?: number;\r\n  duration?: number;\r\n  startXOffset?: number;\r\n  startYOffset?: number;\r\n  endXOffset?: number;\r\n  endYOffset?: number;\r\n};\r\n\r\nconst props = withDefaults(defineProps<AnimatedBeamProps>(), {\r\n  curvature: 0,\r\n  reverse: false,\r\n  duration: Math.random() * 3 + 4,\r\n  delay: 0,\r\n  pathColor: \"gray\",\r\n  pathWidth: 2,\r\n  pathOpacity: 0.2,\r\n  gradientStartColor: \"#FFAA40\",\r\n  gradientStopColor: \"#9C40FF\",\r\n  startXOffset: 0,\r\n  startYOffset: 0,\r\n  endXOffset: 0,\r\n  endYOffset: 0,\r\n});\r\n\r\nconst id = \"beam-\" + Math.random().toString(36).substring(2, 10);\r\nconst isVertical = ref(false);\r\nconst isRightToLeft = ref(false);\r\nconst isBottomToTop = ref(false);\r\nconst x1 = computed(() => {\r\n  const direction = props.reverse ? !isRightToLeft.value : isRightToLeft.value;\r\n  return direction ? \"90%; -10%;\" : \"10%; 110%;\";\r\n});\r\nconst x2 = computed(() => {\r\n  const direction = props.reverse ? !isRightToLeft.value : isRightToLeft.value;\r\n  return direction ? \"100%; 0%;\" : \"0%; 100%;\";\r\n});\r\nconst y1 = computed(() => {\r\n  const direction = props.reverse ? !isBottomToTop.value : isBottomToTop.value;\r\n  return direction ? \"90%; -10%;\" : \"10%; 110%;\";\r\n});\r\nconst y2 = computed(() => {\r\n  const direction = props.reverse ? !isBottomToTop.value : isBottomToTop.value;\r\n  return direction ? \"100%; 0%;\" : \"0%; 100%;\";\r\n});\r\n\r\nconst pathD = ref(\"\");\r\nconst svgDimensions = ref<{ width: number; height: number }>({\r\n  width: 0,\r\n  height: 0,\r\n});\r\n\r\nlet resizeObserver: ResizeObserver | undefined = undefined;\r\n\r\nconst { stop: stopEffect } = watchEffect(effect);\r\n\r\nfunction effect() {\r\n  if (resizeObserver == undefined && props.containerRef != null) {\r\n    resizeObserver = new ResizeObserver(() => {\r\n      updatePath();\r\n    });\r\n    resizeObserver.observe(props.containerRef);\r\n\r\n    stopEffect();\r\n  }\r\n}\r\n\r\n// Function to update the path based on the positions of the elements\r\nfunction updatePath() {\r\n  if (props.containerRef && props.fromRef && props.toRef) {\r\n    const containerRect = props.containerRef.getBoundingClientRect();\r\n    const rectA = props.fromRef.getBoundingClientRect();\r\n    const rectB = props.toRef.getBoundingClientRect();\r\n\r\n    const svgWidth = containerRect.width;\r\n    const svgHeight = containerRect.height;\r\n    svgDimensions.value = { width: svgWidth, height: svgHeight };\r\n\r\n    const startX = rectA.left - containerRect.left + rectA.width / 2 + (props.startXOffset ?? 0);\r\n    const startY = rectA.top - containerRect.top + rectA.height / 2 + (props.startYOffset ?? 0);\r\n    const endX = rectB.left - containerRect.left + rectB.width / 2 + (props.endXOffset ?? 0);\r\n    const endY = rectB.top - containerRect.top + rectB.height / 2 + (props.endYOffset ?? 0);\r\n\r\n    // Check if the light beam is in a vertical direction (the distance in the y-direction is greater than the distance in the x-direction).\r\n    isVertical.value = Math.abs(endY - startY) > Math.abs(endX - startX);\r\n\r\n    // Determine the animation direction based on the position relationship between the starting point and the endpoint\r\n    isRightToLeft.value = endX < startX;\r\n    isBottomToTop.value = endY < startY;\r\n\r\n    const controlY = startY - (props.curvature ?? 0);\r\n    const d = `M ${startX},${startY} Q ${(startX + endX) / 2},${controlY} ${endX},${endY}`;\r\n    pathD.value = d;\r\n  }\r\n}\r\n\r\nonBeforeUnmount(() => {\r\n  resizeObserver?.disconnect();\r\n});\r\n</script>\r\n",
      "target": "web"
    },
    {
      "path": "AnimatedBeam.vue",
      "content": "<template>\r\n  <svg\r\n    fill=\"none\"\r\n    :width=\"svgDimensions.width\"\r\n    :height=\"svgDimensions.height\"\r\n    xmlns=\"http://www.w3.org/2000/svg\"\r\n    :class=\"cn('pointer-events-none absolute left-0 top-0 transform-gpu stroke-2', $props.class)\"\r\n    :viewBox=\"`0 0 ${svgDimensions.width} ${svgDimensions.height}`\"\r\n  >\r\n    <path\r\n      :d=\"pathD\"\r\n      :stroke=\"pathColor\"\r\n      :stroke-width=\"pathWidth\"\r\n      :stroke-opacity=\"pathOpacity\"\r\n      stroke-linecap=\"round\"\r\n    />\r\n    <path\r\n      :d=\"pathD\"\r\n      :stroke-width=\"pathWidth\"\r\n      :stroke=\"`url(#${id})`\"\r\n      stroke-opacity=\"1\"\r\n      stroke-linecap=\"round\"\r\n    />\r\n    <defs>\r\n      <linearGradient\r\n        :id=\"id\"\r\n        gradientUnits=\"userSpaceOnUse\"\r\n        x1=\"0%\"\r\n        x2=\"0%\"\r\n        y1=\"0%\"\r\n        y2=\"0%\"\r\n      >\r\n        <stop\r\n          :stop-color=\"gradientStartColor\"\r\n          stop-opacity=\"0\"\r\n        />\r\n        <stop :stop-color=\"gradientStartColor\" />\r\n        <stop\r\n          offset=\"32.5%\"\r\n          :stop-color=\"gradientStopColor\"\r\n        />\r\n        <stop\r\n          offset=\"100%\"\r\n          :stop-color=\"gradientStopColor\"\r\n          stop-opacity=\"0\"\r\n        />\r\n        <animate\r\n          v-if=\"!isVertical\"\r\n          attributeName=\"x1\"\r\n          :values=\"x1\"\r\n          :dur=\"`${duration}s`\"\r\n          keyTimes=\"0; 1\"\r\n          keySplines=\"0.16 1 0.3 1\"\r\n          calcMode=\"spline\"\r\n          repeatCount=\"indefinite\"\r\n        />\r\n        <animate\r\n          v-if=\"!isVertical\"\r\n          attributeName=\"x2\"\r\n          :values=\"x2\"\r\n          :dur=\"`${duration}s`\"\r\n          keyTimes=\"0; 1\"\r\n          keySplines=\"0.16 1 0.3 1\"\r\n          calcMode=\"spline\"\r\n          repeatCount=\"indefinite\"\r\n        />\r\n        <animate\r\n          v-if=\"isVertical\"\r\n          attributeName=\"y1\"\r\n          :values=\"y1\"\r\n          :dur=\"`${duration}s`\"\r\n          keyTimes=\"0; 1\"\r\n          keySplines=\"0.16 1 0.3 1\"\r\n          calcMode=\"spline\"\r\n          repeatCount=\"indefinite\"\r\n        />\r\n        <animate\r\n          v-if=\"isVertical\"\r\n          attributeName=\"y2\"\r\n          :values=\"y2\"\r\n          :dur=\"`${duration}s`\"\r\n          keyTimes=\"0; 1\"\r\n          keySplines=\"0.16 1 0.3 1\"\r\n          calcMode=\"spline\"\r\n          repeatCount=\"indefinite\"\r\n        />\r\n      </linearGradient>\r\n    </defs>\r\n  </svg>\r\n</template>\r\n\r\n<script lang=\"ts\" setup>\r\nimport { onBeforeUnmount, ref, watchEffect } from \"vue\";\r\nimport { cn } from \"@/lib/utils\";\r\n\r\ntype AnimatedBeamProps = {\r\n  class?: string;\r\n  containerRef: HTMLElement;\r\n  fromRef: HTMLElement;\r\n  toRef: HTMLElement;\r\n  curvature?: number;\r\n  reverse?: boolean;\r\n  pathColor?: string;\r\n  pathWidth?: number;\r\n  pathOpacity?: number;\r\n  gradientStartColor?: string;\r\n  gradientStopColor?: string;\r\n  delay?: number;\r\n  duration?: number;\r\n  startXOffset?: number;\r\n  startYOffset?: number;\r\n  endXOffset?: number;\r\n  endYOffset?: number;\r\n};\r\n\r\nconst props = withDefaults(defineProps<AnimatedBeamProps>(), {\r\n  curvature: 0,\r\n  reverse: false,\r\n  duration: Math.random() * 3 + 4,\r\n  delay: 0,\r\n  pathColor: \"gray\",\r\n  pathWidth: 2,\r\n  pathOpacity: 0.2,\r\n  gradientStartColor: \"#FFAA40\",\r\n  gradientStopColor: \"#9C40FF\",\r\n  startXOffset: 0,\r\n  startYOffset: 0,\r\n  endXOffset: 0,\r\n  endYOffset: 0,\r\n});\r\n\r\nconst id = \"beam-\" + Math.random().toString(36).substring(2, 10);\r\nconst isVertical = ref(false);\r\nconst isRightToLeft = ref(false);\r\nconst isBottomToTop = ref(false);\r\nconst x1 = computed(() => {\r\n  const direction = props.reverse ? !isRightToLeft.value : isRightToLeft.value;\r\n  return direction ? \"90%; -10%;\" : \"10%; 110%;\";\r\n});\r\nconst x2 = computed(() => {\r\n  const direction = props.reverse ? !isRightToLeft.value : isRightToLeft.value;\r\n  return direction ? \"100%; 0%;\" : \"0%; 100%;\";\r\n});\r\nconst y1 = computed(() => {\r\n  const direction = props.reverse ? !isBottomToTop.value : isBottomToTop.value;\r\n  return direction ? \"90%; -10%;\" : \"10%; 110%;\";\r\n});\r\nconst y2 = computed(() => {\r\n  const direction = props.reverse ? !isBottomToTop.value : isBottomToTop.value;\r\n  return direction ? \"100%; 0%;\" : \"0%; 100%;\";\r\n});\r\n\r\nconst pathD = ref(\"\");\r\nconst svgDimensions = ref<{ width: number; height: number }>({\r\n  width: 0,\r\n  height: 0,\r\n});\r\n\r\nlet resizeObserver: ResizeObserver | undefined = undefined;\r\n\r\nconst { stop: stopEffect } = watchEffect(effect);\r\n\r\nfunction effect() {\r\n  if (resizeObserver == undefined && props.containerRef != null) {\r\n    resizeObserver = new ResizeObserver(() => {\r\n      updatePath();\r\n    });\r\n    resizeObserver.observe(props.containerRef);\r\n\r\n    stopEffect();\r\n  }\r\n}\r\n\r\n// Function to update the path based on the positions of the elements\r\nfunction updatePath() {\r\n  if (props.containerRef && props.fromRef && props.toRef) {\r\n    const containerRect = props.containerRef.getBoundingClientRect();\r\n    const rectA = props.fromRef.getBoundingClientRect();\r\n    const rectB = props.toRef.getBoundingClientRect();\r\n\r\n    const svgWidth = containerRect.width;\r\n    const svgHeight = containerRect.height;\r\n    svgDimensions.value = { width: svgWidth, height: svgHeight };\r\n\r\n    const startX = rectA.left - containerRect.left + rectA.width / 2 + (props.startXOffset ?? 0);\r\n    const startY = rectA.top - containerRect.top + rectA.height / 2 + (props.startYOffset ?? 0);\r\n    const endX = rectB.left - containerRect.left + rectB.width / 2 + (props.endXOffset ?? 0);\r\n    const endY = rectB.top - containerRect.top + rectB.height / 2 + (props.endYOffset ?? 0);\r\n\r\n    // Check if the light beam is in a vertical direction (the distance in the y-direction is greater than the distance in the x-direction).\r\n    isVertical.value = Math.abs(endY - startY) > Math.abs(endX - startX);\r\n\r\n    // Determine the animation direction based on the position relationship between the starting point and the endpoint\r\n    isRightToLeft.value = endX < startX;\r\n    isBottomToTop.value = endY < startY;\r\n\r\n    const controlY = startY - (props.curvature ?? 0);\r\n    const d = `M ${startX},${startY} Q ${(startX + endX) / 2},${controlY} ${endX},${endY}`;\r\n    pathD.value = d;\r\n  }\r\n}\r\n\r\nonBeforeUnmount(() => {\r\n  resizeObserver?.disconnect();\r\n});\r\n</script>\r\n",
      "target": "uniapp"
    },
    {
      "path": "index.ts",
      "content": "export { default as AnimatedBeam } from \"./AnimatedBeam.vue\";\r\n"
    }
  ],
  "fileCount": 3,
  "contentHash": "50905303813ecc2f899420760ad5e3d32f82845b"
}
