{
  "name": "bg-bubbles",
  "dependencies": [
    "three"
  ],
  "files": [
    {
      "path": "BubblesBg.vue",
      "content": "<template>\r\n  <div\r\n    ref=\"bubbleParentContainer\"\r\n    class=\"relative h-72 w-full overflow-hidden\"\r\n  >\r\n    <div ref=\"bubbleCanvasContainer\"></div>\r\n    <div\r\n      :style=\"{\r\n        '--bubbles-blur': `${blur}px`,\r\n      }\"\r\n      class=\"absolute inset-0 z-[2] size-full backdrop-blur-[--bubbles-blur]\"\r\n    >\r\n      <slot />\r\n    </div>\r\n  </div>\r\n</template>\r\n\r\n<script setup lang=\"ts\">\r\nimport {\r\n  ShaderMaterial,\r\n  SphereGeometry,\r\n  Vector3,\r\n  Color,\r\n  MathUtils,\r\n  Mesh,\r\n  Clock,\r\n  WebGLRenderer,\r\n  Scene,\r\n  PerspectiveCamera,\r\n} from \"three\";\r\nimport { ref, onMounted, onBeforeUnmount } from \"vue\";\r\n\r\ndefineProps({\r\n  blur: {\r\n    type: Number,\r\n    default: 0,\r\n  },\r\n});\r\n\r\nconst bubbleParentContainer = ref<HTMLElement | null>(null);\r\nconst bubbleCanvasContainer = ref<HTMLElement | null>(null);\r\nlet renderer: WebGLRenderer;\r\nlet scene: Scene;\r\nlet camera: PerspectiveCamera;\r\nlet clock: Clock;\r\nconst spheres: Mesh[] = [];\r\n\r\nconst BG_COLOR_BOTTOM_BLUISH = rgb(170, 215, 217);\r\nconst BG_COLOR_TOP_BLUISH = rgb(57, 167, 255);\r\nconst BG_COLOR_BOTTOM_ORANGISH = rgb(255, 160, 75);\r\nconst BG_COLOR_TOP_ORANGISH = rgb(239, 172, 53);\r\n\r\nconst SPHERE_COLOR_BOTTOM_BLUISH = rgb(120, 235, 124);\r\nconst SPHERE_COLOR_TOP_BLUISH = rgb(0, 167, 255);\r\nconst SPHERE_COLOR_BOTTOM_ORANGISH = rgb(235, 170, 0);\r\nconst SPHERE_COLOR_TOP_ORANGISH = rgb(255, 120, 0);\r\n\r\nconst SPHERE_COUNT = 250;\r\nconst SPHERE_SCALE_COEFF = 3;\r\nconst ORBIT_MIN = SPHERE_SCALE_COEFF + 2;\r\nconst ORBIT_MAX = ORBIT_MIN + 10;\r\nconst RAND_SEED = 898211544;\r\n\r\nconst rand = seededRandom(RAND_SEED);\r\n\r\nconst { PI, cos, sin } = Math;\r\nconst PI2 = PI * 2;\r\nconst sizes = new Array(SPHERE_COUNT).fill(0).map(() => randRange(1) * Math.pow(randRange(), 3));\r\nconst orbitRadii = new Array(SPHERE_COUNT)\r\n  .fill(0)\r\n  .map(() => MathUtils.lerp(ORBIT_MIN, ORBIT_MAX, randRange()));\r\nconst thetas = new Array(SPHERE_COUNT).fill(0).map(() => randRange(PI2));\r\nconst phis = new Array(SPHERE_COUNT).fill(0).map(() => randRange(PI2));\r\nconst positions: [number, number, number][] = orbitRadii.map((rad, i) => [\r\n  rad * cos(thetas[i]) * sin(phis[i]),\r\n  rad * sin(thetas[i]) * sin(phis[i]),\r\n  rad * cos(phis[i]),\r\n]);\r\n\r\nconst sphereGeometry = new SphereGeometry(SPHERE_SCALE_COEFF);\r\nconst sphereMaterial = getGradientMaterial(\r\n  SPHERE_COLOR_BOTTOM_BLUISH,\r\n  SPHERE_COLOR_TOP_BLUISH,\r\n  SPHERE_COLOR_BOTTOM_ORANGISH,\r\n  SPHERE_COLOR_TOP_ORANGISH,\r\n);\r\n\r\nconst bgGeometry = new SphereGeometry();\r\nbgGeometry.scale(-1, 1, 1);\r\nconst bgMaterial = getGradientMaterial(\r\n  BG_COLOR_BOTTOM_BLUISH,\r\n  BG_COLOR_TOP_BLUISH,\r\n  BG_COLOR_BOTTOM_ORANGISH,\r\n  BG_COLOR_TOP_ORANGISH,\r\n);\r\nbgMaterial.uniforms.uTemperatureVariancePeriod.value = new Vector3(0, 0, 0.1);\r\n\r\nfunction seededRandom(a: number) {\r\n  return function () {\r\n    a |= 0;\r\n    a = (a + 0x9e3779b9) | 0;\r\n    var t = a ^ (a >>> 16);\r\n    t = Math.imul(t, 0x21f0aaad);\r\n    t = t ^ (t >>> 15);\r\n    t = Math.imul(t, 0x735a2d97);\r\n    return ((t = t ^ (t >>> 15)) >>> 0) / 4294967296;\r\n  };\r\n}\r\n\r\nfunction randRange(n = 1) {\r\n  return rand() * n;\r\n}\r\n\r\nfunction rgb(r: number, g: number, b: number) {\r\n  return new Color(r / 255, g / 255, b / 255);\r\n}\r\n\r\nfunction getGradientMaterial(\r\n  colorBottomWarm: Color,\r\n  colorTopWarm: Color,\r\n  colorBottomCool: Color,\r\n  colorTopCool: Color,\r\n) {\r\n  return new ShaderMaterial({\r\n    uniforms: {\r\n      colorBottomWarm: {\r\n        value: new Color().copy(colorBottomWarm),\r\n      },\r\n      colorTopWarm: {\r\n        value: new Color().copy(colorTopWarm),\r\n      },\r\n      colorBottomCool: {\r\n        value: new Color().copy(colorBottomCool),\r\n      },\r\n      colorTopCool: {\r\n        value: new Color().copy(colorTopCool),\r\n      },\r\n      uTemperature: {\r\n        value: 0.0,\r\n      },\r\n      uTemperatureVariancePeriod: {\r\n        value: new Vector3(0.08, 0.1, 0.2),\r\n      },\r\n      uElapsedTime: {\r\n        value: 0,\r\n      },\r\n    },\r\n    vertexShader: `\r\n      uniform vec4 uTemperatureVariancePeriod;\r\n      uniform float uTemperature;\r\n      uniform float uElapsedTime;\r\n      varying float topBottomMix;\r\n      varying float warmCoolMix;\r\n\r\n      void main() {\r\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);\r\n        topBottomMix = normal.y;\r\n        warmCoolMix = 0.6 * uTemperature +\r\n          0.4 * (sin(\r\n          (uElapsedTime + gl_Position.x) * uTemperatureVariancePeriod.x +\r\n          (uElapsedTime + gl_Position.y) * uTemperatureVariancePeriod.y +\r\n          (uElapsedTime + gl_Position.z) * uTemperatureVariancePeriod.z) * 0.5 + 0.5);\r\n      }\r\n    `,\r\n    fragmentShader: `\r\n      uniform vec3 colorBottomWarm;\r\n      uniform vec3 colorTopWarm;\r\n      uniform vec3 colorBottomCool;\r\n      uniform vec3 colorTopCool;\r\n\r\n      varying float topBottomMix;\r\n      varying float warmCoolMix;\r\n\r\n      void main() {\r\n        gl_FragColor = vec4(mix(\r\n          mix(colorTopCool, colorTopWarm, warmCoolMix),\r\n          mix(colorBottomCool, colorBottomWarm, warmCoolMix),\r\n          topBottomMix), 1.0);\r\n      }\r\n    `,\r\n  });\r\n}\r\n\r\nfunction createScene() {\r\n  const width = bubbleCanvasContainer.value?.clientWidth || 1;\r\n  const height = bubbleCanvasContainer.value?.clientHeight || 1;\r\n  // Set up the scene, camera, and renderer\r\n  scene = new Scene();\r\n  camera = new PerspectiveCamera(50, width / height, 1, 2000);\r\n  camera.position.x = 0;\r\n  camera.position.y = 0;\r\n  camera.position.z = 23;\r\n\r\n  renderer = new WebGLRenderer({ antialias: true });\r\n  renderer.setSize(width, height);\r\n  renderer.setClearColor(BG_COLOR_BOTTOM_BLUISH);\r\n\r\n  // Add these properties to allow overlap\r\n  sphereMaterial.depthWrite = false;\r\n  sphereMaterial.depthTest = true; // Keep this true for depth sorting\r\n\r\n  if (bubbleCanvasContainer.value) {\r\n    bubbleCanvasContainer.value.appendChild(renderer.domElement);\r\n  }\r\n\r\n  // Create the background mesh\r\n  const bgMesh = new Mesh(bgGeometry, bgMaterial);\r\n  // Position the background far behind everything\r\n  bgMesh.position.set(0, 0, -1); // Move the background far back\r\n\r\n  // Disable depth testing for the background to ensure it's always behind other objects\r\n  bgMesh.material.depthTest = false;\r\n  bgMesh.renderOrder = -1; // Ensure the background is rendered first\r\n\r\n  // Calculate the scale to ensure the background covers the full canvas\r\n  const distance = camera.position.z; // Distance from the camera\r\n  const aspect = camera.aspect;\r\n  const frustumHeight = 2 * distance * Math.tan(MathUtils.degToRad(camera.fov) / 2);\r\n  const frustumWidth = frustumHeight * aspect;\r\n\r\n  // Scale the background geometry to match the camera's frustum size\r\n  bgMesh.scale.set(\r\n    frustumWidth / bgGeometry.parameters.radius,\r\n    frustumHeight / bgGeometry.parameters.radius,\r\n    1,\r\n  );\r\n\r\n  scene.add(bgMesh); // Add the backgrou\r\n\r\n  // Create sphere meshes\r\n  const orbitRadii = new Array(SPHERE_COUNT)\r\n    .fill(0)\r\n    .map(() => MathUtils.lerp(ORBIT_MIN, ORBIT_MAX, randRange()));\r\n  const thetas = new Array(SPHERE_COUNT).fill(0).map(() => randRange(PI2));\r\n  const phis = new Array(SPHERE_COUNT).fill(0).map(() => randRange(PI2));\r\n  const positions = orbitRadii.map((rad, i) => [\r\n    rad * cos(thetas[i]) * sin(phis[i]),\r\n    rad * sin(thetas[i]) * sin(phis[i]),\r\n    rad * cos(phis[i]),\r\n  ]);\r\n\r\n  for (let i = 0; i < SPHERE_COUNT; i++) {\r\n    const sphere = new Mesh(sphereGeometry, sphereMaterial);\r\n    const [x, y, z] = positions[i];\r\n    const scaleVector = sizes[i];\r\n    sphere.scale.set(scaleVector, scaleVector, scaleVector);\r\n    sphere.position.set(x, y, z);\r\n    spheres.push(sphere);\r\n    scene.add(sphere);\r\n  }\r\n\r\n  clock = new Clock();\r\n}\r\n\r\nfunction animate() {\r\n  requestAnimationFrame(animate);\r\n\r\n  const elapsed = clock.getElapsedTime();\r\n  const temperature = sin(elapsed * 0.5) * 0.5 + 0.5;\r\n\r\n  bgMaterial.uniforms.uTemperature.value = temperature;\r\n  bgMaterial.uniforms.uElapsedTime.value = elapsed;\r\n\r\n  sphereMaterial.uniforms.uTemperature.value = temperature;\r\n  sphereMaterial.uniforms.uElapsedTime.value = elapsed;\r\n\r\n  // Floating effect for spheres\r\n  spheres.forEach((sphere, index) => {\r\n    const basePosition = positions[index];\r\n    const floatFactor = 2; // Adjust this value to control float intensity\r\n    const speed = 0.3; // Adjust this value to control float speed\r\n    const floatY = sin(elapsed * speed + index) * floatFactor;\r\n    sphere.position.y = basePosition[1] + floatY;\r\n  });\r\n\r\n  renderer.render(scene, camera);\r\n}\r\n\r\nfunction updateRendererSize() {\r\n  const width = bubbleParentContainer.value?.clientWidth || 1;\r\n  const height = bubbleParentContainer.value?.clientHeight || 1;\r\n\r\n  // Update renderer size and aspect ratio\r\n  renderer.setSize(width, height);\r\n  camera.aspect = width / height;\r\n  camera.updateProjectionMatrix();\r\n\r\n  // Recalculate background mesh scale\r\n  const distance = camera.position.z;\r\n  const frustumHeight = 2 * distance * Math.tan(MathUtils.degToRad(camera.fov) / 2);\r\n  const frustumWidth = frustumHeight * camera.aspect;\r\n\r\n  // Get the background mesh and update its scale\r\n  const bgMesh = scene.children.find(\r\n    (obj) => obj instanceof Mesh && obj.geometry === bgGeometry,\r\n  ) as Mesh;\r\n  if (bgMesh) {\r\n    bgMesh.scale.set(\r\n      frustumWidth / bgGeometry.parameters.radius,\r\n      frustumHeight / bgGeometry.parameters.radius,\r\n      1,\r\n    );\r\n  }\r\n}\r\n\r\nonMounted(() => {\r\n  createScene();\r\n  updateRendererSize();\r\n  window.addEventListener(\"resize\", updateRendererSize);\r\n  animate();\r\n});\r\n\r\nonBeforeUnmount(() => {\r\n  window.removeEventListener(\"resize\", updateRendererSize); // Cleanup on component unmount\r\n});\r\n</script>\r\n",
      "target": "web"
    },
    {
      "path": "BubblesBg.vue",
      "content": "<template>\r\n  <view\r\n    ref=\"bubbleParentContainer\"\r\n    class=\"relative h-72 w-full overflow-hidden\"\r\n  >\r\n    <view ref=\"bubbleCanvasContainer\"></view>\r\n    <view\r\n      :style=\"{\r\n        '--bubbles-blur': `${blur}px`,\r\n      }\"\r\n      class=\"absolute inset-0 z-[2] size-full backdrop-blur-[--bubbles-blur]\"\r\n    >\r\n      <slot />\r\n    </view>\r\n  </view>\r\n</template>\r\n\r\n<script setup lang=\"ts\">\r\nimport {\r\n  ShaderMaterial,\r\n  SphereGeometry,\r\n  Vector3,\r\n  Color,\r\n  MathUtils,\r\n  Mesh,\r\n  Clock,\r\n  WebGLRenderer,\r\n  Scene,\r\n  PerspectiveCamera,\r\n} from \"three\";\r\nimport { ref, onMounted, onBeforeUnmount } from \"vue\";\r\n\r\ndefineProps({\r\n  blur: {\r\n    type: Number,\r\n    default: 0,\r\n  },\r\n});\r\n\r\nconst bubbleParentContainer = ref<HTMLElement | null>(null);\r\nconst bubbleCanvasContainer = ref<HTMLElement | null>(null);\r\nlet renderer: WebGLRenderer;\r\nlet scene: Scene;\r\nlet camera: PerspectiveCamera;\r\nlet clock: Clock;\r\nconst spheres: Mesh[] = [];\r\n\r\nconst BG_COLOR_BOTTOM_BLUISH = rgb(170, 215, 217);\r\nconst BG_COLOR_TOP_BLUISH = rgb(57, 167, 255);\r\nconst BG_COLOR_BOTTOM_ORANGISH = rgb(255, 160, 75);\r\nconst BG_COLOR_TOP_ORANGISH = rgb(239, 172, 53);\r\n\r\nconst SPHERE_COLOR_BOTTOM_BLUISH = rgb(120, 235, 124);\r\nconst SPHERE_COLOR_TOP_BLUISH = rgb(0, 167, 255);\r\nconst SPHERE_COLOR_BOTTOM_ORANGISH = rgb(235, 170, 0);\r\nconst SPHERE_COLOR_TOP_ORANGISH = rgb(255, 120, 0);\r\n\r\nconst SPHERE_COUNT = 250;\r\nconst SPHERE_SCALE_COEFF = 3;\r\nconst ORBIT_MIN = SPHERE_SCALE_COEFF + 2;\r\nconst ORBIT_MAX = ORBIT_MIN + 10;\r\nconst RAND_SEED = 898211544;\r\n\r\nconst rand = seededRandom(RAND_SEED);\r\n\r\nconst { PI, cos, sin } = Math;\r\nconst PI2 = PI * 2;\r\nconst sizes = new Array(SPHERE_COUNT).fill(0).map(() => randRange(1) * Math.pow(randRange(), 3));\r\nconst orbitRadii = new Array(SPHERE_COUNT)\r\n  .fill(0)\r\n  .map(() => MathUtils.lerp(ORBIT_MIN, ORBIT_MAX, randRange()));\r\nconst thetas = new Array(SPHERE_COUNT).fill(0).map(() => randRange(PI2));\r\nconst phis = new Array(SPHERE_COUNT).fill(0).map(() => randRange(PI2));\r\nconst positions: [number, number, number][] = orbitRadii.map((rad, i) => [\r\n  rad * cos(thetas[i]) * sin(phis[i]),\r\n  rad * sin(thetas[i]) * sin(phis[i]),\r\n  rad * cos(phis[i]),\r\n]);\r\n\r\nconst sphereGeometry = new SphereGeometry(SPHERE_SCALE_COEFF);\r\nconst sphereMaterial = getGradientMaterial(\r\n  SPHERE_COLOR_BOTTOM_BLUISH,\r\n  SPHERE_COLOR_TOP_BLUISH,\r\n  SPHERE_COLOR_BOTTOM_ORANGISH,\r\n  SPHERE_COLOR_TOP_ORANGISH,\r\n);\r\n\r\nconst bgGeometry = new SphereGeometry();\r\nbgGeometry.scale(-1, 1, 1);\r\nconst bgMaterial = getGradientMaterial(\r\n  BG_COLOR_BOTTOM_BLUISH,\r\n  BG_COLOR_TOP_BLUISH,\r\n  BG_COLOR_BOTTOM_ORANGISH,\r\n  BG_COLOR_TOP_ORANGISH,\r\n);\r\nbgMaterial.uniforms.uTemperatureVariancePeriod.value = new Vector3(0, 0, 0.1);\r\n\r\nfunction seededRandom(a: number) {\r\n  return function () {\r\n    a |= 0;\r\n    a = (a + 0x9e3779b9) | 0;\r\n    var t = a ^ (a >>> 16);\r\n    t = Math.imul(t, 0x21f0aaad);\r\n    t = t ^ (t >>> 15);\r\n    t = Math.imul(t, 0x735a2d97);\r\n    return ((t = t ^ (t >>> 15)) >>> 0) / 4294967296;\r\n  };\r\n}\r\n\r\nfunction randRange(n = 1) {\r\n  return rand() * n;\r\n}\r\n\r\nfunction rgb(r: number, g: number, b: number) {\r\n  return new Color(r / 255, g / 255, b / 255);\r\n}\r\n\r\nfunction getGradientMaterial(\r\n  colorBottomWarm: Color,\r\n  colorTopWarm: Color,\r\n  colorBottomCool: Color,\r\n  colorTopCool: Color,\r\n) {\r\n  return new ShaderMaterial({\r\n    uniforms: {\r\n      colorBottomWarm: {\r\n        value: new Color().copy(colorBottomWarm),\r\n      },\r\n      colorTopWarm: {\r\n        value: new Color().copy(colorTopWarm),\r\n      },\r\n      colorBottomCool: {\r\n        value: new Color().copy(colorBottomCool),\r\n      },\r\n      colorTopCool: {\r\n        value: new Color().copy(colorTopCool),\r\n      },\r\n      uTemperature: {\r\n        value: 0.0,\r\n      },\r\n      uTemperatureVariancePeriod: {\r\n        value: new Vector3(0.08, 0.1, 0.2),\r\n      },\r\n      uElapsedTime: {\r\n        value: 0,\r\n      },\r\n    },\r\n    vertexShader: `\r\n      uniform vec4 uTemperatureVariancePeriod;\r\n      uniform float uTemperature;\r\n      uniform float uElapsedTime;\r\n      varying float topBottomMix;\r\n      varying float warmCoolMix;\r\n\r\n      void main() {\r\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);\r\n        topBottomMix = normal.y;\r\n        warmCoolMix = 0.6 * uTemperature +\r\n          0.4 * (sin(\r\n          (uElapsedTime + gl_Position.x) * uTemperatureVariancePeriod.x +\r\n          (uElapsedTime + gl_Position.y) * uTemperatureVariancePeriod.y +\r\n          (uElapsedTime + gl_Position.z) * uTemperatureVariancePeriod.z) * 0.5 + 0.5);\r\n      }\r\n    `,\r\n    fragmentShader: `\r\n      uniform vec3 colorBottomWarm;\r\n      uniform vec3 colorTopWarm;\r\n      uniform vec3 colorBottomCool;\r\n      uniform vec3 colorTopCool;\r\n\r\n      varying float topBottomMix;\r\n      varying float warmCoolMix;\r\n\r\n      void main() {\r\n        gl_FragColor = vec4(mix(\r\n          mix(colorTopCool, colorTopWarm, warmCoolMix),\r\n          mix(colorBottomCool, colorBottomWarm, warmCoolMix),\r\n          topBottomMix), 1.0);\r\n      }\r\n    `,\r\n  });\r\n}\r\n\r\nfunction createScene() {\r\n  const width = bubbleCanvasContainer.value?.clientWidth || 1;\r\n  const height = bubbleCanvasContainer.value?.clientHeight || 1;\r\n  // Set up the scene, camera, and renderer\r\n  scene = new Scene();\r\n  camera = new PerspectiveCamera(50, width / height, 1, 2000);\r\n  camera.position.x = 0;\r\n  camera.position.y = 0;\r\n  camera.position.z = 23;\r\n\r\n  renderer = new WebGLRenderer({ antialias: true });\r\n  renderer.setSize(width, height);\r\n  renderer.setClearColor(BG_COLOR_BOTTOM_BLUISH);\r\n\r\n  // Add these properties to allow overlap\r\n  sphereMaterial.depthWrite = false;\r\n  sphereMaterial.depthTest = true; // Keep this true for depth sorting\r\n\r\n  if (bubbleCanvasContainer.value) {\r\n    bubbleCanvasContainer.value.appendChild(renderer.domElement);\r\n  }\r\n\r\n  // Create the background mesh\r\n  const bgMesh = new Mesh(bgGeometry, bgMaterial);\r\n  // Position the background far behind everything\r\n  bgMesh.position.set(0, 0, -1); // Move the background far back\r\n\r\n  // Disable depth testing for the background to ensure it's always behind other objects\r\n  bgMesh.material.depthTest = false;\r\n  bgMesh.renderOrder = -1; // Ensure the background is rendered first\r\n\r\n  // Calculate the scale to ensure the background covers the full canvas\r\n  const distance = camera.position.z; // Distance from the camera\r\n  const aspect = camera.aspect;\r\n  const frustumHeight = 2 * distance * Math.tan(MathUtils.degToRad(camera.fov) / 2);\r\n  const frustumWidth = frustumHeight * aspect;\r\n\r\n  // Scale the background geometry to match the camera's frustum size\r\n  bgMesh.scale.set(\r\n    frustumWidth / bgGeometry.parameters.radius,\r\n    frustumHeight / bgGeometry.parameters.radius,\r\n    1,\r\n  );\r\n\r\n  scene.add(bgMesh); // Add the backgrou\r\n\r\n  // Create sphere meshes\r\n  const orbitRadii = new Array(SPHERE_COUNT)\r\n    .fill(0)\r\n    .map(() => MathUtils.lerp(ORBIT_MIN, ORBIT_MAX, randRange()));\r\n  const thetas = new Array(SPHERE_COUNT).fill(0).map(() => randRange(PI2));\r\n  const phis = new Array(SPHERE_COUNT).fill(0).map(() => randRange(PI2));\r\n  const positions = orbitRadii.map((rad, i) => [\r\n    rad * cos(thetas[i]) * sin(phis[i]),\r\n    rad * sin(thetas[i]) * sin(phis[i]),\r\n    rad * cos(phis[i]),\r\n  ]);\r\n\r\n  for (let i = 0; i < SPHERE_COUNT; i++) {\r\n    const sphere = new Mesh(sphereGeometry, sphereMaterial);\r\n    const [x, y, z] = positions[i];\r\n    const scaleVector = sizes[i];\r\n    sphere.scale.set(scaleVector, scaleVector, scaleVector);\r\n    sphere.position.set(x, y, z);\r\n    spheres.push(sphere);\r\n    scene.add(sphere);\r\n  }\r\n\r\n  clock = new Clock();\r\n}\r\n\r\nfunction animate() {\r\n  requestAnimationFrame(animate);\r\n\r\n  const elapsed = clock.getElapsedTime();\r\n  const temperature = sin(elapsed * 0.5) * 0.5 + 0.5;\r\n\r\n  bgMaterial.uniforms.uTemperature.value = temperature;\r\n  bgMaterial.uniforms.uElapsedTime.value = elapsed;\r\n\r\n  sphereMaterial.uniforms.uTemperature.value = temperature;\r\n  sphereMaterial.uniforms.uElapsedTime.value = elapsed;\r\n\r\n  // Floating effect for spheres\r\n  spheres.forEach((sphere, index) => {\r\n    const basePosition = positions[index];\r\n    const floatFactor = 2; // Adjust this value to control float intensity\r\n    const speed = 0.3; // Adjust this value to control float speed\r\n    const floatY = sin(elapsed * speed + index) * floatFactor;\r\n    sphere.position.y = basePosition[1] + floatY;\r\n  });\r\n\r\n  renderer.render(scene, camera);\r\n}\r\n\r\nfunction updateRendererSize() {\r\n  const width = bubbleParentContainer.value?.clientWidth || 1;\r\n  const height = bubbleParentContainer.value?.clientHeight || 1;\r\n\r\n  // Update renderer size and aspect ratio\r\n  renderer.setSize(width, height);\r\n  camera.aspect = width / height;\r\n  camera.updateProjectionMatrix();\r\n\r\n  // Recalculate background mesh scale\r\n  const distance = camera.position.z;\r\n  const frustumHeight = 2 * distance * Math.tan(MathUtils.degToRad(camera.fov) / 2);\r\n  const frustumWidth = frustumHeight * camera.aspect;\r\n\r\n  // Get the background mesh and update its scale\r\n  const bgMesh = scene.children.find(\r\n    (obj) => obj instanceof Mesh && obj.geometry === bgGeometry,\r\n  ) as Mesh;\r\n  if (bgMesh) {\r\n    bgMesh.scale.set(\r\n      frustumWidth / bgGeometry.parameters.radius,\r\n      frustumHeight / bgGeometry.parameters.radius,\r\n      1,\r\n    );\r\n  }\r\n}\r\n\r\nonMounted(() => {\r\n  createScene();\r\n  updateRendererSize();\r\n  window.addEventListener(\"resize\", updateRendererSize);\r\n  animate();\r\n});\r\n\r\nonBeforeUnmount(() => {\r\n  window.removeEventListener(\"resize\", updateRendererSize); // Cleanup on component unmount\r\n});\r\n</script>\r\n",
      "target": "uniapp"
    },
    {
      "path": "index.ts",
      "content": "export { default as BubblesBg } from \"./BubblesBg.vue\";\r\n"
    }
  ],
  "fileCount": 3,
  "contentHash": "aef9d143dbc7cbad380075a11c85557efa3bbb42"
}
