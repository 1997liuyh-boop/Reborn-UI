{
  "name": "sleek-line-cursor",
  "dependencies": [],
  "files": [
    {
      "path": "SleekLineCursor.vue",
      "content": "<template>\r\n  <canvas\r\n    id=\"canvas\"\r\n    ref=\"canvasRef\"\r\n    :class=\"cn('pointer-events-none fixed inset-0 z-50', props.class)\"\r\n  />\r\n</template>\r\n\r\n<script setup lang=\"ts\">\r\nimport { onMounted, onUnmounted, ref, type HTMLAttributes } from \"vue\";\r\nimport { cn } from \"~/lib/utils\";\r\n\r\ninterface Props {\r\n  friction?: number;\r\n  trails?: number;\r\n  size?: number;\r\n  dampening?: number;\r\n  tension?: number;\r\n  class?: HTMLAttributes[\"class\"];\r\n}\r\n\r\nconst props = withDefaults(defineProps<Props>(), {\r\n  friction: 0.5,\r\n  trails: 20,\r\n  size: 50,\r\n  dampening: 0.25,\r\n  tension: 0.98,\r\n});\r\n\r\nconst canvasRef = ref<HTMLCanvasElement | null>(null);\r\n\r\ninterface NodeType {\r\n  x: number;\r\n  y: number;\r\n  vx: number;\r\n  vy: number;\r\n}\r\n\r\ninterface WaveOptions {\r\n  phase?: number;\r\n  offset?: number;\r\n  frequency?: number;\r\n  amplitude?: number;\r\n}\r\n\r\ninterface LineOptions {\r\n  spring: number;\r\n}\r\n\r\nclass Wave {\r\n  phase: number = 0;\r\n  offset: number = 0;\r\n  frequency: number = 0.001;\r\n  amplitude: number = 1;\r\n  private e: number = 0;\r\n\r\n  constructor(options: WaveOptions = {}) {\r\n    this.init(options);\r\n  }\r\n\r\n  init(options: WaveOptions): void {\r\n    this.phase = options.phase || 0;\r\n    this.offset = options.offset || 0;\r\n    this.frequency = options.frequency || 0.001;\r\n    this.amplitude = options.amplitude || 1;\r\n  }\r\n\r\n  update(): number {\r\n    this.phase += this.frequency;\r\n    this.e = this.offset + Math.sin(this.phase) * this.amplitude;\r\n    return this.e;\r\n  }\r\n\r\n  value(): number {\r\n    return this.e;\r\n  }\r\n}\r\n\r\nclass Node implements NodeType {\r\n  x: number = 0;\r\n  y: number = 0;\r\n  vx: number = 0;\r\n  vy: number = 0;\r\n}\r\n\r\nclass Line {\r\n  spring: number = 0;\r\n  friction: number = 0;\r\n  nodes: NodeType[] = [];\r\n\r\n  constructor(options: LineOptions) {\r\n    this.init(options);\r\n  }\r\n\r\n  init(options: LineOptions): void {\r\n    this.spring = options.spring + 0.1 * Math.random() - 0.02;\r\n    this.friction = E.friction + 0.01 * Math.random() - 0.002;\r\n    this.nodes = [];\r\n\r\n    for (let n = 0; n < E.size; n++) {\r\n      const t = new Node();\r\n      t.x = pos.x;\r\n      t.y = pos.y;\r\n      this.nodes.push(t);\r\n    }\r\n  }\r\n\r\n  update(): void {\r\n    let e = this.spring;\r\n    let t = this.nodes[0];\r\n\r\n    t.vx += (pos.x - t.x) * e;\r\n    t.vy += (pos.y - t.y) * e;\r\n\r\n    for (let i = 0, a = this.nodes.length; i < a; i++) {\r\n      t = this.nodes[i];\r\n\r\n      if (i > 0) {\r\n        const n = this.nodes[i - 1];\r\n        t.vx += (n.x - t.x) * e;\r\n        t.vy += (n.y - t.y) * e;\r\n        t.vx += n.vx * E.dampening;\r\n        t.vy += n.vy * E.dampening;\r\n      }\r\n\r\n      t.vx *= this.friction;\r\n      t.vy *= this.friction;\r\n      t.x += t.vx;\r\n      t.y += t.vy;\r\n      e *= E.tension;\r\n    }\r\n  }\r\n\r\n  draw(ctx: CanvasRenderingContext2D): void {\r\n    let e: NodeType, t: NodeType;\r\n    let n = this.nodes[0].x;\r\n    let i = this.nodes[0].y;\r\n\r\n    ctx.beginPath();\r\n    ctx.moveTo(n, i);\r\n\r\n    for (let a = 1, o = this.nodes.length - 2; a < o; a++) {\r\n      e = this.nodes[a];\r\n      t = this.nodes[a + 1];\r\n      n = 0.5 * (e.x + t.x);\r\n      i = 0.5 * (e.y + t.y);\r\n      ctx.quadraticCurveTo(e.x, e.y, n, i);\r\n    }\r\n\r\n    e = this.nodes[this.nodes.length - 2];\r\n    t = this.nodes[this.nodes.length - 1];\r\n    ctx.quadraticCurveTo(e.x, e.y, t.x, t.y);\r\n    ctx.stroke();\r\n    ctx.closePath();\r\n  }\r\n}\r\n\r\nlet ctx: CanvasRenderingContext2D & { running?: boolean; frame?: number };\r\nlet f: Wave;\r\nlet pos = { x: 0, y: 0 };\r\nlet lines: Line[] = [];\r\n\r\nconst E = {\r\n  debug: true,\r\n  friction: props.friction,\r\n  trails: props.trails,\r\n  size: props.size,\r\n  dampening: props.dampening,\r\n  tension: props.tension,\r\n};\r\n\r\nfunction createLines(): void {\r\n  lines = [];\r\n  for (let e = 0; e < E.trails; e++) {\r\n    lines.push(new Line({ spring: 0.4 + (e / E.trails) * 0.025 }));\r\n  }\r\n}\r\n\r\nfunction updatePosition(e: MouseEvent | TouchEvent): void {\r\n  if (\"touches\" in e) {\r\n    pos.x = e.touches[0].pageX;\r\n    pos.y = e.touches[0].pageY;\r\n  } else {\r\n    pos.x = e.clientX;\r\n    pos.y = e.clientY;\r\n  }\r\n  e.preventDefault();\r\n}\r\n\r\nfunction handleTouchMove(e: TouchEvent): void {\r\n  if (e.touches.length === 1) {\r\n    pos.x = e.touches[0].pageX;\r\n    pos.y = e.touches[0].pageY;\r\n  }\r\n}\r\n\r\nfunction render(): void {\r\n  if (ctx.running) {\r\n    ctx.globalCompositeOperation = \"source-over\";\r\n    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);\r\n    ctx.globalCompositeOperation = \"lighter\";\r\n    ctx.strokeStyle = `hsla(${Math.round(f.update())},50%,50%,0.2)`;\r\n    ctx.lineWidth = 1;\r\n\r\n    for (let t = 0; t < E.trails; t++) {\r\n      const e = lines[t];\r\n      e.update();\r\n      e.draw(ctx);\r\n    }\r\n\r\n    ctx.frame = (ctx.frame || 0) + 1;\r\n    window.requestAnimationFrame(render);\r\n  }\r\n}\r\n\r\nfunction resizeCanvas(): void {\r\n  if (ctx && ctx.canvas) {\r\n    ctx.canvas.width = window.innerWidth - 20;\r\n    ctx.canvas.height = window.innerHeight;\r\n  }\r\n}\r\n\r\nfunction onMouseMove(e: MouseEvent | TouchEvent): void {\r\n  document.removeEventListener(\"mousemove\", onMouseMove);\r\n  document.removeEventListener(\"touchstart\", onMouseMove);\r\n  document.addEventListener(\"mousemove\", updatePosition);\r\n  document.addEventListener(\"touchmove\", updatePosition);\r\n  document.addEventListener(\"touchstart\", handleTouchMove);\r\n  updatePosition(e);\r\n  createLines();\r\n  render();\r\n}\r\n\r\nfunction handleFocus(): void {\r\n  if (!ctx.running) {\r\n    ctx.running = true;\r\n    render();\r\n  }\r\n}\r\n\r\nfunction handleBlur(): void {\r\n  ctx.running = true;\r\n}\r\n\r\nfunction initCanvas(): void {\r\n  const canvas = canvasRef.value;\r\n  if (!canvas) return;\r\n\r\n  ctx = canvas.getContext(\"2d\") as CanvasRenderingContext2D & {\r\n    running?: boolean;\r\n    frame?: number;\r\n  };\r\n\r\n  ctx.running = true;\r\n  ctx.frame = 1;\r\n\r\n  f = new Wave({\r\n    phase: Math.random() * 2 * Math.PI,\r\n    amplitude: 85,\r\n    frequency: 0.0015,\r\n    offset: 285,\r\n  });\r\n\r\n  document.addEventListener(\"mousemove\", onMouseMove);\r\n  document.addEventListener(\"touchstart\", onMouseMove);\r\n  document.body.addEventListener(\"orientationchange\", resizeCanvas);\r\n  window.addEventListener(\"resize\", resizeCanvas);\r\n  window.addEventListener(\"focus\", handleFocus);\r\n  window.addEventListener(\"blur\", handleBlur);\r\n\r\n  resizeCanvas();\r\n}\r\n\r\nfunction cleanup(): void {\r\n  if (ctx) {\r\n    ctx.running = false;\r\n  }\r\n\r\n  document.removeEventListener(\"mousemove\", onMouseMove);\r\n  document.removeEventListener(\"mousemove\", updatePosition);\r\n  document.removeEventListener(\"touchstart\", onMouseMove);\r\n  document.removeEventListener(\"touchstart\", handleTouchMove);\r\n  document.removeEventListener(\"touchmove\", updatePosition);\r\n  document.body.removeEventListener(\"orientationchange\", resizeCanvas);\r\n  window.removeEventListener(\"resize\", resizeCanvas);\r\n  window.removeEventListener(\"focus\", handleFocus);\r\n  window.removeEventListener(\"blur\", handleBlur);\r\n}\r\n\r\nonMounted(() => {\r\n  initCanvas();\r\n});\r\n\r\nonUnmounted(() => {\r\n  cleanup();\r\n});\r\n</script>\r\n\r\n<style scoped>\r\n/* Tailwind classes are applied directly to the template */\r\n</style>\r\n",
      "target": "web"
    },
    {
      "path": "SleekLineCursor.vue",
      "content": "<template>\r\n  <canvas\r\n    id=\"canvas\"\r\n    ref=\"canvasRef\"\r\n    :class=\"cn('pointer-events-none fixed inset-0 z-50', props.class)\"\r\n  />\r\n</template>\r\n\r\n<script setup lang=\"ts\">\r\nimport { onMounted, onUnmounted, ref, type HTMLAttributes } from \"vue\";\r\nimport { cn } from \"~/lib/utils\";\r\n\r\ninterface Props {\r\n  friction?: number;\r\n  trails?: number;\r\n  size?: number;\r\n  dampening?: number;\r\n  tension?: number;\r\n  class?: HTMLAttributes[\"class\"];\r\n}\r\n\r\nconst props = withDefaults(defineProps<Props>(), {\r\n  friction: 0.5,\r\n  trails: 20,\r\n  size: 50,\r\n  dampening: 0.25,\r\n  tension: 0.98,\r\n});\r\n\r\nconst canvasRef = ref<HTMLCanvasElement | null>(null);\r\n\r\ninterface NodeType {\r\n  x: number;\r\n  y: number;\r\n  vx: number;\r\n  vy: number;\r\n}\r\n\r\ninterface WaveOptions {\r\n  phase?: number;\r\n  offset?: number;\r\n  frequency?: number;\r\n  amplitude?: number;\r\n}\r\n\r\ninterface LineOptions {\r\n  spring: number;\r\n}\r\n\r\nclass Wave {\r\n  phase: number = 0;\r\n  offset: number = 0;\r\n  frequency: number = 0.001;\r\n  amplitude: number = 1;\r\n  private e: number = 0;\r\n\r\n  constructor(options: WaveOptions = {}) {\r\n    this.init(options);\r\n  }\r\n\r\n  init(options: WaveOptions): void {\r\n    this.phase = options.phase || 0;\r\n    this.offset = options.offset || 0;\r\n    this.frequency = options.frequency || 0.001;\r\n    this.amplitude = options.amplitude || 1;\r\n  }\r\n\r\n  update(): number {\r\n    this.phase += this.frequency;\r\n    this.e = this.offset + Math.sin(this.phase) * this.amplitude;\r\n    return this.e;\r\n  }\r\n\r\n  value(): number {\r\n    return this.e;\r\n  }\r\n}\r\n\r\nclass Node implements NodeType {\r\n  x: number = 0;\r\n  y: number = 0;\r\n  vx: number = 0;\r\n  vy: number = 0;\r\n}\r\n\r\nclass Line {\r\n  spring: number = 0;\r\n  friction: number = 0;\r\n  nodes: NodeType[] = [];\r\n\r\n  constructor(options: LineOptions) {\r\n    this.init(options);\r\n  }\r\n\r\n  init(options: LineOptions): void {\r\n    this.spring = options.spring + 0.1 * Math.random() - 0.02;\r\n    this.friction = E.friction + 0.01 * Math.random() - 0.002;\r\n    this.nodes = [];\r\n\r\n    for (let n = 0; n < E.size; n++) {\r\n      const t = new Node();\r\n      t.x = pos.x;\r\n      t.y = pos.y;\r\n      this.nodes.push(t);\r\n    }\r\n  }\r\n\r\n  update(): void {\r\n    let e = this.spring;\r\n    let t = this.nodes[0];\r\n\r\n    t.vx += (pos.x - t.x) * e;\r\n    t.vy += (pos.y - t.y) * e;\r\n\r\n    for (let i = 0, a = this.nodes.length; i < a; i++) {\r\n      t = this.nodes[i];\r\n\r\n      if (i > 0) {\r\n        const n = this.nodes[i - 1];\r\n        t.vx += (n.x - t.x) * e;\r\n        t.vy += (n.y - t.y) * e;\r\n        t.vx += n.vx * E.dampening;\r\n        t.vy += n.vy * E.dampening;\r\n      }\r\n\r\n      t.vx *= this.friction;\r\n      t.vy *= this.friction;\r\n      t.x += t.vx;\r\n      t.y += t.vy;\r\n      e *= E.tension;\r\n    }\r\n  }\r\n\r\n  draw(ctx: CanvasRenderingContext2D): void {\r\n    let e: NodeType, t: NodeType;\r\n    let n = this.nodes[0].x;\r\n    let i = this.nodes[0].y;\r\n\r\n    ctx.beginPath();\r\n    ctx.moveTo(n, i);\r\n\r\n    for (let a = 1, o = this.nodes.length - 2; a < o; a++) {\r\n      e = this.nodes[a];\r\n      t = this.nodes[a + 1];\r\n      n = 0.5 * (e.x + t.x);\r\n      i = 0.5 * (e.y + t.y);\r\n      ctx.quadraticCurveTo(e.x, e.y, n, i);\r\n    }\r\n\r\n    e = this.nodes[this.nodes.length - 2];\r\n    t = this.nodes[this.nodes.length - 1];\r\n    ctx.quadraticCurveTo(e.x, e.y, t.x, t.y);\r\n    ctx.stroke();\r\n    ctx.closePath();\r\n  }\r\n}\r\n\r\nlet ctx: CanvasRenderingContext2D & { running?: boolean; frame?: number };\r\nlet f: Wave;\r\nlet pos = { x: 0, y: 0 };\r\nlet lines: Line[] = [];\r\n\r\nconst E = {\r\n  debug: true,\r\n  friction: props.friction,\r\n  trails: props.trails,\r\n  size: props.size,\r\n  dampening: props.dampening,\r\n  tension: props.tension,\r\n};\r\n\r\nfunction createLines(): void {\r\n  lines = [];\r\n  for (let e = 0; e < E.trails; e++) {\r\n    lines.push(new Line({ spring: 0.4 + (e / E.trails) * 0.025 }));\r\n  }\r\n}\r\n\r\nfunction updatePosition(e: MouseEvent | TouchEvent): void {\r\n  if (\"touches\" in e) {\r\n    pos.x = e.touches[0].pageX;\r\n    pos.y = e.touches[0].pageY;\r\n  } else {\r\n    pos.x = e.clientX;\r\n    pos.y = e.clientY;\r\n  }\r\n  e.preventDefault();\r\n}\r\n\r\nfunction handleTouchMove(e: TouchEvent): void {\r\n  if (e.touches.length === 1) {\r\n    pos.x = e.touches[0].pageX;\r\n    pos.y = e.touches[0].pageY;\r\n  }\r\n}\r\n\r\nfunction render(): void {\r\n  if (ctx.running) {\r\n    ctx.globalCompositeOperation = \"source-over\";\r\n    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);\r\n    ctx.globalCompositeOperation = \"lighter\";\r\n    ctx.strokeStyle = `hsla(${Math.round(f.update())},50%,50%,0.2)`;\r\n    ctx.lineWidth = 1;\r\n\r\n    for (let t = 0; t < E.trails; t++) {\r\n      const e = lines[t];\r\n      e.update();\r\n      e.draw(ctx);\r\n    }\r\n\r\n    ctx.frame = (ctx.frame || 0) + 1;\r\n    window.requestAnimationFrame(render);\r\n  }\r\n}\r\n\r\nfunction resizeCanvas(): void {\r\n  if (ctx && ctx.canvas) {\r\n    ctx.canvas.width = window.innerWidth - 20;\r\n    ctx.canvas.height = window.innerHeight;\r\n  }\r\n}\r\n\r\nfunction onMouseMove(e: MouseEvent | TouchEvent): void {\r\n  document.removeEventListener(\"mousemove\", onMouseMove);\r\n  document.removeEventListener(\"touchstart\", onMouseMove);\r\n  document.addEventListener(\"mousemove\", updatePosition);\r\n  document.addEventListener(\"touchmove\", updatePosition);\r\n  document.addEventListener(\"touchstart\", handleTouchMove);\r\n  updatePosition(e);\r\n  createLines();\r\n  render();\r\n}\r\n\r\nfunction handleFocus(): void {\r\n  if (!ctx.running) {\r\n    ctx.running = true;\r\n    render();\r\n  }\r\n}\r\n\r\nfunction handleBlur(): void {\r\n  ctx.running = true;\r\n}\r\n\r\nfunction initCanvas(): void {\r\n  const canvas = canvasRef.value;\r\n  if (!canvas) return;\r\n\r\n  ctx = canvas.getContext(\"2d\") as CanvasRenderingContext2D & {\r\n    running?: boolean;\r\n    frame?: number;\r\n  };\r\n\r\n  ctx.running = true;\r\n  ctx.frame = 1;\r\n\r\n  f = new Wave({\r\n    phase: Math.random() * 2 * Math.PI,\r\n    amplitude: 85,\r\n    frequency: 0.0015,\r\n    offset: 285,\r\n  });\r\n\r\n  document.addEventListener(\"mousemove\", onMouseMove);\r\n  document.addEventListener(\"touchstart\", onMouseMove);\r\n  document.body.addEventListener(\"orientationchange\", resizeCanvas);\r\n  window.addEventListener(\"resize\", resizeCanvas);\r\n  window.addEventListener(\"focus\", handleFocus);\r\n  window.addEventListener(\"blur\", handleBlur);\r\n\r\n  resizeCanvas();\r\n}\r\n\r\nfunction cleanup(): void {\r\n  if (ctx) {\r\n    ctx.running = false;\r\n  }\r\n\r\n  document.removeEventListener(\"mousemove\", onMouseMove);\r\n  document.removeEventListener(\"mousemove\", updatePosition);\r\n  document.removeEventListener(\"touchstart\", onMouseMove);\r\n  document.removeEventListener(\"touchstart\", handleTouchMove);\r\n  document.removeEventListener(\"touchmove\", updatePosition);\r\n  document.body.removeEventListener(\"orientationchange\", resizeCanvas);\r\n  window.removeEventListener(\"resize\", resizeCanvas);\r\n  window.removeEventListener(\"focus\", handleFocus);\r\n  window.removeEventListener(\"blur\", handleBlur);\r\n}\r\n\r\nonMounted(() => {\r\n  initCanvas();\r\n});\r\n\r\nonUnmounted(() => {\r\n  cleanup();\r\n});\r\n</script>\r\n\r\n<style scoped>\r\n/* Tailwind classes are applied directly to the template */\r\n</style>\r\n",
      "target": "uniapp"
    }
  ],
  "fileCount": 2,
  "contentHash": "6a587541f6f52927c8f87c495579c1aa5f47ad64"
}
