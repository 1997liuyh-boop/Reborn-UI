{
  "name": "light-speed",
  "dependencies": [
    "postprocessing",
    "three"
  ],
  "files": [
    {
      "path": "index.ts",
      "content": "export { default as LightSpeed } from \"./LightSpeed.vue\";\r\nexport * from \"./LightSpeedApp\";\r\nexport * from \"./presets\";\r\nexport * from \"./shaders\";\r\n"
    },
    {
      "path": "LightSpeed.vue",
      "content": "<template>\r\n  <div\r\n    ref=\"lightSpeedRef\"\r\n    class=\"w-full h-full overflow-hidden block\"\r\n  />\r\n</template>\r\n\r\n<script lang=\"ts\" setup>\r\nimport type { LightSpeedOptions, LightSpeedProps } from \"./LightSpeedApp\";\r\nimport { defaultOptions, distortions, LightSpeedApp } from \"./LightSpeedApp\";\r\n\r\nconst props = defineProps<LightSpeedProps>();\r\n\r\nconst containerRef = useTemplateRef(\"lightSpeedRef\");\r\n\r\nonMounted(() => {\r\n  if (!containerRef.value) return;\r\n\r\n  const mergedOptions: LightSpeedOptions = {\r\n    ...defaultOptions,\r\n    ...(props.effectOptions || {}),\r\n  };\r\n\r\n  if (typeof mergedOptions.distortion === \"string\") {\r\n    mergedOptions.distortion = distortions[mergedOptions.distortion];\r\n  }\r\n\r\n  const lightSpeedApp = new LightSpeedApp(containerRef.value, mergedOptions);\r\n  lightSpeedApp.loadAssets().then(lightSpeedApp.init);\r\n});\r\n</script>\r\n"
    },
    {
      "path": "LightSpeedApp.ts",
      "content": "/* eslint-disable func-style */\r\n/* eslint-disable @typescript-eslint/no-explicit-any */\r\nimport {\r\n  BloomEffect,\r\n  EffectComposer,\r\n  EffectPass,\r\n  RenderPass,\r\n  SMAAEffect,\r\n  SMAAPreset,\r\n} from \"postprocessing\";\r\nimport * as THREE from \"three\";\r\nimport {\r\n  carLightsFragment,\r\n  carLightsVertex,\r\n  distortion_vertex,\r\n  islandFragment,\r\n  roadFragment,\r\n  roadVertex,\r\n  sideSticksFragment,\r\n  sideSticksVertex,\r\n} from \"./shaders\";\r\n\r\nexport interface Distortion {\r\n  uniforms: Record<string, { value: any }>;\r\n  getDistortion: string;\r\n  getJS?: (progress: number, time: number) => THREE.Vector3;\r\n}\r\n\r\nexport interface Distortions {\r\n  [key: string]: Distortion;\r\n}\r\n\r\nexport interface Colors {\r\n  roadColor: number;\r\n  islandColor: number;\r\n  background: number;\r\n  shoulderLines: number;\r\n  brokenLines: number;\r\n  leftCars: number[];\r\n  rightCars: number[];\r\n  sticks: number;\r\n}\r\n\r\nexport interface LightSpeedOptions {\r\n  onSpeedUp?: (ev: MouseEvent | TouchEvent) => void;\r\n  onSlowDown?: (ev: MouseEvent | TouchEvent) => void;\r\n  distortion?: string | Distortion;\r\n  length: number;\r\n  roadWidth: number;\r\n  islandWidth: number;\r\n  lanesPerRoad: number;\r\n  fov: number;\r\n  fovSpeedUp: number;\r\n  speedUp: number;\r\n  carLightsFade: number;\r\n  totalSideLightSticks: number;\r\n  lightPairsPerRoadWay: number;\r\n  shoulderLinesWidthPercentage: number;\r\n  brokenLinesWidthPercentage: number;\r\n  brokenLinesLengthPercentage: number;\r\n  lightStickWidth: [number, number];\r\n  lightStickHeight: [number, number];\r\n  movingAwaySpeed: [number, number];\r\n  movingCloserSpeed: [number, number];\r\n  carLightsLength: [number, number];\r\n  carLightsRadius: [number, number];\r\n  carWidthPercentage: [number, number];\r\n  carShiftX: [number, number];\r\n  carFloorSeparation: [number, number];\r\n  colors: Colors;\r\n  isHyper?: boolean;\r\n}\r\n\r\nexport interface LightSpeedProps {\r\n  effectOptions?: Partial<LightSpeedOptions>;\r\n}\r\n\r\nexport const defaultOptions: LightSpeedOptions = {\r\n  onSpeedUp: () => {},\r\n  onSlowDown: () => {},\r\n  distortion: \"turbulentDistortion\",\r\n  length: 400,\r\n  roadWidth: 10,\r\n  islandWidth: 2,\r\n  lanesPerRoad: 4,\r\n  fov: 90,\r\n  fovSpeedUp: 150,\r\n  speedUp: 2,\r\n  carLightsFade: 0.4,\r\n  totalSideLightSticks: 20,\r\n  lightPairsPerRoadWay: 40,\r\n  shoulderLinesWidthPercentage: 0.05,\r\n  brokenLinesWidthPercentage: 0.1,\r\n  brokenLinesLengthPercentage: 0.5,\r\n  lightStickWidth: [0.12, 0.5],\r\n  lightStickHeight: [1.3, 1.7],\r\n  movingAwaySpeed: [60, 80],\r\n  movingCloserSpeed: [-120, -160],\r\n  carLightsLength: [400 * 0.03, 400 * 0.2],\r\n  carLightsRadius: [0.05, 0.14],\r\n  carWidthPercentage: [0.3, 0.5],\r\n  carShiftX: [-0.8, 0.8],\r\n  carFloorSeparation: [0, 5],\r\n  colors: {\r\n    roadColor: 0x080808,\r\n    islandColor: 0x0a0a0a,\r\n    background: 0x000000,\r\n    shoulderLines: 0xffffff,\r\n    brokenLines: 0xffffff,\r\n    leftCars: [0xd856bf, 0x6750a2, 0xc247ac],\r\n    rightCars: [0x03b3c3, 0x0e5ea5, 0x324555],\r\n    sticks: 0x03b3c3,\r\n  },\r\n};\r\n\r\nfunction nsin(val: number) {\r\n  return Math.sin(val) * 0.5 + 0.5;\r\n}\r\n\r\nconst mountainUniforms = {\r\n  uFreq: { value: new THREE.Vector3(3, 6, 10) },\r\n  uAmp: { value: new THREE.Vector3(30, 30, 20) },\r\n};\r\n\r\nconst xyUniforms = {\r\n  uFreq: { value: new THREE.Vector2(5, 2) },\r\n  uAmp: { value: new THREE.Vector2(25, 15) },\r\n};\r\n\r\nconst LongRaceUniforms = {\r\n  uFreq: { value: new THREE.Vector2(2, 3) },\r\n  uAmp: { value: new THREE.Vector2(35, 10) },\r\n};\r\n\r\nconst turbulentUniforms = {\r\n  uFreq: { value: new THREE.Vector4(4, 8, 8, 1) },\r\n  uAmp: { value: new THREE.Vector4(25, 5, 10, 10) },\r\n};\r\n\r\nconst deepUniforms = {\r\n  uFreq: { value: new THREE.Vector2(4, 8) },\r\n  uAmp: { value: new THREE.Vector2(10, 20) },\r\n  uPowY: { value: new THREE.Vector2(20, 2) },\r\n};\r\n\r\nexport const distortions: Distortions = {\r\n  mountainDistortion: {\r\n    uniforms: mountainUniforms,\r\n    getDistortion: `\r\n      uniform vec3 uAmp;\r\n      uniform vec3 uFreq;\r\n      #define PI 3.14159265358979\r\n      float nsin(float val){\r\n        return sin(val) * 0.5 + 0.5;\r\n      }\r\n      vec3 getDistortion(float progress){\r\n        float movementProgressFix = 0.02;\r\n        return vec3( \r\n          cos(progress * PI * uFreq.x + uTime) * uAmp.x - cos(movementProgressFix * PI * uFreq.x + uTime) * uAmp.x,\r\n          nsin(progress * PI * uFreq.y + uTime) * uAmp.y - nsin(movementProgressFix * PI * uFreq.y + uTime) * uAmp.y,\r\n          nsin(progress * PI * uFreq.z + uTime) * uAmp.z - nsin(movementProgressFix * PI * uFreq.z + uTime) * uAmp.z\r\n        );\r\n      }\r\n    `,\r\n    getJS: (progress: number, time: number) => {\r\n      const movementProgressFix = 0.02;\r\n      const uFreq = mountainUniforms.uFreq.value;\r\n      const uAmp = mountainUniforms.uAmp.value;\r\n      const distortion = new THREE.Vector3(\r\n        Math.cos(progress * Math.PI * uFreq.x + time) * uAmp.x -\r\n          Math.cos(movementProgressFix * Math.PI * uFreq.x + time) * uAmp.x,\r\n        nsin(progress * Math.PI * uFreq.y + time) * uAmp.y -\r\n          nsin(movementProgressFix * Math.PI * uFreq.y + time) * uAmp.y,\r\n        nsin(progress * Math.PI * uFreq.z + time) * uAmp.z -\r\n          nsin(movementProgressFix * Math.PI * uFreq.z + time) * uAmp.z,\r\n      );\r\n      const lookAtAmp = new THREE.Vector3(2, 2, 2);\r\n      const lookAtOffset = new THREE.Vector3(0, 0, -5);\r\n      return distortion.multiply(lookAtAmp).add(lookAtOffset);\r\n    },\r\n  },\r\n  xyDistortion: {\r\n    uniforms: xyUniforms,\r\n    getDistortion: `\r\n      uniform vec2 uFreq;\r\n      uniform vec2 uAmp;\r\n      #define PI 3.14159265358979\r\n      vec3 getDistortion(float progress){\r\n        float movementProgressFix = 0.02;\r\n        return vec3( \r\n          cos(progress * PI * uFreq.x + uTime) * uAmp.x - cos(movementProgressFix * PI * uFreq.x + uTime) * uAmp.x,\r\n          sin(progress * PI * uFreq.y + PI/2. + uTime) * uAmp.y - sin(movementProgressFix * PI * uFreq.y + PI/2. + uTime) * uAmp.y,\r\n          0.\r\n        );\r\n      }\r\n    `,\r\n    getJS: (progress: number, time: number) => {\r\n      const movementProgressFix = 0.02;\r\n      const uFreq = xyUniforms.uFreq.value;\r\n      const uAmp = xyUniforms.uAmp.value;\r\n      const distortion = new THREE.Vector3(\r\n        Math.cos(progress * Math.PI * uFreq.x + time) * uAmp.x -\r\n          Math.cos(movementProgressFix * Math.PI * uFreq.x + time) * uAmp.x,\r\n        Math.sin(progress * Math.PI * uFreq.y + time + Math.PI / 2) * uAmp.y -\r\n          Math.sin(movementProgressFix * Math.PI * uFreq.y + time + Math.PI / 2) * uAmp.y,\r\n        0,\r\n      );\r\n      const lookAtAmp = new THREE.Vector3(2, 0.4, 1);\r\n      const lookAtOffset = new THREE.Vector3(0, 0, -3);\r\n      return distortion.multiply(lookAtAmp).add(lookAtOffset);\r\n    },\r\n  },\r\n  LongRaceDistortion: {\r\n    uniforms: LongRaceUniforms,\r\n    getDistortion: `\r\n      uniform vec2 uFreq;\r\n      uniform vec2 uAmp;\r\n      #define PI 3.14159265358979\r\n      vec3 getDistortion(float progress){\r\n        float camProgress = 0.0125;\r\n        return vec3( \r\n          sin(progress * PI * uFreq.x + uTime) * uAmp.x - sin(camProgress * PI * uFreq.x + uTime) * uAmp.x,\r\n          sin(progress * PI * uFreq.y + uTime) * uAmp.y - sin(camProgress * PI * uFreq.y + uTime) * uAmp.y,\r\n          0.\r\n        );\r\n      }\r\n    `,\r\n    getJS: (progress: number, time: number) => {\r\n      const camProgress = 0.0125;\r\n      const uFreq = LongRaceUniforms.uFreq.value;\r\n      const uAmp = LongRaceUniforms.uAmp.value;\r\n      const distortion = new THREE.Vector3(\r\n        Math.sin(progress * Math.PI * uFreq.x + time) * uAmp.x -\r\n          Math.sin(camProgress * Math.PI * uFreq.x + time) * uAmp.x,\r\n        Math.sin(progress * Math.PI * uFreq.y + time) * uAmp.y -\r\n          Math.sin(camProgress * Math.PI * uFreq.y + time) * uAmp.y,\r\n        0,\r\n      );\r\n      const lookAtAmp = new THREE.Vector3(1, 1, 0);\r\n      const lookAtOffset = new THREE.Vector3(0, 0, -5);\r\n      return distortion.multiply(lookAtAmp).add(lookAtOffset);\r\n    },\r\n  },\r\n  turbulentDistortion: {\r\n    uniforms: turbulentUniforms,\r\n    getDistortion: `\r\n      uniform vec4 uFreq;\r\n      uniform vec4 uAmp;\r\n      float nsin(float val){\r\n        return sin(val) * 0.5 + 0.5;\r\n      }\r\n      #define PI 3.14159265358979\r\n      float getDistortionX(float progress){\r\n        return (\r\n          cos(PI * progress * uFreq.r + uTime) * uAmp.r +\r\n          pow(cos(PI * progress * uFreq.g + uTime * (uFreq.g / uFreq.r)), 2. ) * uAmp.g\r\n        );\r\n      }\r\n      float getDistortionY(float progress){\r\n        return (\r\n          -nsin(PI * progress * uFreq.b + uTime) * uAmp.b +\r\n          -pow(nsin(PI * progress * uFreq.a + uTime / (uFreq.b / uFreq.a)), 5.) * uAmp.a\r\n        );\r\n      }\r\n      vec3 getDistortion(float progress){\r\n        return vec3(\r\n          getDistortionX(progress) - getDistortionX(0.0125),\r\n          getDistortionY(progress) - getDistortionY(0.0125),\r\n          0.\r\n        );\r\n      }\r\n    `,\r\n    getJS: (progress: number, time: number) => {\r\n      const uFreq = turbulentUniforms.uFreq.value;\r\n      const uAmp = turbulentUniforms.uAmp.value;\r\n\r\n      const getX = (p: number) =>\r\n        Math.cos(Math.PI * p * uFreq.x + time) * uAmp.x +\r\n        Math.cos(Math.PI * p * uFreq.y + time * (uFreq.y / uFreq.x)) ** 2 * uAmp.y;\r\n\r\n      const getY = (p: number) =>\r\n        -nsin(Math.PI * p * uFreq.z + time) * uAmp.z -\r\n        nsin(Math.PI * p * uFreq.w + time / (uFreq.z / uFreq.w)) ** 5 * uAmp.w;\r\n\r\n      const distortion = new THREE.Vector3(\r\n        getX(progress) - getX(progress + 0.007),\r\n        getY(progress) - getY(progress + 0.007),\r\n        0,\r\n      );\r\n      const lookAtAmp = new THREE.Vector3(-2, -5, 0);\r\n      const lookAtOffset = new THREE.Vector3(0, 0, -10);\r\n      return distortion.multiply(lookAtAmp).add(lookAtOffset);\r\n    },\r\n  },\r\n  turbulentDistortionStill: {\r\n    uniforms: turbulentUniforms,\r\n    getDistortion: `\r\n      uniform vec4 uFreq;\r\n      uniform vec4 uAmp;\r\n      float nsin(float val){\r\n        return sin(val) * 0.5 + 0.5;\r\n      }\r\n      #define PI 3.14159265358979\r\n      float getDistortionX(float progress){\r\n        return (\r\n          cos(PI * progress * uFreq.r) * uAmp.r +\r\n          pow(cos(PI * progress * uFreq.g * (uFreq.g / uFreq.r)), 2. ) * uAmp.g\r\n        );\r\n      }\r\n      float getDistortionY(float progress){\r\n        return (\r\n          -nsin(PI * progress * uFreq.b) * uAmp.b +\r\n          -pow(nsin(PI * progress * uFreq.a / (uFreq.b / uFreq.a)), 5.) * uAmp.a\r\n        );\r\n      }\r\n      vec3 getDistortion(float progress){\r\n        return vec3(\r\n          getDistortionX(progress) - getDistortionX(0.02),\r\n          getDistortionY(progress) - getDistortionY(0.02),\r\n          0.\r\n        );\r\n      }\r\n    `,\r\n  },\r\n  deepDistortionStill: {\r\n    uniforms: deepUniforms,\r\n    getDistortion: `\r\n      uniform vec4 uFreq;\r\n      uniform vec4 uAmp;\r\n      uniform vec2 uPowY;\r\n      float nsin(float val){\r\n        return sin(val) * 0.5 + 0.5;\r\n      }\r\n      #define PI 3.14159265358979\r\n      float getDistortionX(float progress){\r\n        return (\r\n          sin(progress * PI * uFreq.x) * uAmp.x * 2.\r\n        );\r\n      }\r\n      float getDistortionY(float progress){\r\n        return (\r\n          pow(abs(progress * uPowY.x), uPowY.y) + sin(progress * PI * uFreq.y) * uAmp.y\r\n        );\r\n      }\r\n      vec3 getDistortion(float progress){\r\n        return vec3(\r\n          getDistortionX(progress) - getDistortionX(0.02),\r\n          getDistortionY(progress) - getDistortionY(0.05),\r\n          0.\r\n        );\r\n      }\r\n    `,\r\n  },\r\n  deepDistortion: {\r\n    uniforms: deepUniforms,\r\n    getDistortion: `\r\n      uniform vec4 uFreq;\r\n      uniform vec4 uAmp;\r\n      uniform vec2 uPowY;\r\n      float nsin(float val){\r\n        return sin(val) * 0.5 + 0.5;\r\n      }\r\n      #define PI 3.14159265358979\r\n      float getDistortionX(float progress){\r\n        return (\r\n          sin(progress * PI * uFreq.x + uTime) * uAmp.x\r\n        );\r\n      }\r\n      float getDistortionY(float progress){\r\n        return (\r\n          pow(abs(progress * uPowY.x), uPowY.y) + sin(progress * PI * uFreq.y + uTime) * uAmp.y\r\n        );\r\n      }\r\n      vec3 getDistortion(float progress){\r\n        return vec3(\r\n          getDistortionX(progress) - getDistortionX(0.02),\r\n          getDistortionY(progress) - getDistortionY(0.02),\r\n          0.\r\n        );\r\n      }\r\n    `,\r\n    getJS: (progress: number, time: number) => {\r\n      const uFreq = deepUniforms.uFreq.value;\r\n      const uAmp = deepUniforms.uAmp.value;\r\n      const uPowY = deepUniforms.uPowY.value;\r\n\r\n      const getX = (p: number) => Math.sin(p * Math.PI * uFreq.x + time) * uAmp.x;\r\n      const getY = (p: number) =>\r\n        (p * uPowY.x) ** uPowY.y + Math.sin(p * Math.PI * uFreq.y + time) * uAmp.y;\r\n\r\n      const distortion = new THREE.Vector3(\r\n        getX(progress) - getX(progress + 0.01),\r\n        getY(progress) - getY(progress + 0.01),\r\n        0,\r\n      );\r\n      const lookAtAmp = new THREE.Vector3(-2, -4, 0);\r\n      const lookAtOffset = new THREE.Vector3(0, 0, -10);\r\n      return distortion.multiply(lookAtAmp).add(lookAtOffset);\r\n    },\r\n  },\r\n};\r\n\r\nconst distortion_uniforms = {\r\n  uDistortionX: { value: new THREE.Vector2(80, 3) },\r\n  uDistortionY: { value: new THREE.Vector2(-40, 2.5) },\r\n};\r\n\r\nfunction random(base: number | [number, number]): number {\r\n  if (Array.isArray(base)) {\r\n    return Math.random() * (base[1] - base[0]) + base[0];\r\n  }\r\n  return Math.random() * base;\r\n}\r\n\r\nfunction pickRandom<T>(arr: T | T[]): T {\r\n  if (Array.isArray(arr)) {\r\n    return arr[Math.floor(Math.random() * arr.length)]!;\r\n  }\r\n  return arr;\r\n}\r\n\r\nfunction lerp(current: number, target: number, speed = 0.1, limit = 0.001): number {\r\n  let change = (target - current) * speed;\r\n  if (Math.abs(change) < limit) {\r\n    change = target - current;\r\n  }\r\n  return change;\r\n}\r\n\r\nclass CarLights {\r\n  webgl: LightSpeedApp;\r\n  options: LightSpeedOptions;\r\n  colors: number[] | THREE.Color;\r\n  speed: [number, number];\r\n  fade: THREE.Vector2;\r\n  mesh!: THREE.Mesh<THREE.InstancedBufferGeometry, THREE.ShaderMaterial>;\r\n\r\n  constructor(\r\n    webgl: LightSpeedApp,\r\n    options: LightSpeedOptions,\r\n    colors: number[] | THREE.Color,\r\n    speed: [number, number],\r\n    fade: THREE.Vector2,\r\n  ) {\r\n    this.webgl = webgl;\r\n    this.options = options;\r\n    this.colors = colors;\r\n    this.speed = speed;\r\n    this.fade = fade;\r\n  }\r\n\r\n  init() {\r\n    const options = this.options;\r\n    const curve = new THREE.LineCurve3(new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, -1));\r\n    const geometry = new THREE.TubeGeometry(curve, 40, 1, 8, false);\r\n\r\n    const instanced = new THREE.InstancedBufferGeometry().copy(\r\n      geometry as any,\r\n    ) as THREE.InstancedBufferGeometry;\r\n    instanced.instanceCount = options.lightPairsPerRoadWay * 2;\r\n\r\n    const laneWidth = options.roadWidth / options.lanesPerRoad;\r\n\r\n    const aOffset: number[] = [];\r\n    const aMetrics: number[] = [];\r\n    const aColor: number[] = [];\r\n\r\n    let colorArray: THREE.Color[];\r\n    if (Array.isArray(this.colors)) {\r\n      colorArray = this.colors.map((c) => new THREE.Color(c));\r\n    } else {\r\n      colorArray = [new THREE.Color(this.colors)];\r\n    }\r\n\r\n    for (let i = 0; i < options.lightPairsPerRoadWay; i++) {\r\n      const radius = random(options.carLightsRadius);\r\n      const length = random(options.carLightsLength);\r\n      const spd = random(this.speed);\r\n\r\n      const carLane = i % options.lanesPerRoad;\r\n      let laneX = carLane * laneWidth - options.roadWidth / 2 + laneWidth / 2;\r\n\r\n      const carWidth = random(options.carWidthPercentage) * laneWidth;\r\n      const carShiftX = random(options.carShiftX) * laneWidth;\r\n      laneX += carShiftX;\r\n\r\n      const offsetY = random(options.carFloorSeparation) + radius * 1.3;\r\n      const offsetZ = -random(options.length);\r\n\r\n      // left side\r\n      aOffset.push(laneX - carWidth / 2);\r\n      aOffset.push(offsetY);\r\n      aOffset.push(offsetZ);\r\n\r\n      // right side\r\n      aOffset.push(laneX + carWidth / 2);\r\n      aOffset.push(offsetY);\r\n      aOffset.push(offsetZ);\r\n\r\n      aMetrics.push(radius);\r\n      aMetrics.push(length);\r\n      aMetrics.push(spd);\r\n\r\n      aMetrics.push(radius);\r\n      aMetrics.push(length);\r\n      aMetrics.push(spd);\r\n\r\n      const color = pickRandom<THREE.Color>(colorArray);\r\n      aColor.push(color.r);\r\n      aColor.push(color.g);\r\n      aColor.push(color.b);\r\n\r\n      aColor.push(color.r);\r\n      aColor.push(color.g);\r\n      aColor.push(color.b);\r\n    }\r\n\r\n    instanced.setAttribute(\r\n      \"aOffset\",\r\n      new THREE.InstancedBufferAttribute(new Float32Array(aOffset), 3, false),\r\n    );\r\n    instanced.setAttribute(\r\n      \"aMetrics\",\r\n      new THREE.InstancedBufferAttribute(new Float32Array(aMetrics), 3, false),\r\n    );\r\n    instanced.setAttribute(\r\n      \"aColor\",\r\n      new THREE.InstancedBufferAttribute(new Float32Array(aColor), 3, false),\r\n    );\r\n\r\n    const material = new THREE.ShaderMaterial({\r\n      fragmentShader: carLightsFragment,\r\n      vertexShader: carLightsVertex,\r\n      transparent: true,\r\n      uniforms: Object.assign(\r\n        {\r\n          uTime: { value: 0 },\r\n          uTravelLength: { value: options.length },\r\n          uFade: { value: this.fade },\r\n        },\r\n        this.webgl.fogUniforms,\r\n        (typeof this.options.distortion === \"object\" ? this.options.distortion.uniforms : {}) || {},\r\n      ),\r\n    });\r\n\r\n    material.onBeforeCompile = (shader) => {\r\n      shader.vertexShader = shader.vertexShader.replace(\r\n        \"#include <getDistortion_vertex>\",\r\n        typeof this.options.distortion === \"object\" ? this.options.distortion.getDistortion : \"\",\r\n      );\r\n    };\r\n\r\n    const mesh = new THREE.Mesh(instanced, material);\r\n    mesh.frustumCulled = false;\r\n    this.webgl.scene.add(mesh);\r\n    this.mesh = mesh;\r\n  }\r\n\r\n  update(time: number) {\r\n    if (this.mesh.material.uniforms.uTime) {\r\n      this.mesh.material.uniforms.uTime.value = time;\r\n    }\r\n  }\r\n}\r\n\r\nclass LightsSticks {\r\n  webgl: LightSpeedApp;\r\n  options: LightSpeedOptions;\r\n  mesh!: THREE.Mesh<THREE.InstancedBufferGeometry, THREE.ShaderMaterial>;\r\n\r\n  constructor(webgl: LightSpeedApp, options: LightSpeedOptions) {\r\n    this.webgl = webgl;\r\n    this.options = options;\r\n  }\r\n\r\n  init() {\r\n    const options = this.options;\r\n    const geometry = new THREE.PlaneGeometry(1, 1);\r\n    const instanced = new THREE.InstancedBufferGeometry().copy(\r\n      geometry as any,\r\n    ) as THREE.InstancedBufferGeometry;\r\n    const totalSticks = options.totalSideLightSticks;\r\n    instanced.instanceCount = totalSticks;\r\n\r\n    const stickoffset = options.length / (totalSticks - 1);\r\n    const aOffset: number[] = [];\r\n    const aColor: number[] = [];\r\n    const aMetrics: number[] = [];\r\n\r\n    let colorArray: THREE.Color[];\r\n    if (Array.isArray(options.colors.sticks)) {\r\n      colorArray = options.colors.sticks.map((c) => new THREE.Color(c));\r\n    } else {\r\n      colorArray = [new THREE.Color(options.colors.sticks)];\r\n    }\r\n\r\n    for (let i = 0; i < totalSticks; i++) {\r\n      const width = random(options.lightStickWidth);\r\n      const height = random(options.lightStickHeight);\r\n      aOffset.push((i - 1) * stickoffset * 2 + stickoffset * Math.random());\r\n\r\n      const color = pickRandom<THREE.Color>(colorArray);\r\n      aColor.push(color.r);\r\n      aColor.push(color.g);\r\n      aColor.push(color.b);\r\n\r\n      aMetrics.push(width);\r\n      aMetrics.push(height);\r\n    }\r\n\r\n    instanced.setAttribute(\r\n      \"aOffset\",\r\n      new THREE.InstancedBufferAttribute(new Float32Array(aOffset), 1, false),\r\n    );\r\n    instanced.setAttribute(\r\n      \"aColor\",\r\n      new THREE.InstancedBufferAttribute(new Float32Array(aColor), 3, false),\r\n    );\r\n    instanced.setAttribute(\r\n      \"aMetrics\",\r\n      new THREE.InstancedBufferAttribute(new Float32Array(aMetrics), 2, false),\r\n    );\r\n\r\n    const material = new THREE.ShaderMaterial({\r\n      fragmentShader: sideSticksFragment,\r\n      vertexShader: sideSticksVertex,\r\n      side: THREE.DoubleSide,\r\n      uniforms: Object.assign(\r\n        {\r\n          uTravelLength: { value: options.length },\r\n          uTime: { value: 0 },\r\n        },\r\n        this.webgl.fogUniforms,\r\n        (typeof options.distortion === \"object\" ? options.distortion.uniforms : {}) || {},\r\n      ),\r\n    });\r\n\r\n    material.onBeforeCompile = (shader) => {\r\n      shader.vertexShader = shader.vertexShader.replace(\r\n        \"#include <getDistortion_vertex>\",\r\n        typeof this.options.distortion === \"object\" ? this.options.distortion.getDistortion : \"\",\r\n      );\r\n    };\r\n\r\n    const mesh = new THREE.Mesh(instanced, material);\r\n    mesh.frustumCulled = false;\r\n    this.webgl.scene.add(mesh);\r\n    this.mesh = mesh;\r\n  }\r\n\r\n  update(time: number) {\r\n    if (this.mesh.material.uniforms.uTime) {\r\n      this.mesh.material.uniforms.uTime.value = time;\r\n    }\r\n  }\r\n}\r\n\r\nclass Road {\r\n  webgl: LightSpeedApp;\r\n  options: LightSpeedOptions;\r\n  uTime: { value: number };\r\n  leftRoadWay!: THREE.Mesh;\r\n  rightRoadWay!: THREE.Mesh;\r\n  island!: THREE.Mesh;\r\n\r\n  constructor(webgl: LightSpeedApp, options: LightSpeedOptions) {\r\n    this.webgl = webgl;\r\n    this.options = options;\r\n    this.uTime = { value: 0 };\r\n  }\r\n\r\n  createPlane(side: number, width: number, isRoad: boolean) {\r\n    const options = this.options;\r\n    const segments = 100;\r\n    const geometry = new THREE.PlaneGeometry(\r\n      isRoad ? options.roadWidth : options.islandWidth,\r\n      options.length,\r\n      20,\r\n      segments,\r\n    );\r\n\r\n    let uniforms: Record<string, { value: any }> = {\r\n      uTravelLength: { value: options.length },\r\n      uColor: {\r\n        value: new THREE.Color(isRoad ? options.colors.roadColor : options.colors.islandColor),\r\n      },\r\n      uTime: this.uTime,\r\n    };\r\n\r\n    if (isRoad) {\r\n      uniforms = Object.assign(uniforms, {\r\n        uLanes: { value: options.lanesPerRoad },\r\n        uBrokenLinesColor: {\r\n          value: new THREE.Color(options.colors.brokenLines),\r\n        },\r\n        uShoulderLinesColor: {\r\n          value: new THREE.Color(options.colors.shoulderLines),\r\n        },\r\n        uShoulderLinesWidthPercentage: {\r\n          value: options.shoulderLinesWidthPercentage,\r\n        },\r\n        uBrokenLinesLengthPercentage: {\r\n          value: options.brokenLinesLengthPercentage,\r\n        },\r\n        uBrokenLinesWidthPercentage: {\r\n          value: options.brokenLinesWidthPercentage,\r\n        },\r\n      });\r\n    }\r\n\r\n    const material = new THREE.ShaderMaterial({\r\n      fragmentShader: isRoad ? roadFragment : islandFragment,\r\n      vertexShader: roadVertex,\r\n      side: THREE.DoubleSide,\r\n      uniforms: Object.assign(\r\n        uniforms,\r\n        this.webgl.fogUniforms,\r\n        (typeof options.distortion === \"object\" ? options.distortion.uniforms : {}) || {},\r\n      ),\r\n    });\r\n\r\n    material.onBeforeCompile = (shader) => {\r\n      shader.vertexShader = shader.vertexShader.replace(\r\n        \"#include <getDistortion_vertex>\",\r\n        typeof this.options.distortion === \"object\" ? this.options.distortion.getDistortion : \"\",\r\n      );\r\n    };\r\n\r\n    const mesh = new THREE.Mesh(geometry, material);\r\n    mesh.rotation.x = -Math.PI / 2;\r\n    mesh.position.z = -options.length / 2;\r\n    mesh.position.x += (this.options.islandWidth / 2 + options.roadWidth / 2) * side;\r\n\r\n    this.webgl.scene.add(mesh);\r\n    return mesh;\r\n  }\r\n\r\n  init() {\r\n    this.leftRoadWay = this.createPlane(-1, this.options.roadWidth, true);\r\n    this.rightRoadWay = this.createPlane(1, this.options.roadWidth, true);\r\n    this.island = this.createPlane(0, this.options.islandWidth, false);\r\n  }\r\n\r\n  update(time: number) {\r\n    this.uTime.value = time;\r\n  }\r\n}\r\n\r\nfunction resizeRendererToDisplaySize(\r\n  renderer: THREE.WebGLRenderer,\r\n  setSize: (width: number, height: number, updateStyle: boolean) => void,\r\n) {\r\n  const canvas = renderer.domElement;\r\n  const width = canvas.clientWidth;\r\n  const height = canvas.clientHeight;\r\n  const needResize = canvas.width !== width || canvas.height !== height;\r\n  if (needResize) {\r\n    setSize(width, height, false);\r\n  }\r\n  return needResize;\r\n}\r\n\r\nexport class LightSpeedApp {\r\n  container: HTMLElement;\r\n  options: LightSpeedOptions;\r\n  renderer: THREE.WebGLRenderer;\r\n  composer: EffectComposer;\r\n  camera: THREE.PerspectiveCamera;\r\n  scene: THREE.Scene;\r\n  renderPass!: RenderPass;\r\n  bloomPass!: EffectPass;\r\n  clock: THREE.Clock;\r\n  assets: Record<string, any>;\r\n  disposed: boolean;\r\n  road: Road;\r\n  leftCarLights: CarLights;\r\n  rightCarLights: CarLights;\r\n  leftSticks: LightsSticks;\r\n  fogUniforms: Record<string, { value: any }>;\r\n  fovTarget: number;\r\n  speedUpTarget: number;\r\n  speedUp: number;\r\n  timeOffset: number;\r\n\r\n  constructor(container: HTMLElement, options: LightSpeedOptions) {\r\n    this.options = options;\r\n    if (!this.options.distortion) {\r\n      this.options.distortion = {\r\n        uniforms: distortion_uniforms,\r\n        getDistortion: distortion_vertex,\r\n      };\r\n    }\r\n    this.container = container;\r\n\r\n    this.renderer = new THREE.WebGLRenderer({\r\n      antialias: false,\r\n      alpha: true,\r\n    });\r\n    this.renderer.setSize(container.offsetWidth, container.offsetHeight, false);\r\n    this.renderer.setPixelRatio(window.devicePixelRatio);\r\n\r\n    this.renderer.domElement.style.setProperty(\"height\", \"100%\");\r\n    this.renderer.domElement.style.setProperty(\"width\", \"100%\");\r\n\r\n    this.composer = new EffectComposer(this.renderer);\r\n    container.appendChild(this.renderer.domElement);\r\n\r\n    this.camera = new THREE.PerspectiveCamera(\r\n      options.fov,\r\n      container.offsetWidth / container.offsetHeight,\r\n      0.1,\r\n      10000,\r\n    );\r\n    this.camera.position.z = -5;\r\n    this.camera.position.y = 8;\r\n    this.camera.position.x = 0;\r\n\r\n    this.scene = new THREE.Scene();\r\n    this.scene.background = null;\r\n\r\n    const fog = new THREE.Fog(\r\n      options.colors.background,\r\n      options.length * 0.2,\r\n      options.length * 500,\r\n    );\r\n    this.scene.fog = fog;\r\n\r\n    this.fogUniforms = {\r\n      fogColor: { value: fog.color },\r\n      fogNear: { value: fog.near },\r\n      fogFar: { value: fog.far },\r\n    };\r\n\r\n    this.clock = new THREE.Clock();\r\n    this.assets = {};\r\n    this.disposed = false;\r\n\r\n    this.road = new Road(this, options);\r\n    this.leftCarLights = new CarLights(\r\n      this,\r\n      options,\r\n      options.colors.leftCars,\r\n      options.movingAwaySpeed,\r\n      new THREE.Vector2(0, 1 - options.carLightsFade),\r\n    );\r\n    this.rightCarLights = new CarLights(\r\n      this,\r\n      options,\r\n      options.colors.rightCars,\r\n      options.movingCloserSpeed,\r\n      new THREE.Vector2(1, 0 + options.carLightsFade),\r\n    );\r\n    this.leftSticks = new LightsSticks(this, options);\r\n\r\n    this.fovTarget = options.fov;\r\n    this.speedUpTarget = 0;\r\n    this.speedUp = 0;\r\n    this.timeOffset = 0;\r\n\r\n    this.tick = this.tick.bind(this);\r\n    this.init = this.init.bind(this);\r\n    this.setSize = this.setSize.bind(this);\r\n    this.onMouseDown = this.onMouseDown.bind(this);\r\n    this.onMouseUp = this.onMouseUp.bind(this);\r\n\r\n    window.addEventListener(\"resize\", this.onWindowResize.bind(this));\r\n  }\r\n\r\n  onWindowResize() {\r\n    const width = this.container.offsetWidth;\r\n    const height = this.container.offsetHeight;\r\n\r\n    this.renderer.setSize(width, height);\r\n    this.camera.aspect = width / height;\r\n    this.camera.updateProjectionMatrix();\r\n    this.composer.setSize(width, height);\r\n  }\r\n\r\n  initPasses() {\r\n    this.renderPass = new RenderPass(this.scene, this.camera);\r\n    this.bloomPass = new EffectPass(\r\n      this.camera,\r\n      new BloomEffect({\r\n        luminanceThreshold: 0.2,\r\n        luminanceSmoothing: 0,\r\n        resolutionScale: 1,\r\n      }),\r\n    );\r\n\r\n    const smaaPass = new EffectPass(\r\n      this.camera,\r\n      new SMAAEffect({\r\n        preset: SMAAPreset.MEDIUM,\r\n      }),\r\n    );\r\n    this.renderPass.renderToScreen = false;\r\n    this.bloomPass.renderToScreen = false;\r\n    smaaPass.renderToScreen = true;\r\n\r\n    this.composer.addPass(this.renderPass);\r\n    this.composer.addPass(this.bloomPass);\r\n    this.composer.addPass(smaaPass);\r\n  }\r\n\r\n  loadAssets(): Promise<void> {\r\n    const assets = this.assets;\r\n    return new Promise((resolve) => {\r\n      const manager = new THREE.LoadingManager(resolve);\r\n\r\n      const searchImage = new Image();\r\n      const areaImage = new Image();\r\n      assets.smaa = {};\r\n\r\n      searchImage.addEventListener(\"load\", function () {\r\n        assets.smaa.search = this;\r\n        manager.itemEnd(\"smaa-search\");\r\n      });\r\n\r\n      areaImage.addEventListener(\"load\", function () {\r\n        assets.smaa.area = this;\r\n        manager.itemEnd(\"smaa-area\");\r\n      });\r\n\r\n      manager.itemStart(\"smaa-search\");\r\n      manager.itemStart(\"smaa-area\");\r\n\r\n      searchImage.src = SMAAEffect.searchImageDataURL;\r\n      areaImage.src = SMAAEffect.areaImageDataURL;\r\n    });\r\n  }\r\n\r\n  init() {\r\n    this.initPasses();\r\n    const options = this.options;\r\n    this.road.init();\r\n    this.leftCarLights.init();\r\n    this.leftCarLights.mesh.position.setX(-options.roadWidth / 2 - options.islandWidth / 2);\r\n\r\n    this.rightCarLights.init();\r\n    this.rightCarLights.mesh.position.setX(options.roadWidth / 2 + options.islandWidth / 2);\r\n\r\n    this.leftSticks.init();\r\n    this.leftSticks.mesh.position.setX(-(options.roadWidth + options.islandWidth / 2));\r\n\r\n    this.container.addEventListener(\"mousedown\", this.onMouseDown);\r\n    this.container.addEventListener(\"mouseup\", this.onMouseUp);\r\n    this.container.addEventListener(\"mouseout\", this.onMouseUp);\r\n\r\n    this.container.addEventListener(\"touchstart\", this.onTouchStart);\r\n    this.container.addEventListener(\"touchend\", this.onTouchEnd);\r\n\r\n    this.tick();\r\n  }\r\n\r\n  onTouchStart(ev: TouchEvent) {\r\n    if (this.options.onSpeedUp) this.options.onSpeedUp(ev);\r\n    this.fovTarget = this.options.fovSpeedUp;\r\n    this.speedUpTarget = this.options.speedUp;\r\n  }\r\n\r\n  onTouchEnd(ev: TouchEvent) {\r\n    if (this.options.onSlowDown) this.options.onSlowDown(ev);\r\n    this.fovTarget = this.options.fov;\r\n    this.speedUpTarget = 0;\r\n  }\r\n\r\n  onMouseDown(ev: MouseEvent) {\r\n    if (this.options.onSpeedUp) this.options.onSpeedUp(ev);\r\n    this.fovTarget = this.options.fovSpeedUp;\r\n    this.speedUpTarget = this.options.speedUp;\r\n  }\r\n\r\n  onMouseUp(ev: MouseEvent) {\r\n    if (this.options.onSlowDown) this.options.onSlowDown(ev);\r\n    this.fovTarget = this.options.fov;\r\n    this.speedUpTarget = 0;\r\n  }\r\n\r\n  update(delta: number) {\r\n    const lerpPercentage = Math.exp(-(-60 * Math.log2(1 - 0.1)) * delta);\r\n    this.speedUp += lerp(this.speedUp, this.speedUpTarget, lerpPercentage, 0.00001);\r\n    this.timeOffset += this.speedUp * delta;\r\n    const time = this.clock.elapsedTime + this.timeOffset;\r\n\r\n    this.rightCarLights.update(time);\r\n    this.leftCarLights.update(time);\r\n    this.leftSticks.update(time);\r\n    this.road.update(time);\r\n\r\n    let updateCamera = false;\r\n    const fovChange = lerp(this.camera.fov, this.fovTarget, lerpPercentage);\r\n    if (fovChange !== 0) {\r\n      this.camera.fov += fovChange * delta * 6;\r\n      updateCamera = true;\r\n    }\r\n\r\n    if (typeof this.options.distortion === \"object\" && this.options.distortion.getJS) {\r\n      const distortion = this.options.distortion.getJS(0.025, time);\r\n      this.camera.lookAt(\r\n        new THREE.Vector3(\r\n          this.camera.position.x + distortion.x,\r\n          this.camera.position.y + distortion.y,\r\n          this.camera.position.z + distortion.z,\r\n        ),\r\n      );\r\n      updateCamera = true;\r\n    }\r\n\r\n    if (updateCamera) {\r\n      this.camera.updateProjectionMatrix();\r\n    }\r\n  }\r\n\r\n  render(delta: number) {\r\n    this.composer.render(delta);\r\n  }\r\n\r\n  dispose() {\r\n    this.disposed = true;\r\n  }\r\n\r\n  setSize(width: number, height: number, updateStyles: boolean) {\r\n    this.composer.setSize(width, height, updateStyles);\r\n  }\r\n\r\n  tick() {\r\n    if (this.disposed || !this) return;\r\n    if (resizeRendererToDisplaySize(this.renderer, this.setSize)) {\r\n      const canvas = this.renderer.domElement;\r\n      this.camera.aspect = canvas.clientWidth / canvas.clientHeight;\r\n      this.camera.updateProjectionMatrix();\r\n    }\r\n    const delta = this.clock.getDelta();\r\n    this.render(delta);\r\n    this.update(delta);\r\n    requestAnimationFrame(this.tick);\r\n  }\r\n}\r\n"
    },
    {
      "path": "presets.ts",
      "content": "export const lightSpeedPresets = {\r\n  one: {\r\n    onSpeedUp: () => {},\r\n    onSlowDown: () => {},\r\n    distortion: \"deepDistortion\",\r\n    length: 400,\r\n    roadWidth: 18,\r\n    islandWidth: 2,\r\n    lanesPerRoad: 3,\r\n    fov: 90,\r\n    fovSpeedUp: 150,\r\n    speedUp: 2,\r\n    carLightsFade: 0.4,\r\n    totalSideLightSticks: 50,\r\n    lightPairsPerRoadWay: 50,\r\n    shoulderLinesWidthPercentage: 0.05,\r\n    brokenLinesWidthPercentage: 0.1,\r\n    brokenLinesLengthPercentage: 0.5,\r\n    lightStickWidth: [0.12, 0.5],\r\n    lightStickHeight: [1.3, 1.7],\r\n    movingAwaySpeed: [60, 80],\r\n    movingCloserSpeed: [-120, -160],\r\n    carLightsLength: [400 * 0.05, 400 * 0.15],\r\n    carLightsRadius: [0.05, 0.14],\r\n    carWidthPercentage: [0.3, 0.5],\r\n    carShiftX: [-0.2, 0.2],\r\n    carFloorSeparation: [0.05, 1],\r\n    colors: {\r\n      roadColor: 0x080808,\r\n      islandColor: 0x0a0a0a,\r\n      background: 0x000000,\r\n      shoulderLines: 0x131318,\r\n      brokenLines: 0x131318,\r\n      leftCars: [0xff322f, 0xa33010, 0xa81508],\r\n      rightCars: [0xfdfdf0, 0xf3dea0, 0xe2bb88],\r\n      sticks: 0xfdfdf0,\r\n    },\r\n  },\r\n  two: {\r\n    onSpeedUp: () => {},\r\n    onSlowDown: () => {},\r\n    distortion: \"turbulentDistortion\",\r\n    length: 400,\r\n    roadWidth: 9,\r\n    islandWidth: 2,\r\n    lanesPerRoad: 3,\r\n    fov: 90,\r\n    fovSpeedUp: 150,\r\n    speedUp: 2,\r\n    carLightsFade: 0.4,\r\n    totalSideLightSticks: 50,\r\n    lightPairsPerRoadWay: 50,\r\n    shoulderLinesWidthPercentage: 0.05,\r\n    brokenLinesWidthPercentage: 0.1,\r\n    brokenLinesLengthPercentage: 0.5,\r\n    lightStickWidth: [0.12, 0.5],\r\n    lightStickHeight: [1.3, 1.7],\r\n    movingAwaySpeed: [60, 80],\r\n    movingCloserSpeed: [-120, -160],\r\n    carLightsLength: [400 * 0.05, 400 * 0.15],\r\n    carLightsRadius: [0.05, 0.14],\r\n    carWidthPercentage: [0.3, 0.5],\r\n    carShiftX: [-0.2, 0.2],\r\n    carFloorSeparation: [0.05, 1],\r\n    colors: {\r\n      roadColor: 0x080808,\r\n      islandColor: 0x0a0a0a,\r\n      background: 0x000000,\r\n      shoulderLines: 0x131318,\r\n      brokenLines: 0x131318,\r\n      /***  Only these colors can be an array ***/\r\n      leftCars: [0xdc5b20, 0xdca320, 0xdc2020],\r\n      rightCars: [0x334bf7, 0xe5e6ed, 0xbfc6f3],\r\n      sticks: 0xc5e8eb,\r\n    },\r\n  },\r\n  three: {\r\n    onSpeedUp: () => {},\r\n    onSlowDown: () => {},\r\n    distortion: \"LongRaceDistortion\",\r\n    length: 400,\r\n    roadWidth: 10,\r\n    islandWidth: 5,\r\n    lanesPerRoad: 2,\r\n    fov: 90,\r\n    fovSpeedUp: 150,\r\n    speedUp: 2,\r\n    carLightsFade: 0.4,\r\n    totalSideLightSticks: 50,\r\n    lightPairsPerRoadWay: 70,\r\n    shoulderLinesWidthPercentage: 0.05,\r\n    brokenLinesWidthPercentage: 0.1,\r\n    brokenLinesLengthPercentage: 0.5,\r\n    lightStickWidth: [0.12, 0.5],\r\n    lightStickHeight: [1.3, 1.7],\r\n    movingAwaySpeed: [60, 80],\r\n    movingCloserSpeed: [-120, -160],\r\n    carLightsLength: [400 * 0.05, 400 * 0.15],\r\n    carLightsRadius: [0.05, 0.14],\r\n    carWidthPercentage: [0.3, 0.5],\r\n    carShiftX: [-0.2, 0.2],\r\n    carFloorSeparation: [0.05, 1],\r\n    colors: {\r\n      roadColor: 0x080808,\r\n      islandColor: 0x0a0a0a,\r\n      background: 0x000000,\r\n      shoulderLines: 0x131318,\r\n      brokenLines: 0x131318,\r\n      leftCars: [0xff5f73, 0xe74d60, 0xff102a],\r\n      rightCars: [0xa4e3e6, 0x80d1d4, 0x53c2c6],\r\n      sticks: 0xa4e3e6,\r\n    },\r\n  },\r\n  four: {\r\n    onSpeedUp: () => {},\r\n    onSlowDown: () => {},\r\n    distortion: \"xyDistortion\",\r\n    length: 400,\r\n    roadWidth: 9,\r\n    islandWidth: 2,\r\n    lanesPerRoad: 3,\r\n    fov: 90,\r\n    fovSpeedUp: 150,\r\n    speedUp: 3,\r\n    carLightsFade: 0.4,\r\n    totalSideLightSticks: 50,\r\n    lightPairsPerRoadWay: 30,\r\n    shoulderLinesWidthPercentage: 0.05,\r\n    brokenLinesWidthPercentage: 0.1,\r\n    brokenLinesLengthPercentage: 0.5,\r\n    lightStickWidth: [0.02, 0.05],\r\n    lightStickHeight: [0.3, 0.7],\r\n    movingAwaySpeed: [20, 50],\r\n    movingCloserSpeed: [-150, -230],\r\n    carLightsLength: [400 * 0.05, 400 * 0.2],\r\n    carLightsRadius: [0.03, 0.08],\r\n    carWidthPercentage: [0.1, 0.5],\r\n    carShiftX: [-0.5, 0.5],\r\n    carFloorSeparation: [0, 0.1],\r\n    colors: {\r\n      roadColor: 0x080808,\r\n      islandColor: 0x0a0a0a,\r\n      background: 0x000000,\r\n      shoulderLines: 0x131318,\r\n      brokenLines: 0x131318,\r\n      leftCars: [0x7d0d1b, 0xa90519, 0xff102a],\r\n      rightCars: [0xf1eece, 0xe6e2b1, 0xdfd98a],\r\n      sticks: 0xf1eece,\r\n    },\r\n  },\r\n  five: {\r\n    onSpeedUp: () => {},\r\n    onSlowDown: () => {},\r\n    distortion: \"mountainDistortion\",\r\n    length: 400,\r\n    roadWidth: 9,\r\n    islandWidth: 2,\r\n    lanesPerRoad: 3,\r\n    fov: 90,\r\n    fovSpeedUp: 150,\r\n    speedUp: 2,\r\n    carLightsFade: 0.4,\r\n    totalSideLightSticks: 50,\r\n    lightPairsPerRoadWay: 50,\r\n    shoulderLinesWidthPercentage: 0.05,\r\n    brokenLinesWidthPercentage: 0.1,\r\n    brokenLinesLengthPercentage: 0.5,\r\n    lightStickWidth: [0.12, 0.5],\r\n    lightStickHeight: [1.3, 1.7],\r\n\r\n    movingAwaySpeed: [60, 80],\r\n    movingCloserSpeed: [-120, -160],\r\n    carLightsLength: [400 * 0.05, 400 * 0.15],\r\n    carLightsRadius: [0.05, 0.14],\r\n    carWidthPercentage: [0.3, 0.5],\r\n    carShiftX: [-0.2, 0.2],\r\n    carFloorSeparation: [0.05, 1],\r\n    colors: {\r\n      roadColor: 0x080808,\r\n      islandColor: 0x0a0a0a,\r\n      background: 0x000000,\r\n      shoulderLines: 0x131318,\r\n      brokenLines: 0x131318,\r\n      leftCars: [0xff102a, 0xeb383e, 0xff102a],\r\n      rightCars: [0xdadafa, 0xbebae3, 0x8f97e4],\r\n      sticks: 0xdadafa,\r\n    },\r\n  },\r\n  six: {\r\n    onSpeedUp: () => {},\r\n    onSlowDown: () => {},\r\n    distortion: \"turbulentDistortion\",\r\n    length: 400,\r\n    roadWidth: 10,\r\n    islandWidth: 2,\r\n    lanesPerRoad: 3,\r\n    fov: 90,\r\n    fovSpeedUp: 150,\r\n    speedUp: 2,\r\n    carLightsFade: 0.4,\r\n    totalSideLightSticks: 20,\r\n    lightPairsPerRoadWay: 40,\r\n    shoulderLinesWidthPercentage: 0.05,\r\n    brokenLinesWidthPercentage: 0.1,\r\n    brokenLinesLengthPercentage: 0.5,\r\n    lightStickWidth: [0.12, 0.5],\r\n    lightStickHeight: [1.3, 1.7],\r\n    movingAwaySpeed: [60, 80],\r\n    movingCloserSpeed: [-120, -160],\r\n    carLightsLength: [400 * 0.03, 400 * 0.2],\r\n    carLightsRadius: [0.05, 0.14],\r\n    carWidthPercentage: [0.3, 0.5],\r\n    carShiftX: [-0.8, 0.8],\r\n    carFloorSeparation: [0, 5],\r\n    colors: {\r\n      roadColor: 0x080808,\r\n      islandColor: 0x0a0a0a,\r\n      background: 0x000000,\r\n      shoulderLines: 0x131318,\r\n      brokenLines: 0x131318,\r\n      leftCars: [0xd856bf, 0x6750a2, 0xc247ac],\r\n      rightCars: [0x03b3c3, 0x0e5ea5, 0x324555],\r\n      sticks: 0x03b3c3,\r\n    },\r\n  },\r\n};\r\n"
    },
    {
      "path": "shaders.ts",
      "content": "import * as THREE from \"three\";\r\n\r\nexport const roadBaseFragment = `\r\n  #define USE_FOG;\r\n  varying vec2 vUv; \r\n  uniform vec3 uColor;\r\n  uniform float uTime;\r\n  #include <roadMarkings_vars>\r\n  ${THREE.ShaderChunk.fog_pars_fragment}\r\n  void main() {\r\n    vec2 uv = vUv;\r\n    vec3 color = vec3(uColor);\r\n    #include <roadMarkings_fragment>\r\n    gl_FragColor = vec4(color, 1.);\r\n    ${THREE.ShaderChunk.fog_fragment}\r\n  }\r\n`;\r\n\r\nexport const islandFragment = roadBaseFragment\r\n  .replace(\"#include <roadMarkings_fragment>\", \"\")\r\n  .replace(\"#include <roadMarkings_vars>\", \"\");\r\n\r\nexport const roadMarkings_vars = `\r\n  uniform float uLanes;\r\n  uniform vec3 uBrokenLinesColor;\r\n  uniform vec3 uShoulderLinesColor;\r\n  uniform float uShoulderLinesWidthPercentage;\r\n  uniform float uBrokenLinesWidthPercentage;\r\n  uniform float uBrokenLinesLengthPercentage;\r\n  highp float random(vec2 co) {\r\n    highp float a = 12.9898;\r\n    highp float b = 78.233;\r\n    highp float c = 43758.5453;\r\n    highp float dt = dot(co.xy, vec2(a, b));\r\n    highp float sn = mod(dt, 3.14);\r\n    return fract(sin(sn) * c);\r\n  }\r\n`;\r\n\r\nexport const roadMarkings_fragment = `\r\n  uv.y = mod(uv.y + uTime * 0.05, 1.);\r\n  float laneWidth = 1.0 / uLanes;\r\n  float brokenLineWidth = laneWidth * uBrokenLinesWidthPercentage;\r\n  float laneEmptySpace = 1. - uBrokenLinesLengthPercentage;\r\n\r\n  float brokenLines = step(1.0 - brokenLineWidth, fract(uv.x * 2.0)) * step(laneEmptySpace, fract(uv.y * 10.0));\r\n  float sideLines = step(1.0 - brokenLineWidth, fract((uv.x - laneWidth * (uLanes - 1.0)) * 2.0)) + step(brokenLineWidth, uv.x);\r\n\r\n  brokenLines = mix(brokenLines, sideLines, uv.x);\r\n  // color = mix(color, uBrokenLinesColor, brokenLines);\r\n\r\n  // vec2 noiseFreq = vec2(4., 7000.);\r\n  // float roadNoise = random(floor(uv * noiseFreq) / noiseFreq) * 0.02 - 0.01; \r\n  // color += roadNoise;\r\n`;\r\n\r\nexport const roadFragment = roadBaseFragment\r\n  .replace(\"#include <roadMarkings_fragment>\", roadMarkings_fragment)\r\n  .replace(\"#include <roadMarkings_vars>\", roadMarkings_vars);\r\n\r\nexport const roadVertex = `\r\n  #define USE_FOG;\r\n  uniform float uTime;\r\n  ${THREE.ShaderChunk.fog_pars_vertex}\r\n  uniform float uTravelLength;\r\n  varying vec2 vUv; \r\n  #include <getDistortion_vertex>\r\n  void main() {\r\n    vec3 transformed = position.xyz;\r\n    vec3 distortion = getDistortion((transformed.y + uTravelLength / 2.) / uTravelLength);\r\n    transformed.x += distortion.x;\r\n    transformed.z += distortion.y;\r\n    transformed.y += -1. * distortion.z;  \r\n    \r\n    vec4 mvPosition = modelViewMatrix * vec4(transformed, 1.);\r\n    gl_Position = projectionMatrix * mvPosition;\r\n    vUv = uv;\r\n    ${THREE.ShaderChunk.fog_vertex}\r\n  }\r\n`;\r\n\r\nexport const carLightsFragment = `\r\n  #define USE_FOG;\r\n  ${THREE.ShaderChunk.fog_pars_fragment}\r\n  varying vec3 vColor;\r\n  varying vec2 vUv; \r\n  uniform vec2 uFade;\r\n  void main() {\r\n    vec3 color = vec3(vColor);\r\n    float alpha = smoothstep(uFade.x, uFade.y, vUv.x);\r\n    gl_FragColor = vec4(color, alpha);\r\n    if (gl_FragColor.a < 0.0001) discard;\r\n    ${THREE.ShaderChunk.fog_fragment}\r\n  }\r\n`;\r\n\r\nexport const carLightsVertex = `\r\n  #define USE_FOG;\r\n  ${THREE.ShaderChunk.fog_pars_vertex}\r\n  attribute vec3 aOffset;\r\n  attribute vec3 aMetrics;\r\n  attribute vec3 aColor;\r\n  uniform float uTravelLength;\r\n  uniform float uTime;\r\n  varying vec2 vUv; \r\n  varying vec3 vColor; \r\n  #include <getDistortion_vertex>\r\n  void main() {\r\n    vec3 transformed = position.xyz;\r\n    float radius = aMetrics.r;\r\n    float myLength = aMetrics.g;\r\n    float speed = aMetrics.b;\r\n\r\n    transformed.xy *= radius;\r\n    transformed.z *= myLength;\r\n\r\n    transformed.z += myLength - mod(uTime * speed + aOffset.z, uTravelLength);\r\n    transformed.xy += aOffset.xy;\r\n\r\n    float progress = abs(transformed.z / uTravelLength);\r\n    transformed.xyz += getDistortion(progress);\r\n\r\n    vec4 mvPosition = modelViewMatrix * vec4(transformed, 1.);\r\n    gl_Position = projectionMatrix * mvPosition;\r\n    vUv = uv;\r\n    vColor = aColor;\r\n    ${THREE.ShaderChunk.fog_vertex}\r\n  }\r\n`;\r\n\r\nexport const sideSticksVertex = `\r\n  #define USE_FOG;\r\n  ${THREE.ShaderChunk.fog_pars_vertex}\r\n  attribute float aOffset;\r\n  attribute vec3 aColor;\r\n  attribute vec2 aMetrics;\r\n  uniform float uTravelLength;\r\n  uniform float uTime;\r\n  varying vec3 vColor;\r\n  mat4 rotationY( in float angle ) {\r\n    return mat4(\r\n      cos(angle),\t\t0,\t\tsin(angle),\t0,\r\n      0,\t\t        1.0,\t0,\t\t\t0,\r\n      -sin(angle),\t    0,\t\tcos(angle),\t0,\r\n      0, \t\t        0,\t\t0,\t\t\t1\r\n    );\r\n  }\r\n  #include <getDistortion_vertex>\r\n  void main(){\r\n    vec3 transformed = position.xyz;\r\n    float width = aMetrics.x;\r\n    float height = aMetrics.y;\r\n\r\n    transformed.xy *= vec2(width, height);\r\n    float time = mod(uTime * 60. * 2. + aOffset, uTravelLength);\r\n\r\n    transformed = (rotationY(3.14/2.) * vec4(transformed,1.)).xyz;\r\n    transformed.z += - uTravelLength + time;\r\n\r\n    float progress = abs(transformed.z / uTravelLength);\r\n    transformed.xyz += getDistortion(progress);\r\n\r\n    transformed.y += height / 2.;\r\n    transformed.x += -width / 2.;\r\n    vec4 mvPosition = modelViewMatrix * vec4(transformed, 1.);\r\n    gl_Position = projectionMatrix * mvPosition;\r\n    vColor = aColor;\r\n    ${THREE.ShaderChunk.fog_vertex}\r\n  }\r\n`;\r\n\r\nexport const sideSticksFragment = `\r\n  #define USE_FOG;\r\n  ${THREE.ShaderChunk.fog_pars_fragment}\r\n  varying vec3 vColor;\r\n  void main(){\r\n    vec3 color = vec3(vColor);\r\n    gl_FragColor = vec4(color,1.);\r\n    ${THREE.ShaderChunk.fog_fragment}\r\n  }\r\n`;\r\n\r\nexport const distortion_vertex = `\r\n  #define PI 3.14159265358979\r\n  uniform vec2 uDistortionX;\r\n  uniform vec2 uDistortionY;\r\n  float nsin(float val){\r\n    return sin(val) * 0.5 + 0.5;\r\n  }\r\n  vec3 getDistortion(float progress){\r\n    progress = clamp(progress, 0., 1.);\r\n    float xAmp = uDistortionX.r;\r\n    float xFreq = uDistortionX.g;\r\n    float yAmp = uDistortionY.r;\r\n    float yFreq = uDistortionY.g;\r\n    return vec3( \r\n      xAmp * nsin(progress * PI * xFreq - PI / 2.),\r\n      yAmp * nsin(progress * PI * yFreq - PI / 2.),\r\n      0.\r\n    );\r\n  }\r\n`;\r\n"
    }
  ],
  "fileCount": 5,
  "contentHash": "637a99acd13f514c6fb6420d5326a124dd6a41bd"
}
