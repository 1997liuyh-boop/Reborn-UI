{
  "name": "sparkles",
  "dependencies": [
    "@vueuse/core"
  ],
  "files": [
    {
      "path": "index.ts",
      "content": "export { default as Sparkles } from \"./Sparkles.vue\";\r\n"
    },
    {
      "path": "Sparkles.vue",
      "content": "<template>\r\n  <div\r\n    ref=\"containerRef\"\r\n    class=\"relative size-full overflow-hidden will-change-transform\"\r\n    :style=\"{ background }\"\r\n  >\r\n    <canvas\r\n      ref=\"canvasRef\"\r\n      class=\"absolute inset-0 size-full\"\r\n    />\r\n  </div>\r\n</template>\r\n\r\n<script setup lang=\"ts\">\r\nimport { useRafFn, templateRef } from \"@vueuse/core\";\r\nimport { ref, onMounted, onBeforeUnmount } from \"vue\";\r\n\r\ninterface Props {\r\n  background?: string;\r\n  particleColor?: string;\r\n  minSize?: number;\r\n  maxSize?: number;\r\n  speed?: number;\r\n  particleDensity?: number;\r\n}\r\n\r\ninterface Particle {\r\n  x: number;\r\n  y: number;\r\n  size: number;\r\n  opacity: number;\r\n  vx: number;\r\n  vy: number;\r\n  phase: number;\r\n  phaseSpeed: number;\r\n}\r\n\r\nconst props = withDefaults(defineProps<Props>(), {\r\n  background: \"#0d47a1\",\r\n  particleColor: \"#ffffff\",\r\n  minSize: 1,\r\n  maxSize: 3,\r\n  speed: 4,\r\n  particleDensity: 120,\r\n});\r\n\r\nconst containerRef = templateRef<HTMLElement | null>(\"containerRef\");\r\nconst canvasRef = templateRef<HTMLCanvasElement | null>(\"canvasRef\");\r\nconst particles = ref<Particle[]>([]);\r\nconst ctx = ref<CanvasRenderingContext2D | null>(null);\r\n\r\n// Adjust canvas size on mount and resize\r\nfunction resizeCanvas() {\r\n  if (!canvasRef.value || !containerRef.value) return;\r\n\r\n  const dpr = window.devicePixelRatio || 1;\r\n  const rect = containerRef.value.getBoundingClientRect();\r\n\r\n  canvasRef.value.width = rect.width * dpr;\r\n  canvasRef.value.height = rect.height * dpr;\r\n\r\n  if (ctx.value) {\r\n    ctx.value.scale(dpr, dpr);\r\n  }\r\n}\r\n\r\nfunction generateParticles(): void {\r\n  const newParticles: Particle[] = [];\r\n  const count = props.particleDensity;\r\n\r\n  for (let i = 0; i < count; i++) {\r\n    const baseSpeed = 0.05;\r\n    const speedVariance = Math.random() * 0.3 + 0.7;\r\n\r\n    newParticles.push({\r\n      x: Math.random() * 100,\r\n      y: Math.random() * 100,\r\n      size: Math.random() * (props.maxSize - props.minSize) + props.minSize,\r\n      opacity: Math.random() * 0.5 + 0.3,\r\n      vx: (Math.random() - 0.5) * baseSpeed * speedVariance * props.speed,\r\n      vy: ((Math.random() - 0.5) * baseSpeed - baseSpeed * 0.3) * speedVariance * props.speed,\r\n      phase: Math.random() * Math.PI * 2,\r\n      phaseSpeed: 0.015,\r\n    });\r\n  }\r\n\r\n  particles.value = newParticles;\r\n}\r\n\r\nfunction updateAndDrawParticles() {\r\n  if (!ctx.value || !canvasRef.value) return;\r\n\r\n  const canvas = canvasRef.value;\r\n  ctx.value.clearRect(0, 0, canvas.width, canvas.height);\r\n\r\n  particles.value = particles.value.map((particle) => {\r\n    let newX = particle.x + particle.vx;\r\n    let newY = particle.y + particle.vy;\r\n\r\n    if (newX < -2) newX = 102;\r\n    if (newX > 102) newX = -2;\r\n    if (newY < -2) newY = 102;\r\n    if (newY > 102) newY = -2;\r\n\r\n    const newPhase = (particle.phase + particle.phaseSpeed) % (Math.PI * 2);\r\n    const opacity = 0.3 + (Math.sin(newPhase) * 0.3 + 0.3);\r\n\r\n    // Draw particle\r\n    ctx.value!.beginPath();\r\n    ctx.value!.arc(\r\n      (newX * canvas.width) / 100,\r\n      (newY * canvas.height) / 100,\r\n      particle.size,\r\n      0,\r\n      Math.PI * 2,\r\n    );\r\n    ctx.value!.fillStyle = `${props.particleColor}${Math.floor(opacity * 255)\r\n      .toString(16)\r\n      .padStart(2, \"0\")}`;\r\n    ctx.value!.fill();\r\n\r\n    return {\r\n      ...particle,\r\n      x: newX,\r\n      y: newY,\r\n      phase: newPhase,\r\n      opacity,\r\n    };\r\n  });\r\n}\r\n\r\nconst { pause, resume } = useRafFn(updateAndDrawParticles, { immediate: false });\r\n\r\n// Handle window resize\r\nlet resizeObserver: ResizeObserver | undefined;\r\n\r\nonMounted(() => {\r\n  if (!canvasRef.value) return;\r\n\r\n  ctx.value = canvasRef.value.getContext(\"2d\");\r\n  resizeCanvas();\r\n  generateParticles();\r\n\r\n  // Set up resize observer\r\n  resizeObserver = new ResizeObserver(resizeCanvas);\r\n  if (containerRef.value) {\r\n    resizeObserver.observe(containerRef.value);\r\n  }\r\n\r\n  resume();\r\n});\r\n\r\nonBeforeUnmount(() => {\r\n  pause();\r\n  if (resizeObserver && containerRef.value) {\r\n    resizeObserver.unobserve(containerRef.value);\r\n  }\r\n});\r\n</script>\r\n",
      "target": "web"
    },
    {
      "path": "Sparkles.vue",
      "content": "<template>\r\n  <view\r\n    ref=\"containerRef\"\r\n    class=\"relative size-full overflow-hidden will-change-transform\"\r\n    :style=\"{ background }\"\r\n  >\r\n    <canvas\r\n      ref=\"canvasRef\"\r\n      class=\"absolute inset-0 size-full\"\r\n    />\r\n  </view>\r\n</template>\r\n\r\n<script setup lang=\"ts\">\r\nimport { useRafFn, templateRef } from \"@vueuse/core\";\r\nimport { ref, onMounted, onBeforeUnmount } from \"vue\";\r\n\r\ninterface Props {\r\n  background?: string;\r\n  particleColor?: string;\r\n  minSize?: number;\r\n  maxSize?: number;\r\n  speed?: number;\r\n  particleDensity?: number;\r\n}\r\n\r\ninterface Particle {\r\n  x: number;\r\n  y: number;\r\n  size: number;\r\n  opacity: number;\r\n  vx: number;\r\n  vy: number;\r\n  phase: number;\r\n  phaseSpeed: number;\r\n}\r\n\r\nconst props = withDefaults(defineProps<Props>(), {\r\n  background: \"#0d47a1\",\r\n  particleColor: \"#ffffff\",\r\n  minSize: 1,\r\n  maxSize: 3,\r\n  speed: 4,\r\n  particleDensity: 120,\r\n});\r\n\r\nconst containerRef = templateRef<HTMLElement | null>(\"containerRef\");\r\nconst canvasRef = templateRef<HTMLCanvasElement | null>(\"canvasRef\");\r\nconst particles = ref<Particle[]>([]);\r\nconst ctx = ref<CanvasRenderingContext2D | null>(null);\r\n\r\n// Adjust canvas size on mount and resize\r\nfunction resizeCanvas() {\r\n  if (!canvasRef.value || !containerRef.value) return;\r\n\r\n  const dpr = window.devicePixelRatio || 1;\r\n  const rect = containerRef.value.getBoundingClientRect();\r\n\r\n  canvasRef.value.width = rect.width * dpr;\r\n  canvasRef.value.height = rect.height * dpr;\r\n\r\n  if (ctx.value) {\r\n    ctx.value.scale(dpr, dpr);\r\n  }\r\n}\r\n\r\nfunction generateParticles(): void {\r\n  const newParticles: Particle[] = [];\r\n  const count = props.particleDensity;\r\n\r\n  for (let i = 0; i < count; i++) {\r\n    const baseSpeed = 0.05;\r\n    const speedVariance = Math.random() * 0.3 + 0.7;\r\n\r\n    newParticles.push({\r\n      x: Math.random() * 100,\r\n      y: Math.random() * 100,\r\n      size: Math.random() * (props.maxSize - props.minSize) + props.minSize,\r\n      opacity: Math.random() * 0.5 + 0.3,\r\n      vx: (Math.random() - 0.5) * baseSpeed * speedVariance * props.speed,\r\n      vy: ((Math.random() - 0.5) * baseSpeed - baseSpeed * 0.3) * speedVariance * props.speed,\r\n      phase: Math.random() * Math.PI * 2,\r\n      phaseSpeed: 0.015,\r\n    });\r\n  }\r\n\r\n  particles.value = newParticles;\r\n}\r\n\r\nfunction updateAndDrawParticles() {\r\n  if (!ctx.value || !canvasRef.value) return;\r\n\r\n  const canvas = canvasRef.value;\r\n  ctx.value.clearRect(0, 0, canvas.width, canvas.height);\r\n\r\n  particles.value = particles.value.map((particle) => {\r\n    let newX = particle.x + particle.vx;\r\n    let newY = particle.y + particle.vy;\r\n\r\n    if (newX < -2) newX = 102;\r\n    if (newX > 102) newX = -2;\r\n    if (newY < -2) newY = 102;\r\n    if (newY > 102) newY = -2;\r\n\r\n    const newPhase = (particle.phase + particle.phaseSpeed) % (Math.PI * 2);\r\n    const opacity = 0.3 + (Math.sin(newPhase) * 0.3 + 0.3);\r\n\r\n    // Draw particle\r\n    ctx.value!.beginPath();\r\n    ctx.value!.arc(\r\n      (newX * canvas.width) / 100,\r\n      (newY * canvas.height) / 100,\r\n      particle.size,\r\n      0,\r\n      Math.PI * 2,\r\n    );\r\n    ctx.value!.fillStyle = `${props.particleColor}${Math.floor(opacity * 255)\r\n      .toString(16)\r\n      .padStart(2, \"0\")}`;\r\n    ctx.value!.fill();\r\n\r\n    return {\r\n      ...particle,\r\n      x: newX,\r\n      y: newY,\r\n      phase: newPhase,\r\n      opacity,\r\n    };\r\n  });\r\n}\r\n\r\nconst { pause, resume } = useRafFn(updateAndDrawParticles, { immediate: false });\r\n\r\n// Handle window resize\r\nlet resizeObserver: ResizeObserver | undefined;\r\n\r\nonMounted(() => {\r\n  if (!canvasRef.value) return;\r\n\r\n  ctx.value = canvasRef.value.getContext(\"2d\");\r\n  resizeCanvas();\r\n  generateParticles();\r\n\r\n  // Set up resize observer\r\n  resizeObserver = new ResizeObserver(resizeCanvas);\r\n  if (containerRef.value) {\r\n    resizeObserver.observe(containerRef.value);\r\n  }\r\n\r\n  resume();\r\n});\r\n\r\nonBeforeUnmount(() => {\r\n  pause();\r\n  if (resizeObserver && containerRef.value) {\r\n    resizeObserver.unobserve(containerRef.value);\r\n  }\r\n});\r\n</script>\r\n",
      "target": "uniapp"
    }
  ],
  "fileCount": 3,
  "contentHash": "d42138b166fc215e44e4590935e91905db8282f0"
}
