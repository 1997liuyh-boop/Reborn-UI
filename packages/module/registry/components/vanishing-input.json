{
  "name": "vanishing-input",
  "dependencies": [
    "@vueuse/core"
  ],
  "files": [
    {
      "path": "index.ts",
      "content": "export { default as VanishingInput } from \"./VanishingInput.vue\";\r\n"
    },
    {
      "path": "VanishingInput.vue",
      "content": "<template>\r\n  <form\r\n    :class=\"[\r\n      'relative mx-auto h-12 w-full max-w-xl overflow-hidden rounded-full bg-white shadow-[0px_2px_3px_-1px_rgba(0,0,0,0.1),_0px_1px_0px_0px_rgba(25,28,33,0.02),_0px_0px_0px_1px_rgba(25,28,33,0.08)] transition duration-200 dark:bg-zinc-800',\r\n      vanishingText && 'bg-gray-50',\r\n    ]\"\r\n    @submit.prevent=\"handleSubmit\"\r\n  >\r\n    <!-- Canvas Element -->\r\n    <canvas\r\n      ref=\"canvasRef\"\r\n      :class=\"[\r\n        'pointer-events-none absolute left-2 top-[20%] origin-top-left scale-50 pr-20 text-base invert sm:left-8 dark:invert-0',\r\n        animating ? 'opacity-100' : 'opacity-0',\r\n      ]\"\r\n    />\r\n\r\n    <!-- Text Input -->\r\n    <input\r\n      ref=\"inputRef\"\r\n      v-model=\"vanishingText\"\r\n      :disabled=\"animating\"\r\n      type=\"text\"\r\n      class=\"relative z-50 size-full rounded-full border-none bg-transparent pl-4 pr-20 text-sm text-black focus:outline-none focus:ring-0 sm:pl-10 sm:text-base dark:text-white\"\r\n      :class=\"{ 'text-transparent dark:text-transparent': animating }\"\r\n      @keydown.enter=\"handleKeyDown\"\r\n    />\r\n\r\n    <!-- Submit Button -->\r\n    <button\r\n      :disabled=\"!vanishingText\"\r\n      type=\"submit\"\r\n      class=\"absolute right-2 top-1/2 z-50 flex size-8 -translate-y-1/2 items-center justify-center rounded-full bg-black transition duration-200 disabled:bg-gray-100 dark:bg-zinc-900 dark:disabled:bg-zinc-700\"\r\n    >\r\n      <svg\r\n        xmlns=\"http://www.w3.org/2000/svg\"\r\n        width=\"24\"\r\n        height=\"24\"\r\n        viewBox=\"0 0 24 24\"\r\n        fill=\"none\"\r\n        stroke=\"currentColor\"\r\n        stroke-width=\"2\"\r\n        stroke-linecap=\"round\"\r\n        stroke-linejoin=\"round\"\r\n        class=\"size-4 text-gray-300\"\r\n      >\r\n        <path\r\n          stroke=\"none\"\r\n          d=\"M0 0h24v24H0z\"\r\n          fill=\"none\"\r\n        />\r\n        <path\r\n          d=\"M5 12l14 0\"\r\n          :style=\"{\r\n            strokeDasharray: '50%',\r\n            strokeDashoffset: vanishingText ? '0' : '50%',\r\n            transition: 'stroke-dashoffset 0.3s linear',\r\n          }\"\r\n        />\r\n        <path d=\"M13 18l6 -6\" />\r\n        <path d=\"M13 6l6 6\" />\r\n      </svg>\r\n    </button>\r\n\r\n    <!-- Placeholder Text -->\r\n    <div class=\"pointer-events-none absolute inset-0 flex items-center rounded-full\">\r\n      <Transition\r\n        v-show=\"!vanishingText\"\r\n        mode=\"out-in\"\r\n        enter-active-class=\"transition duration-300 ease-out\"\r\n        leave-active-class=\"transition duration-300 ease-in\"\r\n        enter-from-class=\"opacity-0 translate-y-4\"\r\n        enter-to-class=\"opacity-100 translate-y-0\"\r\n        leave-from-class=\"opacity-100 translate-y-0\"\r\n        leave-to-class=\"opacity-0 -translate-y-4\"\r\n      >\r\n        <p\r\n          :key=\"currentPlaceholder\"\r\n          class=\"w-[calc(100%-2rem)] truncate pl-4 text-left text-sm font-normal text-neutral-500 sm:pl-10 sm:text-base dark:text-zinc-500\"\r\n        >\r\n          {{ placeholders[currentPlaceholder] }}\r\n        </p>\r\n      </Transition>\r\n    </div>\r\n  </form>\r\n</template>\r\n\r\n<script setup lang=\"ts\">\r\nimport { ref, onMounted, watch, onBeforeUnmount } from \"vue\";\r\nimport { templateRef } from \"@vueuse/core\";\r\n\r\n// Define interfaces for props and data structures\r\ninterface Props {\r\n  placeholders?: string[];\r\n}\r\n\r\ninterface PixelData {\r\n  x: number;\r\n  y: number;\r\n  color: string;\r\n}\r\n\r\ninterface AnimatedPixel extends PixelData {\r\n  r: number;\r\n}\r\n\r\nconst vanishingText = defineModel<string>({\r\n  default: \"\",\r\n});\r\nconst emit = defineEmits([\"submit\", \"change\"]);\r\n\r\nconst canvasRef = templateRef<HTMLCanvasElement>(\"canvasRef\");\r\nconst inputRef = templateRef<HTMLInputElement>(\"inputRef\");\r\n\r\n// normal refs\r\nconst currentPlaceholder = ref<number>(0);\r\nconst animating = ref<boolean>(false);\r\nconst intervalRef = ref<number | null>(null);\r\nconst newDataRef = ref<AnimatedPixel[]>([]);\r\nconst animationFrame = ref<number | null>(null);\r\n\r\n// props\r\nconst props = withDefaults(defineProps<Props>(), {\r\n  placeholders: () => [\"Placeholder 1\", \"Placeholder 2\", \"Placeholder 3\"],\r\n});\r\n\r\n// Focus on input when mounted\r\nonMounted(() => {\r\n  if (!inputRef.value) return;\r\n  inputRef.value.focus();\r\n});\r\n\r\nfunction changePlaceholder(): void {\r\n  intervalRef.value = window.setInterval(() => {\r\n    currentPlaceholder.value = (currentPlaceholder.value + 1) % props.placeholders.length;\r\n  }, 3000);\r\n}\r\n\r\nfunction handleVisibilityChange(): void {\r\n  if (document.visibilityState !== \"visible\" && intervalRef.value) {\r\n    clearInterval(intervalRef.value);\r\n    intervalRef.value = null;\r\n  } else if (document.visibilityState === \"visible\") {\r\n    changePlaceholder();\r\n  }\r\n}\r\n\r\nfunction draw(): void {\r\n  if (!inputRef.value || !canvasRef.value) return;\r\n\r\n  const canvas = canvasRef.value;\r\n  const ctx = canvas.getContext(\"2d\");\r\n  if (!ctx) return;\r\n\r\n  const computedStyles = getComputedStyle(inputRef.value);\r\n\r\n  canvas.width = 800;\r\n  canvas.height = 800;\r\n  ctx.clearRect(0, 0, 800, 800);\r\n\r\n  const fontSize = parseFloat(computedStyles.getPropertyValue(\"font-size\"));\r\n  ctx.font = `${fontSize * 2}px ${computedStyles.fontFamily}`;\r\n  ctx.fillStyle = \"#FFF\";\r\n  ctx.fillText(vanishingText.value, 16, 40);\r\n\r\n  const imageData = ctx.getImageData(0, 0, 800, 800);\r\n  const pixelData = imageData.data;\r\n  const newData: PixelData[] = [];\r\n\r\n  for (let t = 0; t < 800; t++) {\r\n    let i = 4 * t * 800;\r\n    for (let n = 0; n < 800; n++) {\r\n      let e = i + 4 * n;\r\n      if (pixelData[e] !== 0 && pixelData[e + 1] !== 0 && pixelData[e + 2] !== 0) {\r\n        newData.push({\r\n          x: n,\r\n          y: t,\r\n          color: `rgba(${pixelData[e]}, ${pixelData[e + 1]}, ${pixelData[e + 2]}, ${pixelData[e + 3]})`,\r\n        });\r\n      }\r\n    }\r\n  }\r\n  newDataRef.value = newData.map(({ x, y, color }) => ({ x, y, r: 1, color }));\r\n}\r\n\r\nfunction animate(start: number = 0): void {\r\n  animationFrame.value = requestAnimationFrame(() => {\r\n    const newArr: AnimatedPixel[] = [];\r\n    for (const current of newDataRef.value) {\r\n      if (current.x < start) {\r\n        newArr.push(current);\r\n      } else {\r\n        if (current.r <= 0) {\r\n          current.r = 0;\r\n          continue;\r\n        }\r\n        current.x += Math.random() > 0.5 ? 1 : -1;\r\n        current.y += Math.random() > 0.5 ? 1 : -1;\r\n        current.r -= 0.05 * Math.random();\r\n        newArr.push(current);\r\n      }\r\n    }\r\n    newDataRef.value = newArr;\r\n    const ctx = canvasRef.value?.getContext(\"2d\");\r\n    if (ctx) {\r\n      ctx.clearRect(start, 0, 800, 800);\r\n      newDataRef.value.forEach(({ x, y, r, color }) => {\r\n        if (x > start) {\r\n          ctx.beginPath();\r\n          ctx.rect(x, y, r, r);\r\n          ctx.fillStyle = color;\r\n          ctx.strokeStyle = color;\r\n          ctx.stroke();\r\n        }\r\n      });\r\n    }\r\n    if (newDataRef.value.length > 0) {\r\n      animate(start - 8);\r\n    } else {\r\n      vanishingText.value = \"\";\r\n      animating.value = false;\r\n      setTimeout(() => {\r\n        // regain focus after animation\r\n        inputRef.value.focus();\r\n      }, 100);\r\n    }\r\n  });\r\n}\r\n\r\nfunction handleKeyDown(e: KeyboardEvent): void {\r\n  if (vanishingText.value === \"\") return;\r\n  if (e.key === \"Enter\" && !animating.value) {\r\n    vanishAndSubmit();\r\n  }\r\n}\r\n\r\nfunction vanishAndSubmit(): void {\r\n  animating.value = true;\r\n  draw();\r\n  if (vanishingText.value) {\r\n    const maxX = Math.max(...newDataRef.value.map(({ x }) => x));\r\n    animate(maxX);\r\n    emit(\"submit\", vanishingText.value);\r\n  }\r\n}\r\n\r\nfunction handleSubmit(): void {\r\n  vanishAndSubmit();\r\n}\r\n\r\n// Watch for value changes\r\nwatch(vanishingText, (newVal: string) => {\r\n  if (!animating.value) {\r\n    emit(\"change\", { target: { value: newVal } });\r\n  }\r\n});\r\n\r\nonMounted(() => {\r\n  changePlaceholder();\r\n  document.addEventListener(\"visibilitychange\", handleVisibilityChange);\r\n});\r\n\r\nonBeforeUnmount(() => {\r\n  if (intervalRef.value) {\r\n    clearInterval(intervalRef.value);\r\n  }\r\n  if (animationFrame.value) {\r\n    cancelAnimationFrame(animationFrame.value);\r\n  }\r\n  document.removeEventListener(\"visibilitychange\", handleVisibilityChange);\r\n});\r\n</script>\r\n"
    }
  ],
  "fileCount": 2,
  "contentHash": "ba5236b6bf224bbe235f66c6e01d6b319cf35615"
}
