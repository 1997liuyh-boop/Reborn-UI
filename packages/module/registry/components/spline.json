{
  "name": "spline",
  "dependencies": [
    "@splinetool/runtime",
    "@vueuse/core"
  ],
  "files": [
    {
      "path": "index.ts",
      "content": "export { default as Spline } from \"./Spline.vue\";\r\nexport { default as ParentSize } from \"./ParentSize.vue\";\r\n"
    },
    {
      "path": "ParentSize.vue",
      "content": "<!-- ParentSize.vue -->\r\n<template>\r\n  <div\r\n    ref=\"target\"\r\n    :style=\"mergedStyles\"\r\n    :class=\"cn('w-full h-full', props.class)\"\r\n    v-bind=\"attrsWithoutClassAndStyle\"\r\n  >\r\n    <slot />\r\n  </div>\r\n</template>\r\n\r\n<script setup lang=\"ts\">\r\nimport { ref, reactive, computed, useAttrs } from \"vue\";\r\nimport { useDebounceFn, useResizeObserver } from \"@vueuse/core\";\r\nimport { cn } from \"@/lib/utils\";\r\n\r\nconst props = defineProps({\r\n  class: String,\r\n  debounceTime: {\r\n    type: Number,\r\n    default: 300,\r\n  },\r\n  ignoreDimensions: {\r\n    type: [Array, String],\r\n    default: () => [],\r\n  },\r\n  parentSizeStyles: Object,\r\n  enableDebounceLeadingCall: {\r\n    type: Boolean,\r\n    default: true,\r\n  },\r\n});\r\n\r\nconst attrs = useAttrs();\r\nconst target = ref<HTMLElement | null>(null);\r\nconst state = reactive({\r\n  width: 0,\r\n  height: 0,\r\n  top: 0,\r\n  left: 0,\r\n});\r\n\r\nconst mergedStyles = computed(() => ({\r\n  ...props.parentSizeStyles,\r\n  ...(attrs.style as object),\r\n}));\r\n\r\nconst mergedClass = computed(() => [\"w-full h-full\", props.class]);\r\n\r\nconst attrsWithoutClassAndStyle = computed(() => {\r\n  const { class: _, style: __, ...rest } = attrs;\r\n  return rest;\r\n});\r\n\r\nconst normalizedIgnore = computed(() =>\r\n  Array.isArray(props.ignoreDimensions) ? props.ignoreDimensions : [props.ignoreDimensions],\r\n);\r\n\r\nfunction updateDimensions(rect: DOMRectReadOnly) {\r\n  const { width, height, top, left } = rect;\r\n  const newState = { width, height, top, left };\r\n\r\n  const hasChange = Object.keys(newState).some(\r\n    (key) => state[key as keyof typeof state] !== newState[key as keyof typeof state],\r\n  );\r\n\r\n  if (!hasChange) return;\r\n\r\n  const shouldUpdate = !Object.keys(newState).every((key) =>\r\n    normalizedIgnore.value.includes(key as keyof typeof state),\r\n  );\r\n\r\n  if (shouldUpdate) {\r\n    Object.assign(state, newState);\r\n  }\r\n}\r\n\r\nconst debouncedUpdate = useDebounceFn(updateDimensions, props.debounceTime);\r\n\r\nuseResizeObserver(target, (entries) => {\r\n  const entry = entries[0];\r\n  if (entry) debouncedUpdate(entry.contentRect);\r\n});\r\n</script>\r\n"
    },
    {
      "path": "Spline.vue",
      "content": "<template>\r\n  <ParentSize\r\n    :parent-size-styles=\"parentSizeStyles\"\r\n    :debounce-time=\"50\"\r\n    v-bind=\"$attrs\"\r\n  >\r\n    <template #default>\r\n      <canvas\r\n        ref=\"canvasRef\"\r\n        :style=\"canvasStyle\"\r\n      />\r\n      <slot v-if=\"isLoading\" />\r\n    </template>\r\n  </ParentSize>\r\n</template>\r\n\r\n<script setup lang=\"ts\">\r\n/* eslint-disable @typescript-eslint/no-explicit-any */\r\n\r\nimport { ref, onMounted, onUnmounted, computed, watch, nextTick } from \"vue\";\r\nimport { Application, type SplineEventName } from \"@splinetool/runtime\";\r\nimport { useDebounceFn, useIntersectionObserver } from \"@vueuse/core\";\r\nimport ParentSize from \"./ParentSize.vue\";\r\n\r\nconst props = defineProps({\r\n  scene: {\r\n    type: String,\r\n    required: true,\r\n  },\r\n  onLoad: Function,\r\n  renderOnDemand: {\r\n    type: Boolean,\r\n    default: true,\r\n  },\r\n  style: Object,\r\n});\r\n\r\nconst emit = defineEmits([\r\n  \"error\",\r\n  \"spline-mouse-down\",\r\n  \"spline-mouse-up\",\r\n  \"spline-mouse-hover\",\r\n  \"spline-key-down\",\r\n  \"spline-key-up\",\r\n  \"spline-start\",\r\n  \"spline-look-at\",\r\n  \"spline-follow\",\r\n  \"spline-scroll\",\r\n]);\r\n\r\nconst canvasRef = ref<HTMLCanvasElement | null>(null);\r\nconst isLoading = ref(false);\r\nconst splineApp = ref<Application | null>(null);\r\nconst isVisible = ref(true);\r\n\r\n// eslint-disable-next-line func-style\r\nlet cleanup: () => void = () => {};\r\n\r\nconst parentSizeStyles = computed(() => ({\r\n  overflow: \"hidden\",\r\n  ...props.style,\r\n}));\r\n\r\nconst canvasStyle = computed(() => ({\r\n  display: \"block\",\r\n  width: \"100%\",\r\n  height: \"100%\",\r\n}));\r\n\r\n// Use IntersectionObserver to detect when component is visible\r\nconst { stop: stopIntersectionObserver } = useIntersectionObserver(\r\n  canvasRef,\r\n  ([{ isIntersecting }]) => {\r\n    isVisible.value = isIntersecting;\r\n    if (isIntersecting && splineApp.value) {\r\n      // When becoming visible again, force a resize\r\n      nextTick(() => {\r\n        if (canvasRef.value && splineApp.value) {\r\n          splineApp.value.requestRender();\r\n          splineApp.value.setSize(canvasRef.value.clientWidth, canvasRef.value.clientHeight);\r\n        }\r\n      });\r\n    }\r\n  },\r\n  { threshold: 0.1 },\r\n);\r\n\r\nfunction eventHandler(name: SplineEventName, handler?: (e: any) => void) {\r\n  if (!handler || !splineApp.value) return;\r\n  const debouncedHandler = useDebounceFn(handler, 50, { maxWait: 100 });\r\n  splineApp.value.addEventListener(name, debouncedHandler);\r\n  return () => splineApp.value?.removeEventListener(name, debouncedHandler);\r\n}\r\n\r\nasync function initSpline() {\r\n  if (!canvasRef.value) return;\r\n\r\n  isLoading.value = true;\r\n\r\n  try {\r\n    // Clean up previous instance if exists\r\n    if (splineApp.value) {\r\n      splineApp.value.dispose();\r\n      splineApp.value = null;\r\n    }\r\n\r\n    splineApp.value = new Application(canvasRef.value, {\r\n      renderOnDemand: props.renderOnDemand,\r\n    });\r\n\r\n    await splineApp.value.load(props.scene);\r\n\r\n    // Set up event listeners\r\n    const cleanUpFns = [\r\n      eventHandler(\"mouseDown\", (e: any) => emit(\"spline-mouse-down\", e)),\r\n      eventHandler(\"mouseUp\", (e: any) => emit(\"spline-mouse-up\", e)),\r\n      eventHandler(\"mouseHover\", (e: any) => emit(\"spline-mouse-hover\", e)),\r\n      eventHandler(\"keyDown\", (e: any) => emit(\"spline-key-down\", e)),\r\n      eventHandler(\"keyUp\", (e: any) => emit(\"spline-key-up\", e)),\r\n      eventHandler(\"start\", (e: any) => emit(\"spline-start\", e)),\r\n      eventHandler(\"lookAt\", (e: any) => emit(\"spline-look-at\", e)),\r\n      eventHandler(\"follow\", (e: any) => emit(\"spline-follow\", e)),\r\n      eventHandler(\"scroll\", (e: any) => emit(\"spline-scroll\", e)),\r\n    ].filter(Boolean);\r\n\r\n    isLoading.value = false;\r\n    props.onLoad?.(splineApp.value);\r\n\r\n    return () => {\r\n      cleanUpFns.forEach((fn) => fn?.());\r\n    };\r\n  } catch (err) {\r\n    console.error(\"Spline initialization error:\", err);\r\n    emit(\"error\", err);\r\n    isLoading.value = false;\r\n    return () => {};\r\n  }\r\n}\r\n\r\nasync function initialize() {\r\n  cleanup();\r\n  cleanup = (await initSpline()) ?? (() => {});\r\n}\r\n\r\nonMounted(async () => {\r\n  await initialize();\r\n\r\n  // Reinitialize when becoming visible again\r\n  watch(isVisible, (visible) => {\r\n    if (visible) {\r\n      initialize();\r\n    }\r\n  });\r\n});\r\n\r\nonUnmounted(() => {\r\n  stopIntersectionObserver();\r\n  if (splineApp.value) {\r\n    splineApp.value.dispose();\r\n    splineApp.value = null;\r\n  }\r\n});\r\n</script>\r\n"
    }
  ],
  "fileCount": 3,
  "contentHash": "9c20894c397981e2af84dbec7037b92631650daf"
}
