{
  "name": "bg-particle-whirlpool",
  "dependencies": [
    "three"
  ],
  "files": [
    {
      "path": "index.ts",
      "content": "export { default as ParticleWhirlpoolBg } from \"./ParticleWhirlpoolBg.vue\";\r\n"
    },
    {
      "path": "ParticleWhirlpoolBg.vue",
      "content": "<template>\r\n  <div\r\n    ref=\"whirlpoolCanvasContainerRef\"\r\n    :class=\"cn('relative w-full h-full', $props.class)\"\r\n  >\r\n    <canvas\r\n      ref=\"whirlpoolCanvasRef\"\r\n      class=\"size-full\"\r\n    ></canvas>\r\n    <div\r\n      :style=\"{\r\n        '--bubbles-blur': `${blur}px`,\r\n      }\"\r\n      class=\"absolute inset-0 backdrop-blur-[--bubbles-blur]\"\r\n    ></div>\r\n\r\n    <div class=\"absolute inset-0\">\r\n      <slot />\r\n    </div>\r\n  </div>\r\n</template>\r\n\r\n<script lang=\"ts\" setup>\r\nimport {\r\n  Vector3,\r\n  MathUtils,\r\n  AmbientLight,\r\n  BoxGeometry,\r\n  InstancedMesh,\r\n  PointLight,\r\n  WebGLRenderer,\r\n  Scene,\r\n  Object3D,\r\n  Vector2,\r\n  PerspectiveCamera,\r\n  Raycaster,\r\n  Plane,\r\n  MeshBasicMaterial,\r\n  InstancedBufferAttribute,\r\n} from \"three\";\r\nimport { onMounted, onUnmounted, ref } from \"vue\";\r\n\r\nimport { EffectComposer } from \"three/addons/postprocessing/EffectComposer.js\";\r\nimport { RenderPass } from \"three/addons/postprocessing/RenderPass.js\";\r\nimport { UnrealBloomPass } from \"three/addons/postprocessing/UnrealBloomPass.js\";\r\nimport { OrbitControls } from \"three/addons/controls/OrbitControls.js\";\r\nimport { cn } from \"@/lib/utils\";\r\n\r\nconst { randFloat: rnd, randFloatSpread: rndFS } = MathUtils;\r\n\r\ntype Instance = {\r\n  position: Vector3;\r\n  scale: number;\r\n  scaleZ: number;\r\n  velocity: Vector3;\r\n  attraction: number;\r\n  vLimit: number;\r\n};\r\n\r\nconst props = defineProps({\r\n  particleCount: {\r\n    type: Number,\r\n    default: 2000,\r\n  },\r\n  class: String,\r\n  blur: {\r\n    type: Number,\r\n    default: 0,\r\n  },\r\n});\r\n\r\nconst instances: Instance[] = [];\r\nconst target = new Vector3();\r\nconst dummyO = new Object3D();\r\nconst dummyV = new Vector3();\r\nconst pointer = new Vector2();\r\n\r\nconst light = new PointLight(0x0060ff, 0.5);\r\nconst raycaster = new Raycaster();\r\n\r\nlet renderer: WebGLRenderer;\r\nlet scene: Scene;\r\nlet camera: PerspectiveCamera;\r\nlet imesh: InstancedMesh;\r\nlet controls: OrbitControls;\r\nlet effectComposer: EffectComposer;\r\n\r\nconst whirlpoolCanvasContainerRef = ref<HTMLCanvasElement>();\r\nconst whirlpoolCanvasRef = ref<HTMLCanvasElement>();\r\n\r\nloadParticleInstances();\r\n\r\nfunction loadParticleInstances() {\r\n  for (let i = 0; i < props.particleCount; i++) {\r\n    instances.push({\r\n      position: new Vector3(rndFS(200), rndFS(200), rndFS(200)),\r\n      scale: rnd(0.2, 1),\r\n      scaleZ: rnd(0.1, 1),\r\n      velocity: new Vector3(rndFS(2), rndFS(2), rndFS(2)),\r\n      attraction: 0.03 + rnd(-0.01, 0.01),\r\n      vLimit: 1.2 + rnd(-0.1, 0.1),\r\n    });\r\n  }\r\n}\r\n\r\nfunction setupScene() {\r\n  if (!whirlpoolCanvasRef.value) {\r\n    throw new Error(\"Canvas not initialized\");\r\n  }\r\n\r\n  const width = whirlpoolCanvasRef.value.clientWidth;\r\n  const height = whirlpoolCanvasRef.value.clientHeight;\r\n\r\n  // Set Renderer\r\n  renderer = new WebGLRenderer({\r\n    canvas: whirlpoolCanvasRef.value,\r\n    antialias: true,\r\n  });\r\n  renderer.setSize(width, height);\r\n  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));\r\n  renderer.autoClear = false;\r\n\r\n  // Camera\r\n  camera = new PerspectiveCamera();\r\n  camera.aspect = width / height;\r\n  camera.position.set(0, 0, 200);\r\n  camera.updateProjectionMatrix();\r\n\r\n  const ambientLight = new AmbientLight(0x808080);\r\n  const pointLight1 = new PointLight(0xff6000);\r\n\r\n  const pointLight2 = new PointLight(0xff6000, 0.5);\r\n  pointLight2.position.set(100, 0, 0);\r\n\r\n  const pointLight3 = new PointLight(0x0000ff, 0.5);\r\n  pointLight3.position.set(-100, 0, 0);\r\n\r\n  const boxGeometry = new BoxGeometry(2, 2, 10);\r\n  const standardMaterial = new MeshBasicMaterial({\r\n    transparent: true,\r\n    opacity: 0.9,\r\n  });\r\n\r\n  imesh = new InstancedMesh(boxGeometry, standardMaterial, props.particleCount);\r\n\r\n  scene = new Scene();\r\n  scene.add(ambientLight);\r\n  scene.add(pointLight1);\r\n  scene.add(light);\r\n  scene.add(pointLight2);\r\n  scene.add(pointLight3);\r\n\r\n  scene.add(imesh);\r\n\r\n  controls = new OrbitControls(camera, renderer.domElement);\r\n\r\n  effectComposer = new EffectComposer(renderer);\r\n  effectComposer.setSize(width, height);\r\n  effectComposer.addPass(new RenderPass(scene, camera));\r\n\r\n  const unrealBloomPass = new UnrealBloomPass(new Vector2(width, height), 1, 0, 0);\r\n\r\n  effectComposer.addPass(unrealBloomPass);\r\n}\r\n\r\nfunction init() {\r\n  for (let i = 0; i < props.particleCount; i++) {\r\n    const { position, scale, scaleZ } = instances[i];\r\n    dummyO.position.copy(position);\r\n    dummyO.scale.set(scale, scale, scaleZ);\r\n    dummyO.updateMatrix();\r\n    imesh.setMatrixAt(i, dummyO.matrix);\r\n  }\r\n\r\n  const colors = new Float32Array(props.particleCount * 3); // Each color is an RGB triplet\r\n\r\n  for (let i = 0; i < props.particleCount; i++) {\r\n    // Assign random colors\r\n    colors[i * 3] = rnd(0, 1); // Red component\r\n    colors[i * 3 + 1] = rnd(0, 1); // Green component\r\n    colors[i * 3 + 2] = rnd(0, 1); // Blue component\r\n  }\r\n\r\n  imesh.instanceColor = new InstancedBufferAttribute(colors, 3); // Add the colors as an attribute\r\n  imesh.instanceMatrix.needsUpdate = true;\r\n}\r\n\r\nfunction animate() {\r\n  requestAnimationFrame(animate);\r\n  controls.update();\r\n\r\n  light.position.copy(target);\r\n\r\n  for (let i = 0; i < props.particleCount; i++) {\r\n    const { position, scale, scaleZ, velocity, attraction, vLimit } = instances[i];\r\n\r\n    dummyV.copy(target).sub(position).normalize().multiplyScalar(attraction);\r\n\r\n    velocity.add(dummyV).clampScalar(-vLimit, vLimit);\r\n    position.add(velocity);\r\n\r\n    dummyO.position.copy(position);\r\n    dummyO.scale.set(scale, scale, scaleZ);\r\n    dummyO.lookAt(dummyV.copy(position).add(velocity));\r\n    dummyO.updateMatrix();\r\n    imesh.setMatrixAt(i, dummyO.matrix);\r\n  }\r\n  imesh.instanceMatrix.needsUpdate = true;\r\n\r\n  effectComposer.render();\r\n}\r\n\r\nonMounted(() => {\r\n  setupScene();\r\n  init();\r\n  animate();\r\n\r\n  whirlpoolCanvasContainerRef.value?.addEventListener(\"mousemove\", onPointerMove);\r\n  whirlpoolCanvasContainerRef.value?.addEventListener(\"touchmove\", onPointerMove);\r\n  window.addEventListener(\"resize\", onWindowResize);\r\n});\r\n\r\nfunction onPointerMove(event: MouseEvent | TouchEvent) {\r\n  if (!renderer || !camera) return;\r\n\r\n  let clientX: number;\r\n  let clientY: number;\r\n\r\n  // Check if it's a touch event\r\n  if (event instanceof TouchEvent) {\r\n    clientX = event.touches[0].clientX;\r\n    clientY = event.touches[0].clientY;\r\n  } else {\r\n    clientX = (event as MouseEvent).clientX;\r\n    clientY = (event as MouseEvent).clientY;\r\n  }\r\n\r\n  const rect = whirlpoolCanvasContainerRef.value!.getBoundingClientRect();\r\n  const x = clientX - rect.left;\r\n  const y = clientY - rect.top;\r\n\r\n  // Check if the pointer is within the bounds of the canvas\r\n  if (x >= 0 && x <= rect.width && y >= 0 && y <= rect.height) {\r\n    // Pointer is within canvas bounds\r\n    pointer.x = (x / rect.width) * 2 - 1;\r\n    pointer.y = -(y / rect.height) * 2 + 1;\r\n\r\n    // Update the target position in 3D space\r\n    raycaster.setFromCamera(pointer, camera);\r\n    const planeZ = new Plane(new Vector3(0, 0, 1), 0);\r\n    const point = new Vector3();\r\n    raycaster.ray.intersectPlane(planeZ, point);\r\n    target.copy(point);\r\n  } else {\r\n    // Pointer is outside canvas bounds\r\n    // Set target to center of canvas in 3D space\r\n    target.set(0, 0, 0); // Or any default position you prefer\r\n  }\r\n}\r\n\r\nfunction onWindowResize() {\r\n  if (!whirlpoolCanvasRef.value || !renderer || !camera || !effectComposer) return;\r\n\r\n  const width = whirlpoolCanvasContainerRef.value!.clientWidth;\r\n  const height = whirlpoolCanvasContainerRef.value!.clientHeight;\r\n\r\n  // Update camera\r\n  camera.aspect = width / height;\r\n  camera.updateProjectionMatrix();\r\n\r\n  // Update renderer size\r\n  renderer.setSize(width, height);\r\n  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));\r\n\r\n  // Update effect composer size\r\n  effectComposer.setSize(width, height);\r\n}\r\n\r\nonUnmounted(() => {\r\n  window.removeEventListener(\"mousemove\", onPointerMove);\r\n  window.removeEventListener(\"resize\", onWindowResize);\r\n});\r\n</script>\r\n"
    }
  ],
  "fileCount": 2,
  "contentHash": "e3bfe90fe5c7346eed342cb46b509f7cfc72d594"
}
