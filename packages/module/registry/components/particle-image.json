{
  "name": "particle-image",
  "dependencies": [],
  "files": [
    {
      "path": "index.ts",
      "content": "export { default as ParticleImage } from \"./ParticleImage.vue\";\r\n"
    },
    {
      "path": "inspiraImageParticles.d.ts",
      "content": "/**\r\n * Type definitions for inspiraImageParticles\r\n */\r\n\r\n/**\r\n * Options for initializing the InspiraImageParticle class.\r\n */\r\ninterface InspiraImageParticleOptions {\r\n  width?: number;\r\n  height?: number;\r\n  maxWidth?: number;\r\n  maxHeight?: number;\r\n  minWidth?: number;\r\n  minHeight?: number;\r\n  gravity?: number;\r\n  particleGap?: number;\r\n  particleSize?: number;\r\n  layerCount?: number;\r\n  depth?: number;\r\n  rotationDuration?: number;\r\n  growDuration?: number;\r\n  waitDuration?: number;\r\n  shrinkDuration?: number;\r\n  shrinkDistance?: number;\r\n  threeDimensional?: boolean | string;\r\n  lifeCycle?: boolean | string;\r\n  layerDistance?: number;\r\n  initPosition?: \"random\" | \"top\" | \"left\" | \"bottom\" | \"right\" | \"misplaced\" | \"none\";\r\n  initDirection?: \"random\" | \"top\" | \"left\" | \"bottom\" | \"right\" | \"none\";\r\n  fadePosition?: \"explode\" | \"top\" | \"left\" | \"bottom\" | \"right\" | \"random\" | \"none\";\r\n  fadeDirection?: \"random\" | \"top\" | \"left\" | \"bottom\" | \"right\" | \"none\";\r\n  noise?: number;\r\n  disableInteraction?: boolean;\r\n  mouseForce?: number;\r\n  clickStrength?: number;\r\n  color?: string;\r\n  colorArr?: number[];\r\n  image?: HTMLImageElement;\r\n  imageId?: string;\r\n  imageUrl?: string;\r\n  wrapperElement?: HTMLElement;\r\n  canvas?: HTMLCanvasElement;\r\n  context?: CanvasRenderingContext2D | WebGL2RenderingContext | WebGLRenderingContext;\r\n  renderer?: \"default\" | \"webgl\";\r\n  addTimestamp?: boolean;\r\n  responsiveWidth?: boolean;\r\n}\r\n\r\n/**\r\n * Interface for event handling methods.\r\n */\r\nexport interface EventHandlers {\r\n  on(event: string, callback: (params?: unknow) => void): void;\r\n  emit(event: string, params?: unknow): void;\r\n}\r\n\r\n/**\r\n * Interface containing all public property definitions for InspiraImageParticle.\r\n */\r\nexport interface InspiraImageParticleProps {\r\n  // Public Properties\r\n  state: string;\r\n  touches: Array<{ x: number; y: number; z: number; force: number }>;\r\n  colorArr: number[];\r\n  vertices: Float32Array | false;\r\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-function-type\r\n  events: { [key: string]: Function[] };\r\n  canvas?: HTMLCanvasElement;\r\n  context?: CanvasRenderingContext2D | WebGLRenderingContext;\r\n  particles: unknow[];\r\n  origins: unknow[];\r\n  width: number;\r\n  height: number;\r\n  maxWidth?: number;\r\n  maxHeight?: number;\r\n  minWidth?: number;\r\n  minHeight?: number;\r\n  alphaFade: number;\r\n  gravity: number;\r\n  particleGap: number;\r\n  particleSize: number;\r\n  layerCount: number;\r\n  depth: number;\r\n  rotationDuration: number;\r\n  growDuration: number;\r\n  waitDuration: number;\r\n  shrinkDuration: number;\r\n  shrinkDistance: number;\r\n  threeDimensional: boolean;\r\n  lifeCycle: boolean;\r\n  layerDistance: number;\r\n  initPosition: string;\r\n  initDirection: string;\r\n  fadePosition: string;\r\n  fadeDirection: string;\r\n  noise: number;\r\n  disableInteraction: boolean;\r\n  mouseForce: number;\r\n  clickStrength: number;\r\n  imageWidth: number;\r\n  imageHeight: number;\r\n  imageRatio: number;\r\n  srcImage?: HTMLImageElement;\r\n  image?: HTMLImageElement;\r\n  imageUrl: string;\r\n  wrapperElement?: HTMLElement;\r\n  responsiveWidth: boolean;\r\n  renderWidth: number;\r\n  renderHeight: number;\r\n  offsetX: number;\r\n  offsetY: number;\r\n  speed: number;\r\n  gravityFactor: number;\r\n  renderer: \"default\" | \"webgl\";\r\n  color: string;\r\n}\r\n\r\n/**\r\n * InspiraImageParticle class for creating particle animations from images.\r\n */\r\nexport declare class InspiraImageParticle implements InspiraImageParticleProps, EventHandlers {\r\n  constructor(options?: InspiraImageParticleOptions);\r\n\r\n  // Public Methods\r\n  on(event: string, fn: (params?: unknow) => void): void;\r\n  emit(event: string, params?: unknow): void;\r\n\r\n  start(options?: Partial<InspiraImageParticleOptions>): void;\r\n  stop(options?: Partial<InspiraImageParticleOptions>): void;\r\n\r\n  // Private Methods\r\n  private _animate(): void;\r\n  private _onImageLoaded(options: InspiraImageParticleOptions): void;\r\n  private _initImage(options: InspiraImageParticleOptions): void;\r\n  private _initContext(options: InspiraImageParticleOptions): void;\r\n  private _defaultInitContext(options: InspiraImageParticleOptions): void;\r\n  private _webglInitContext(): void;\r\n  private _webglSetAttributes(): void;\r\n  private _updateRotation(): void;\r\n  private _defaultRenderer(): void;\r\n  private _webglRenderer(): void;\r\n  private _calculate(): void;\r\n  private _fade(): void;\r\n  private _initParticles(): void;\r\n  private _initOrigins(): void;\r\n  private _initParticlePosition(origin: unknow, particle: unknow): void;\r\n  private _initParticleDirection(particle: unknow): void;\r\n  private _fadeOriginPosition(origin: unknow): void;\r\n  private _fadeOriginDirection(particle: unknow): void;\r\n  private _parseColor(str: string): number[] | undefined;\r\n\r\n  // Private Getters\r\n  private get _mouseHandler(): (e: MouseEvent) => void;\r\n  private get _clickHandler(): (e: MouseEvent) => void;\r\n  private get _touchHandler(): (e: TouchEvent) => void;\r\n  private get _clearTouches(): (e: Event) => void;\r\n}\r\n\r\n/**\r\n * Initializes the InspiraImageParticle module and returns the class.\r\n */\r\nexport declare const inspiraImageParticles: () => {\r\n  InspiraImageParticle: typeof InspiraImageParticle;\r\n};\r\n"
    },
    {
      "path": "inspiraImageParticles.js",
      "content": "/* eslint-disable */\r\nexport const inspiraImageParticles = () => {\r\n  \"use strict\";\r\n\r\n  const _requestAnimationFrame =\r\n    window.requestAnimationFrame ||\r\n    window.webkitRequestAnimationFrame ||\r\n    window.mozRequestAnimationFrame ||\r\n    function (callback) {\r\n      setTimeout(callback, 10);\r\n    };\r\n  const PI2 = Math.PI * 2;\r\n  let imageData, renderCount;\r\n  let index, startIndex, layerIndex;\r\n  let origin, particle, touch, touchIndex, rect;\r\n  let x, y, z, dX, dY, dZ, distance;\r\n  let force, angle, intensity, vertices;\r\n  let canvas, context, data, r, g, b, a;\r\n  let tick;\r\n  let rotationX = 0;\r\n  let rotationY = 0;\r\n\r\n  class InspiraImageParticle {\r\n    constructor(optionsParam) {\r\n      let options = {};\r\n      if (optionsParam) {\r\n        if (optionsParam.nodeName) {\r\n          options = JSON.parse(JSON.stringify(optionsParam.dataset));\r\n          if (optionsParam.nodeName === \"IMG\") {\r\n            options.image = optionsParam;\r\n          } else {\r\n            options.wrapperElement = optionsParam;\r\n          }\r\n        } else {\r\n          options = optionsParam;\r\n        }\r\n      }\r\n      this.state = \"stopped\";\r\n      this.touches = [];\r\n      this.on(\"imageLoaded\", this._onImageLoaded);\r\n      this._initImage(options);\r\n    }\r\n\r\n    on(event, fn) {\r\n      this.events = this.events || {};\r\n      this.events[event] = this.events[event] || [];\r\n      this.events[event].push(fn);\r\n    }\r\n\r\n    emit(event, params) {\r\n      const events = this.events[event];\r\n      if (events && events.length) {\r\n        for (let eventIndex = 0; eventIndex < events.length; eventIndex++) {\r\n          const cb = events[eventIndex];\r\n          cb.call(this, params);\r\n        }\r\n      }\r\n    }\r\n\r\n    get renderer() {\r\n      return this._renderer;\r\n    }\r\n\r\n    set renderer(value) {\r\n      this._renderer = value;\r\n      this._draw = this[\"_\" + value + \"Renderer\"];\r\n      try {\r\n        this[\"_\" + value + \"InitContext\"]();\r\n      } catch (e) {\r\n        console.log(e);\r\n        if (value !== \"default\") {\r\n          this.renderer = \"default\";\r\n        }\r\n      }\r\n    }\r\n\r\n    set color(value) {\r\n      this.colorArr = this._parseColor(value);\r\n      if (this.colorArr) {\r\n        if (isNaN(this.colorArr[3])) {\r\n          this.colorArr[3] = 255;\r\n        }\r\n        if (0 < this.colorArr[3] && this.colorArr[3] <= 1) {\r\n          this.colorArr[3] *= 255;\r\n        }\r\n      }\r\n    }\r\n\r\n    start(optionsParam) {\r\n      const options = optionsParam || {};\r\n      this.initPosition = options.initPosition || this.initPosition;\r\n      this.initDirection = options.initDirection || this.initDirection;\r\n      if (this.canvas) {\r\n        this.canvas.width = this.width;\r\n        this.canvas.height = this.height;\r\n        this.canvas.style.display = \"\";\r\n      }\r\n      this._initOrigins();\r\n      this._initParticles();\r\n      this._webglSetAttributes();\r\n      if (this.state !== \"running\") {\r\n        this.state = \"running\";\r\n        if (!this.disableInteraction) {\r\n          if (\"ontouchstart\" in window || window.navigator.msPointerEnabled) {\r\n            document.body.addEventListener(\"touchstart\", this._touchHandler);\r\n            document.body.addEventListener(\"touchmove\", this._touchHandler);\r\n            document.body.addEventListener(\"touchend\", this._clearTouches);\r\n            document.body.addEventListener(\"touchcancel\", this._clearTouches);\r\n          } else {\r\n            this.canvas.addEventListener(\"mousemove\", this._mouseHandler);\r\n            this.canvas.addEventListener(\"mouseout\", this._clearTouches);\r\n            this.canvas.addEventListener(\"click\", this._clickHandler);\r\n          }\r\n        }\r\n        this._animate();\r\n      }\r\n    }\r\n\r\n    stop(optionsParam) {\r\n      const options = optionsParam || {};\r\n      this.fadePosition = options.fadePosition || this.fadePosition;\r\n      this.fadeDirection = options.fadeDirection || this.fadeDirection;\r\n      this._fade();\r\n      document.body.removeEventListener(\"touchstart\", this._touchHandler);\r\n      document.body.removeEventListener(\"touchmove\", this._touchHandler);\r\n      document.body.removeEventListener(\"touchend\", this._clearTouches);\r\n      document.body.removeEventListener(\"touchcancel\", this._clearTouches);\r\n      if (this.canvas) {\r\n        this.canvas.removeEventListener(\"mousemove\", this._mouseHandler);\r\n        this.canvas.removeEventListener(\"mouseout\", this._clearTouches);\r\n        this.canvas.removeEventListener(\"click\", this._clickHandler);\r\n      }\r\n    }\r\n\r\n    _animate() {\r\n      if (this.state !== \"stopped\") {\r\n        this._calculate();\r\n        this._draw();\r\n        _requestAnimationFrame(() => this._animate());\r\n      } else {\r\n        this.emit(\"stopped\");\r\n      }\r\n    }\r\n\r\n    get _mouseHandler() {\r\n      return (e) => {\r\n        this.touches = [\r\n          {\r\n            x: e.offsetX,\r\n            y: e.offsetY,\r\n            z: 49 + (this.layerCount - 1) * this.layerDistance,\r\n            force: 1,\r\n          },\r\n        ];\r\n      };\r\n    }\r\n\r\n    get _clickHandler() {\r\n      return (e) => {\r\n        const strength = this.clickStrength;\r\n        this.origins.map((o) => (o.z -= strength));\r\n        setTimeout(() => {\r\n          this.origins.map((o) => (o.z += strength));\r\n        }, 100);\r\n      };\r\n    }\r\n\r\n    get _touchHandler() {\r\n      return (e) => {\r\n        this.touches = [];\r\n        rect = this.canvas.getBoundingClientRect();\r\n        for (touchIndex = 0; touchIndex < e.changedTouches.length; touchIndex++) {\r\n          touch = e.changedTouches[touchIndex];\r\n          if (touch.target === this.canvas) {\r\n            this.touches.push({\r\n              x: touch.pageX - rect.left,\r\n              y: touch.pageY - rect.top,\r\n              z: 49 + (this.layerCount - 1) * this.layerDistance,\r\n              force: touch.force || 1,\r\n            });\r\n            e.preventDefault();\r\n          }\r\n        }\r\n      };\r\n    }\r\n\r\n    get _clearTouches() {\r\n      return (e) => {\r\n        this.touches = [];\r\n      };\r\n    }\r\n\r\n    _onImageLoaded(options) {\r\n      this.imageWidth = this.image.naturalWidth || this.image.width;\r\n      this.imageHeight = this.image.naturalHeight || this.image.height;\r\n      this.imageRatio = this.imageWidth / this.imageHeight;\r\n      this.width = this.width || this.imageWidth;\r\n      this.height = this.height || this.imageHeight;\r\n      this.renderSize = (this.width + this.height) / 4;\r\n      if (this.srcImage) {\r\n        this.srcImage.style.display = \"none\";\r\n      }\r\n      this._initSettings(options);\r\n      this._initContext(options);\r\n      this._initResponsive(options);\r\n      this.start();\r\n    }\r\n\r\n    _initImage(options) {\r\n      this.srcImage = options.image;\r\n      if (!this.srcImage && options.imageId) {\r\n        this.srcImage = document.getElementById(options.imageId);\r\n      }\r\n      this.imageUrl = options.imageUrl || this.srcImage.src;\r\n      this.image = document.createElement(\"img\");\r\n      this.wrapperElement = options.wrapperElement || this.srcImage.parentElement;\r\n      this.image.onload = () => this.emit(\"imageLoaded\", options);\r\n      this.image.crossOrigin = \"Anonymous\";\r\n      if (options.addTimestamp) {\r\n        if (/\\?/.test(this.imageUrl)) {\r\n          this.imageUrl += \"&d=\" + Date.now();\r\n        } else {\r\n          this.imageUrl += \"?d=\" + Date.now();\r\n        }\r\n      }\r\n      this.image.src = this.imageUrl;\r\n    }\r\n\r\n    _initContext(options) {\r\n      this.canvas = options.canvas;\r\n      if (!this.canvas && !this.context && this.wrapperElement) {\r\n        this.canvas = document.createElement(\"canvas\");\r\n        this.wrapperElement.appendChild(this.canvas);\r\n      }\r\n      if (this.convas) {\r\n        this.convas.style.display = \"none\";\r\n      }\r\n      this.context = options.context;\r\n      this.renderer = options.renderer || \"default\";\r\n    }\r\n\r\n    _defaultInitContext(options) {\r\n      this.context = this.context || this.canvas.getContext(\"2d\");\r\n    }\r\n\r\n    _webglInitContext() {\r\n      this.context =\r\n        this.context ||\r\n        this.canvas.getContext(\"webgl2\") ||\r\n        this.canvas.getContext(\"experimental-webgl\");\r\n      this.fragmentShaderScript = `#version 300 es\r\n    \r\n            precision highp float;\r\n    \r\n            in vec4 vColor;\r\n            out vec4 fragColor;\r\n    \r\n            void main(void) {\r\n              // fragColor = vec4(1, 1, 1, 0.1);\r\n              fragColor = vColor;\r\n            }\r\n          `;\r\n\r\n      this.vertexShaderScript = `#version 300 es\r\n    \r\n            precision highp float;\r\n    \r\n            in vec3 vertexPosition;\r\n            in vec4 vertexColor;\r\n            uniform vec3 vertexOffset;\r\n            uniform float pointSize;\r\n            uniform float depth;\r\n            vec3 mirror = vec3(1, -1, 1);\r\n    \r\n            uniform mat4 modelViewMatrix;\r\n            uniform mat4 perspectiveMatrix;\r\n            uniform mat4 rotationMatrix;\r\n    \r\n            out vec4 vColor;\r\n    \r\n            void main(void) {\r\n              gl_Position = rotationMatrix * perspectiveMatrix * modelViewMatrix * vec4(mirror * vertexPosition + vertexOffset, vertexPosition);\r\n              gl_PointSize = pointSize + max((log(vertexPosition.z) - 3.91) * depth, -pointSize + 1.0);\r\n              vColor = vertexColor;\r\n            }\r\n          `;\r\n      this.context.viewport(0, 0, this.width, this.height);\r\n      const vertexShader = this.context.createShader(this.context.VERTEX_SHADER);\r\n      this.context.shaderSource(vertexShader, this.vertexShaderScript);\r\n      this.context.compileShader(vertexShader);\r\n      if (!this.context.getShaderParameter(vertexShader, this.context.COMPILE_STATUS)) {\r\n        console.log(this.context.getShaderInfoLog(vertexShader));\r\n      }\r\n      const fragmentShader = this.context.createShader(this.context.FRAGMENT_SHADER);\r\n      this.context.shaderSource(fragmentShader, this.fragmentShaderScript);\r\n      this.context.compileShader(fragmentShader);\r\n      if (!this.context.getShaderParameter(fragmentShader, this.context.COMPILE_STATUS)) {\r\n        console.log(this.context.getShaderInfoLog(fragmentShader));\r\n      }\r\n      this.program = this.context.createProgram();\r\n      this.context.attachShader(this.program, vertexShader);\r\n      this.context.attachShader(this.program, fragmentShader);\r\n      this.context.linkProgram(this.program);\r\n      this.context.useProgram(this.program);\r\n      this.vertexPosition = this.context.getAttribLocation(this.program, \"vertexPosition\");\r\n      this.context.enableVertexAttribArray(this.vertexPosition);\r\n      this.vertexColor = this.context.getAttribLocation(this.program, \"vertexColor\");\r\n      this.context.enableVertexAttribArray(this.vertexColor);\r\n      this.context.clearColor(0.0, 0.0, 0.0, 0.0);\r\n      this.context.enable(this.context.BLEND);\r\n      this.context.disable(this.context.DEPTH_TEST);\r\n      this.context.blendFunc(this.context.SRC_ALPHA, this.context.ONE);\r\n      this.vertexBuffer = this.context.createBuffer();\r\n      this.context.bindBuffer(this.context.ARRAY_BUFFER, this.vertexBuffer);\r\n      this.context.clear(this.context.COLOR_BUFFER_BIT | this.context.DEPTH_BUFFER_BIT);\r\n      this.vertexOffset = this.context.getUniformLocation(this.program, \"vertexOffset\");\r\n      this.context.uniform3f(this.vertexOffset, 0, 0, 1000);\r\n      this.context.vertexAttribPointer(this.vertexPosition, 3.0, this.context.FLOAT, false, 28, 0);\r\n      this.context.vertexAttribPointer(this.vertexColor, 4.0, this.context.FLOAT, false, 28, 12);\r\n      this.uModelViewMatrix = this.context.getUniformLocation(this.program, \"modelViewMatrix\");\r\n      this.uPerspectiveMatrix = this.context.getUniformLocation(this.program, \"perspectiveMatrix\");\r\n      this.uRotationMatrix = this.context.getUniformLocation(this.program, \"rotationMatrix\");\r\n      this.uPointSize = this.context.getUniformLocation(this.program, \"pointSize\");\r\n      this.uDepth = this.context.getUniformLocation(this.program, \"depth\");\r\n      // this.uVertexColors = this.context.getUniformLocation(this.program, 'vertexColors');\r\n      // this.uVertexIndex = this.context.getUniformLocation(this.program, 'vertexIndex');\r\n\r\n      this._webglSetAttributes();\r\n    }\r\n\r\n    _webglSetAttributes() {\r\n      if (this.renderer === \"webgl\") {\r\n        var fieldOfView = 1;\r\n        var aspectRatio = this.canvas.width / this.canvas.height;\r\n        var nearPlane = 10;\r\n        var farPlane = 100;\r\n        var top = nearPlane * Math.tan((fieldOfView * Math.PI) / 360.0);\r\n        var bottom = -top;\r\n        var right = top * aspectRatio;\r\n        var left = -right;\r\n        var a = (right + left) / (right - left);\r\n        var b = (top + bottom) / (top - bottom);\r\n        var c = (farPlane + nearPlane) / (farPlane - nearPlane);\r\n        var d = (2 * farPlane * nearPlane) / (farPlane - nearPlane);\r\n        var x = (2 * nearPlane) / (right - left);\r\n        var y = (2 * nearPlane) / (top - bottom);\r\n\r\n        var perspectiveMatrix = [x, 0, a, 0, 0, y, b, 0, 0, 0, c, d, 0, 0, -1, 0];\r\n        var modelViewMatrix = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\r\n        this.context.viewport(0, 0, this.width, this.height);\r\n        this.context.uniformMatrix4fv(\r\n          this.uModelViewMatrix,\r\n          false,\r\n          new Float32Array(perspectiveMatrix),\r\n        );\r\n        this.context.uniformMatrix4fv(\r\n          this.uPerspectiveMatrix,\r\n          false,\r\n          new Float32Array(modelViewMatrix),\r\n        );\r\n        this.context.uniform1f(this.uPointSize, this.particleSize);\r\n        this.context.uniform1f(this.uDepth, this.depth);\r\n        // this.context.uniform4fv(this.uVertexColors, new Float32Array(this.vertexColors));\r\n        // this.context.uniform1f(this.uVertexIndex, 0);\r\n        this._updateRotation();\r\n      }\r\n    }\r\n\r\n    _updateRotation() {\r\n      const a = Math.cos(rotationX);\r\n      const b = Math.sin(rotationX);\r\n      const c = Math.cos(rotationY);\r\n      const d = Math.sin(rotationY);\r\n      var rotationMatrix = [c, 0, d, 0, 0, a, -b, 0, -c, b, a, 0, 0, 0, 0, 1];\r\n      this.context.uniformMatrix4fv(this.uRotationMatrix, false, new Float32Array(rotationMatrix));\r\n    }\r\n\r\n    _webglRenderer() {\r\n      vertices = new Float32Array(this.vertices);\r\n      this.context.bufferData(this.context.ARRAY_BUFFER, vertices, this.context.STATIC_DRAW);\r\n      this.context.clear(this.context.COLOR_BUFFER_BIT | this.context.DEPTH_BUFFER_BIT);\r\n      this.context.drawArrays(this.context.POINTS, 0, this.particles.length);\r\n      this.context.flush();\r\n    }\r\n\r\n    _initSettings(options) {\r\n      this.width = options.width * 1 || this.width;\r\n      this.height = options.height * 1 || this.height;\r\n      this.maxWidth = options.maxWidth;\r\n      this.maxHeight = options.maxHeight;\r\n      this.minWidth = options.minWidth;\r\n      this.minHeight = options.minHeight;\r\n      if (this.maxWidth) {\r\n        if (/%$/.test(this.maxWidth)) {\r\n          this.maxWidth = (this.width * this.maxWidth.replace(\"%\", \"\")) / 100;\r\n        } else {\r\n          this.maxWidth *= 1;\r\n        }\r\n      }\r\n      if (this.maxHeight) {\r\n        if (/%$/.test(this.maxHeight)) {\r\n          this.maxHeight = (this.height * this.maxHeight.replace(\"%\", \"\")) / 100;\r\n        } else {\r\n          this.maxHeight *= 1;\r\n        }\r\n      }\r\n      if (this.minWidth) {\r\n        if (/%$/.test(this.minWidth)) {\r\n          this.minWidth = (this.width * this.minWidth.replace(\"%\", \"\")) / 100;\r\n        } else {\r\n          this.minWidth *= 1;\r\n        }\r\n      }\r\n      if (this.minHeight) {\r\n        if (/%$/.test(this.minHeight)) {\r\n          this.minHeight = (this.height * this.minHeight.replace(\"%\", \"\")) / 100;\r\n        } else {\r\n          this.minHeight *= 1;\r\n        }\r\n      }\r\n      this.alphaFade = 0.4;\r\n      this.gravity = options.gravity * 1 || 0.08;\r\n      this.particleGap = options.particleGap * 1 || 3;\r\n      this.particleSize = options.particleSize * 1 || 1;\r\n      this.layerCount = options.layerCount * 1 || 1;\r\n      this.depth = options.depth * 1 || 1;\r\n      this.rotationDuration = options.rotationDuration * 1 || 0;\r\n      this.growDuration = options.growDuration * 1 || 200;\r\n      this.waitDuration = options.waitDuration * 1 || 200;\r\n      this.shrinkDuration = options.shrinkDuration * 1 || 200;\r\n      this.shrinkDistance = options.shrinkDistance * 1 || 50;\r\n      this.threeDimensional =\r\n        options.threeDimensional !== undefined && options.threeDimensional !== \"false\"\r\n          ? !!options.threeDimensional\r\n          : false;\r\n      this.lifeCycle =\r\n        options.lifeCycle !== undefined && options.lifeCycle !== \"false\"\r\n          ? !!options.lifeCycle\r\n          : false;\r\n      this.layerDistance = options.layerDistance || this.particleGap;\r\n      this.initPosition = options.initPosition || \"random\";\r\n      this.initDirection = options.initDirection || \"random\";\r\n      this.fadePosition = options.fadePosition || \"none\";\r\n      this.fadeDirection = options.fadeDirection || \"none\";\r\n      this.noise = isNaN(options.noise * 1) ? 10 : options.noise * 1;\r\n      this.disableInteraction = options.disableInteraction;\r\n      this.mouseForce = options.mouseForce * 1 || 30;\r\n      this.clickStrength = options.clickStrength * 1 || 0;\r\n      this.color = options.color;\r\n      this.colorArr = options.colorArr || this.colorArr;\r\n    }\r\n\r\n    _initResponsive(options) {\r\n      this.responsiveWidth = this.wrapperElement && options.responsiveWidth;\r\n      if (this.responsiveWidth) {\r\n        this.on(\"stopped\", () => {\r\n          this.width = this.wrapperElement.clientWidth;\r\n          this.start();\r\n        });\r\n        this.wrapperElement.addEventListener(\"resize\", () => {\r\n          if (this.width !== this.wrapperElement.clientWidth) {\r\n            this.stop();\r\n          }\r\n        });\r\n        this.width = this.wrapperElement.clientWidth;\r\n      }\r\n    }\r\n\r\n    _calculate() {\r\n      this.vertices = this.renderer === \"webgl\" ? [] : false;\r\n\r\n      renderCount = 0;\r\n      for (index = 0; index < this.particles.length; index++) {\r\n        origin = this.origins[index];\r\n        particle = this.particles[index];\r\n        dX = origin.x - particle.x + (Math.random() - 0.5) * this.noise;\r\n        dY = origin.y - particle.y + (Math.random() - 0.5) * this.noise;\r\n        dZ = origin.z - particle.z + ((Math.random() - 0.5) * this.noise) / 1000;\r\n        distance = Math.sqrt(dX * dX + dY * dY + dZ * dZ);\r\n        force = distance * 0.01;\r\n        particle.vx += force * (dX / distance) * this.speed;\r\n        particle.vy += force * (dY / distance) * this.speed;\r\n        particle.vz += force * (dZ / distance) * this.speed;\r\n        for (touchIndex = 0; touchIndex < this.touches.length; touchIndex++) {\r\n          touch = this.touches[touchIndex];\r\n          dX = particle.x - touch.x;\r\n          dY = particle.y - touch.y;\r\n          dZ = particle.z - touch.z;\r\n          distance = Math.sqrt(dX * dX + dY * dY + dZ * dZ);\r\n          force = (this.mouseForce * touch.force) / distance;\r\n          particle.vx += force * (dX / distance) * this.speed;\r\n          particle.vy += force * (dY / distance) * this.speed;\r\n          particle.vz += force * (dZ / distance) * this.speed;\r\n        }\r\n        particle.vx *= this.gravityFactor;\r\n        particle.vy *= this.gravityFactor;\r\n        particle.vz *= this.gravityFactor;\r\n        particle.x += particle.vx;\r\n        particle.y += particle.vy;\r\n        particle.z += particle.vz;\r\n        if (\r\n          0 > particle.x ||\r\n          particle.x >= this.width ||\r\n          0 > particle.y ||\r\n          particle.y >= this.height\r\n        ) {\r\n          particle.isHidden = true;\r\n          if (this.state === \"stopping\") {\r\n            particle.isDead = true;\r\n          }\r\n        } else {\r\n          if (this.state === \"stopping\" && !particle.isDead) {\r\n            renderCount++;\r\n          }\r\n          particle.isHidden = false;\r\n        }\r\n        if (this.vertices) {\r\n          x = particle.x - this.width / 2;\r\n          y = particle.y - this.height / 2;\r\n          z = particle.z;\r\n          a = origin.vertexColors[3];\r\n          if (this.lifeCycle) {\r\n            origin.tick += 1;\r\n            if (origin.tick >= 0) {\r\n              if (origin.tick < this.growDuration) {\r\n                a = a * (origin.tick / this.growDuration);\r\n                // z -= 50 * (tick / this.shrinkDuration);\r\n              } else {\r\n                tick = origin.tick - this.growDuration - this.waitDuration;\r\n                if (tick >= 0 && tick <= this.shrinkDuration) {\r\n                  touch = this.touches[touchIndex];\r\n                  // rotationX = Math.PI / 2 + Math.cos(dX * Math.PI / 2) * dX * Math.PI * 0.1;\r\n                  // rotationY = Math.PI / 2 + Math.cos(dY * Math.PI / 2) * dY * Math.PI * 0.1;\r\n                  distance = Math.sqrt(x * x + y * y + (z - 50) * (z - 50));\r\n                  // distance = Math.sqrt(x * x + y * y);\r\n                  force = tick / this.shrinkDuration;\r\n                  x += this.shrinkDistance * (x / distance) * force;\r\n                  y += this.shrinkDistance * (y / distance) * force;\r\n                  z += this.shrinkDistance * ((z - 50) / distance) * force;\r\n                  a *= 1 - force;\r\n                  if (tick === this.shrinkDuration) {\r\n                    origin.tick = 0;\r\n                  }\r\n                }\r\n              }\r\n            } else {\r\n              a = 0;\r\n            }\r\n          }\r\n          this.vertices.push(\r\n            x,\r\n            y,\r\n            z,\r\n            origin.vertexColors[0],\r\n            origin.vertexColors[1],\r\n            origin.vertexColors[2],\r\n            a,\r\n          );\r\n        }\r\n      }\r\n      if (this.state === \"stopping\" && renderCount === 0) {\r\n        this.state = \"stopped\";\r\n      }\r\n    }\r\n\r\n    _defaultRenderer() {\r\n      this.depth = Math.max((this.layerDistance * this.layerCount) / 2, this.mouseForce);\r\n      this.minZ = -this.depth;\r\n      this.maxZ = this.depth;\r\n      imageData = this.context.createImageData(this.width, this.height);\r\n\r\n      for (index = 0; index < this.origins.length; index++) {\r\n        origin = this.origins[index];\r\n        particle = this.particles[index];\r\n        if (!particle.isDead && !particle.isHidden) {\r\n          x = ~~particle.x;\r\n          y = ~~particle.y;\r\n          a = origin.color[3];\r\n          if (this.alphaFade > 0 && this.layerCount > 1) {\r\n            z = Math.max(Math.min(particle.z, this.maxZ), this.minZ) - this.minZ;\r\n            a = a * (1 - this.alphaFade) + a * this.alphaFade * (z / (this.maxZ - this.minZ));\r\n            a = Math.max(Math.min(~~a, 255), 0);\r\n          }\r\n          startIndex = (x + y * this.width) * 4;\r\n          imageData.data[startIndex + 0] = origin.color[0];\r\n          imageData.data[startIndex + 1] = origin.color[1];\r\n          imageData.data[startIndex + 2] = origin.color[2];\r\n          imageData.data[startIndex + 3] = a;\r\n        }\r\n      }\r\n      this.context.putImageData(imageData, 0, 0);\r\n    }\r\n\r\n    _initParticles() {\r\n      this.particles = undefined;\r\n      this.particles = [];\r\n      for (index = 0; index < this.origins.length; index++) {\r\n        origin = this.origins[index];\r\n        particle = {};\r\n        this._initParticlePosition(origin, particle);\r\n        this._initParticleDirection(particle);\r\n        this.particles.push(particle);\r\n      }\r\n    }\r\n\r\n    _initParticlePosition(origin, particle) {\r\n      particle.z = 0;\r\n      switch (this.initPosition) {\r\n        case \"random\": {\r\n          particle.x = Math.random() * this.width;\r\n          particle.y = Math.random() * this.height;\r\n          break;\r\n        }\r\n        case \"top\": {\r\n          particle.x = Math.random() * this.width * 3 - this.width;\r\n          particle.y = -Math.random() * this.height;\r\n          break;\r\n        }\r\n        case \"left\": {\r\n          particle.x = -Math.random() * this.width;\r\n          particle.y = Math.random() * this.height * 3 - this.height;\r\n          break;\r\n        }\r\n        case \"bottom\": {\r\n          particle.x = Math.random() * this.width * 3 - this.width;\r\n          particle.y = this.height + Math.random() * this.height;\r\n          break;\r\n        }\r\n        case \"right\": {\r\n          particle.x = this.width + Math.random() * this.width;\r\n          particle.y = Math.random() * this.height * 3 - this.height;\r\n          break;\r\n        }\r\n        case \"misplaced\": {\r\n          particle.x = origin.x + Math.random() * this.width * 0.3 - this.width * 0.1;\r\n          particle.y = origin.y + Math.random() * this.height * 0.3 - this.height * 0.1;\r\n          break;\r\n        }\r\n        default: {\r\n          particle.x = origin.x;\r\n          particle.y = origin.y;\r\n        }\r\n      }\r\n    }\r\n\r\n    _fade() {\r\n      if (\r\n        this.fadePosition === \"explode\" ||\r\n        this.fadePosition === \"top\" ||\r\n        this.fadePosition === \"left\" ||\r\n        this.fadePosition === \"bottom\" ||\r\n        this.fadePosition === \"right\"\r\n      ) {\r\n        this.state = \"stopping\";\r\n      } else {\r\n        this.state = \"stopped\";\r\n      }\r\n      if (this.origins) {\r\n        for (index = 0; index < this.origins.length; index++) {\r\n          this._fadeOriginPosition(this.origins[index]);\r\n          this._fadeOriginDirection(this.particles[index]);\r\n        }\r\n      }\r\n    }\r\n\r\n    _fadeOriginPosition(origin) {\r\n      switch (this.fadePosition) {\r\n        case \"random\": {\r\n          origin.x = Math.random() * this.width * 2 - this.width;\r\n          origin.y = Math.random() * this.height * 2 - this.height;\r\n          if (origin.x > 0) origin.x += this.width;\r\n          if (origin.y > 0) origin.y += this.height;\r\n          break;\r\n        }\r\n        case \"top\": {\r\n          origin.x = Math.random() * this.width * 3 - this.width;\r\n          origin.y = -Math.random() * this.height;\r\n          break;\r\n        }\r\n        case \"left\": {\r\n          origin.x = -Math.random() * this.width;\r\n          origin.y = Math.random() * this.height * 3 - this.height;\r\n          break;\r\n        }\r\n        case \"bottom\": {\r\n          origin.x = Math.random() * this.width * 3 - this.width;\r\n          origin.y = this.height + Math.random() * this.height;\r\n          break;\r\n        }\r\n        case \"right\": {\r\n          origin.x = this.width + Math.random() * this.width;\r\n          origin.y = Math.random() * this.height * 3 - this.height;\r\n          break;\r\n        }\r\n        default: {\r\n          // Stay in place\r\n        }\r\n      }\r\n    }\r\n\r\n    _initParticleDirection(particle) {\r\n      particle.vz = 0;\r\n      switch (this.initDirection) {\r\n        case \"random\": {\r\n          angle = Math.random() * Math.PI * 2;\r\n          intensity = Math.random();\r\n          particle.vx = this.width * intensity * Math.sin(angle) * 0.1;\r\n          particle.vy = this.height * intensity * Math.cos(angle) * 0.1;\r\n          break;\r\n        }\r\n        case \"top\": {\r\n          angle = Math.random() * Math.PI - Math.PI / 2;\r\n          intensity = Math.random();\r\n          particle.vx = this.width * intensity * Math.sin(angle) * 0.1;\r\n          particle.vy = this.height * intensity * Math.cos(angle) * 0.1;\r\n          break;\r\n        }\r\n        case \"left\": {\r\n          angle = Math.random() * Math.PI + Math.PI;\r\n          intensity = Math.random();\r\n          particle.vx = this.width * intensity * Math.sin(angle) * 0.1;\r\n          particle.vy = this.height * intensity * Math.cos(angle) * 0.1;\r\n          break;\r\n        }\r\n        case \"bottom\": {\r\n          angle = Math.random() * Math.PI + Math.PI / 2;\r\n          intensity = Math.random();\r\n          particle.vx = this.width * intensity * Math.sin(angle) * 0.1;\r\n          particle.vy = this.height * intensity * Math.cos(angle) * 0.1;\r\n          break;\r\n        }\r\n        case \"right\": {\r\n          angle = Math.random() * Math.PI;\r\n          intensity = Math.random();\r\n          particle.vx = this.width * intensity * Math.sin(angle) * 0.1;\r\n          particle.vy = this.height * intensity * Math.cos(angle) * 0.1;\r\n          break;\r\n        }\r\n        default: {\r\n          particle.vx = 0;\r\n          particle.vy = 0;\r\n        }\r\n      }\r\n    }\r\n\r\n    _fadeOriginDirection(particle) {\r\n      switch (this.fadeDirection) {\r\n        case \"random\": {\r\n          angle = Math.random() * Math.PI * 2;\r\n          intensity = Math.random();\r\n          particle.vx += this.width * intensity * Math.sin(angle) * 0.1;\r\n          particle.vy += this.height * intensity * Math.cos(angle) * 0.1;\r\n          break;\r\n        }\r\n        case \"top\": {\r\n          angle = Math.random() * Math.PI - Math.PI / 2;\r\n          intensity = Math.random();\r\n          particle.vx += this.width * intensity * Math.sin(angle) * 0.1;\r\n          particle.vy += this.height * intensity * Math.cos(angle) * 0.1;\r\n          break;\r\n        }\r\n        case \"left\": {\r\n          angle = Math.random() * Math.PI + Math.PI;\r\n          intensity = Math.random();\r\n          particle.vx += this.width * intensity * Math.sin(angle) * 0.1;\r\n          particle.vy += this.height * intensity * Math.cos(angle) * 0.1;\r\n          break;\r\n        }\r\n        case \"bottom\": {\r\n          angle = Math.random() * Math.PI + Math.PI / 2;\r\n          intensity = Math.random();\r\n          particle.vx += this.width * intensity * Math.sin(angle) * 0.1;\r\n          particle.vy += this.height * intensity * Math.cos(angle) * 0.1;\r\n          break;\r\n        }\r\n        case \"right\": {\r\n          angle = Math.random() * Math.PI;\r\n          intensity = Math.random();\r\n          particle.vx += this.width * intensity * Math.sin(angle) * 0.1;\r\n          particle.vy += this.height * intensity * Math.cos(angle) * 0.1;\r\n          break;\r\n        }\r\n        default: {\r\n          particle.vx = 0;\r\n          particle.vy = 0;\r\n        }\r\n      }\r\n    }\r\n\r\n    _initOrigins() {\r\n      canvas = document.createElement(\"canvas\");\r\n      if (this.responsiveWidth) {\r\n        this.width = this.wrapperElement.clientWidth;\r\n      }\r\n      this.ratio =\r\n        Math.min(this.width, this.maxWidth || Number.POSITIVE_INFINITY) /\r\n        Math.min(this.height, this.maxHeight || Number.POSITIVE_INFINITY);\r\n      if (this.ratio < this.imageRatio) {\r\n        this.renderWidth = ~~Math.min(\r\n          this.width || Number.POSITIVE_INFINITY,\r\n          this.minWidth || this.imageWidth || Number.POSITIVE_INFINITY,\r\n          this.maxWidth || Number.POSITIVE_INFINITY,\r\n        );\r\n        this.renderHeight = ~~(this.renderWidth / this.imageRatio);\r\n      } else {\r\n        this.renderHeight = ~~Math.min(\r\n          this.height || Number.POSITIVE_INFINITY,\r\n          this.minHeight || this.imageHeight || Number.POSITIVE_INFINITY,\r\n          this.maxHeight || Number.POSITIVE_INFINITY,\r\n        );\r\n        this.renderWidth = ~~(this.renderHeight * this.imageRatio);\r\n      }\r\n      this.offsetX = ~~((this.width - this.renderWidth) / 2);\r\n      this.offsetY = ~~((this.height - this.renderHeight) / 2);\r\n      canvas.width = this.renderWidth;\r\n      canvas.height = this.renderHeight;\r\n      context = canvas.getContext(\"2d\");\r\n      context.drawImage(this.image, 0, 0, this.renderWidth, this.renderHeight);\r\n      data = context.getImageData(0, 0, this.renderWidth, this.renderHeight).data;\r\n      this.origins = undefined;\r\n      this.origins = [];\r\n      const duration = this.growDuration + this.waitDuration + this.shrinkDuration;\r\n      for (x = 0; x < this.renderWidth; x += this.particleGap) {\r\n        for (y = 0; y < this.renderHeight; y += this.particleGap) {\r\n          index = (x + y * this.renderWidth) * 4;\r\n          a = data[index + 3];\r\n          if (a > 0) {\r\n            const seed = Math.random();\r\n            tick = -Math.floor(seed * duration);\r\n            if (this.colorArr) {\r\n              for (layerIndex = 0; layerIndex < this.layerCount; layerIndex++) {\r\n                this.origins.push({\r\n                  x: this.offsetX + x,\r\n                  y: this.offsetY + y,\r\n                  z: layerIndex * this.layerDistance + 50,\r\n                  color: this.colorArr,\r\n                  tick,\r\n                  seed,\r\n                  vertexColors: this.colorArr.map((c) => c / 255),\r\n                });\r\n              }\r\n            } else {\r\n              r = data[index];\r\n              g = data[index + 1];\r\n              b = data[index + 2];\r\n              for (layerIndex = 0; layerIndex < this.layerCount; layerIndex++) {\r\n                this.origins.push({\r\n                  x: this.offsetX + x,\r\n                  y: this.offsetY + y,\r\n                  z: layerIndex * this.layerDistance + 50,\r\n                  color: [r, g, b, a],\r\n                  tick,\r\n                  seed,\r\n                  vertexColors: [r / 255, g / 255, b / 255, a / 255],\r\n                });\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n      this.speed = Math.log(this.origins.length) / 10;\r\n      this.gravityFactor = 1 - this.gravity * this.speed;\r\n    }\r\n\r\n    _parseColor(strParam) {\r\n      let color;\r\n      if (typeof strParam !== \"string\") {\r\n        return undefined;\r\n      }\r\n      const str = strParam.replace(\" \", \"\");\r\n\r\n      if ((color = /^#([\\da-fA-F]{2})([\\da-fA-F]{2})([\\da-fA-F]{2})/.exec(str))) {\r\n        color = [parseInt(color[1], 16), parseInt(color[2], 16), parseInt(color[3], 16)];\r\n      } else if ((color = /^#([\\da-fA-F])([\\da-fA-F])([\\da-fA-F])/.exec(str))) {\r\n        color = [\r\n          parseInt(color[1], 16) * 17,\r\n          parseInt(color[2], 16) * 17,\r\n          parseInt(color[3], 16) * 17,\r\n        ];\r\n      } else if ((color = /^rgba\\(([\\d]+),([\\d]+),([\\d]+),([\\d]+|[\\d]*.[\\d]+)\\)/.exec(str))) {\r\n        color = [+color[1], +color[2], +color[3], +color[4]];\r\n      } else if ((color = /^rgb\\(([\\d]+),([\\d]+),([\\d]+)\\)/.exec(str))) {\r\n        color = [+color[1], +color[2], +color[3]];\r\n      } else return undefined;\r\n\r\n      return color;\r\n    }\r\n  }\r\n\r\n  return {\r\n    InspiraImageParticle,\r\n  };\r\n};\r\n"
    },
    {
      "path": "ParticleImage.vue",
      "content": "<template>\r\n  <img\r\n    ref=\"imageParticleRef\"\r\n    :src=\"imageSrc\"\r\n    :class=\"cn('hidden w-32 h-32', $props.class)\"\r\n    :data-particle-gap=\"particleGap\"\r\n    :data-width=\"canvasWidth\"\r\n    :data-height=\"canvasHeight\"\r\n    :data-gravity=\"gravity\"\r\n    :data-particle-size=\"particleSize\"\r\n    :data-mouse-force=\"mouseForce\"\r\n    :data-renderer=\"renderer\"\r\n    :data-color=\"color\"\r\n    :data-color-arr=\"colorArr\"\r\n    :data-init-position=\"initPosition\"\r\n    :data-init-direction=\"initDirection\"\r\n    :data-fade-position=\"fadePosition\"\r\n    :data-fade-direction=\"fadeDirection\"\r\n    :data-noise=\"noise\"\r\n    :data-responsive-width=\"responsiveWidth\"\r\n  />\r\n</template>\r\n\r\n<script lang=\"ts\" setup>\r\nimport { cn } from \"@/lib/utils\";\r\nimport {\r\n  inspiraImageParticles,\r\n  type InspiraImageParticle as ImageParticle,\r\n} from \"./inspiraImageParticles\";\r\nimport { ref, onMounted } from \"vue\";\r\n\r\ntype ParticleImageProps = {\r\n  imageSrc: string;\r\n  class?: string;\r\n  canvasWidth?: string;\r\n  canvasHeight?: string;\r\n  gravity?: string;\r\n  particleSize?: string;\r\n  particleGap?: string;\r\n  mouseForce?: string;\r\n  renderer?: \"default\" | \"webgl\";\r\n  color?: string;\r\n  colorArr?: number[];\r\n  initPosition?: \"random\" | \"top\" | \"left\" | \"bottom\" | \"right\" | \"misplaced\" | \"none\";\r\n  initDirection?: \"random\" | \"top\" | \"left\" | \"bottom\" | \"right\" | \"none\";\r\n  fadePosition?: \"explode\" | \"top\" | \"left\" | \"bottom\" | \"right\" | \"random\" | \"none\";\r\n  fadeDirection?: \"random\" | \"top\" | \"left\" | \"bottom\" | \"right\" | \"none\";\r\n  noise?: number;\r\n  responsiveWidth?: boolean;\r\n};\r\n\r\ndefineProps<ParticleImageProps>();\r\n\r\nlet particles: ImageParticle;\r\nconst imageParticleRef = ref<HTMLImageElement>();\r\n\r\nonMounted(() => {\r\n  const { InspiraImageParticle } = inspiraImageParticles();\r\n  particles = new InspiraImageParticle(imageParticleRef.value);\r\n});\r\n</script>\r\n"
    }
  ],
  "fileCount": 4,
  "contentHash": "da8ef51dbc8835ae1249e80e69170cf29b49bf94"
}
