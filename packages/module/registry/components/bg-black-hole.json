{
  "name": "bg-black-hole",
  "dependencies": [
    "motion-v"
  ],
  "files": [
    {
      "path": "BlackHoleBackground.vue",
      "content": "<template>\r\n  <div\r\n    data-slot=\"black-hole-background\"\r\n    :class=\"[\r\n      'relative size-full overflow-hidden',\r\n      `before:absolute before:left-1/2 before:top-1/2 before:block before:size-[140%] before:content-[''] before:[background:radial-gradient(ellipse_at_50%_55%,transparent_10%,white_50%)] before:[transform:translate3d(-50%,-50%,0)] dark:before:[background:radial-gradient(ellipse_at_50%_55%,transparent_10%,black_50%)]`,\r\n      `after:absolute after:left-1/2 after:top-1/2 after:z-[5] after:block after:size-full after:mix-blend-overlay after:content-[''] after:[background:radial-gradient(ellipse_at_50%_75%,#a900ff_20%,transparent_75%)] after:[transform:translate3d(-50%,-50%,0)]`,\r\n    ]\"\r\n    v-bind=\"props\"\r\n  >\r\n    <slot></slot>\r\n    <canvas\r\n      ref=\"canvasRef\"\r\n      class=\"absolute inset-0 block size-full opacity-10 dark:opacity-20\"\r\n    />\r\n    <motion.div\r\n      :class=\"[\r\n        'absolute left-1/2 top-[-71.5%] z-[3] h-[140%] w-[30%] rounded-b-full opacity-75 mix-blend-plus-darker blur-3xl [background-position:0%_100%] [background-size:100%_200%] [transform:translate3d(-50%,0,0)] dark:mix-blend-plus-lighter',\r\n        '[background:linear-gradient(20deg,#00f8f1,#ffbd1e40_16.5%,#fe848f_33%,#fe848f40_49.5%,#00f8f1_66%,#00f8f180_85.5%,#ffbd1e_100%)_0_100%_/_100%_200%] dark:[background:linear-gradient(20deg,#00f8f1,#ffbd1e20_16.5%,#fe848f_33%,#fe848f20_49.5%,#00f8f1_66%,#00f8f160_85.5%,#ffbd1e_100%)_0_100%_/_100%_200%]',\r\n      ]\"\r\n      :animate=\"{ backgroundPosition: '0% 300%' }\"\r\n      :transition=\"{ duration: 5, ease: 'linear', repeat: Infinity }\"\r\n    />\r\n    <div\r\n      class=\"absolute left-0 top-0 z-[7] size-full opacity-50 mix-blend-overlay dark:[background:repeating-linear-gradient(transparent,transparent_1px,white_1px,white_2px)]\"\r\n    />\r\n  </div>\r\n</template>\r\n\r\n<script lang=\"ts\" setup>\r\nimport { motion } from \"motion-v\";\r\n\r\ninterface Disc {\r\n  p: number;\r\n  x: number;\r\n  y: number;\r\n  w: number;\r\n  h: number;\r\n}\r\n\r\ninterface Point {\r\n  x: number;\r\n  y: number;\r\n}\r\n\r\ninterface Particle {\r\n  x: number;\r\n  sx: number;\r\n  dx: number;\r\n  y: number;\r\n  vy: number;\r\n  p: number;\r\n  r: number;\r\n  c: string;\r\n}\r\n\r\ninterface Clip {\r\n  disc?: Disc;\r\n  i?: number;\r\n  path?: Path2D;\r\n}\r\n\r\ninterface State {\r\n  discs: Disc[];\r\n  lines: Point[][];\r\n  particles: Particle[];\r\n  clip: Clip;\r\n  startDisc: Disc;\r\n  endDisc: Disc;\r\n  rect: { width: number; height: number };\r\n  render: { width: number; height: number; dpi: number };\r\n  particleArea: {\r\n    sw?: number;\r\n    ew?: number;\r\n    h?: number;\r\n    sx?: number;\r\n    ex?: number;\r\n  };\r\n  linesCanvas?: HTMLCanvasElement;\r\n}\r\ninterface Props {\r\n  strokeColor?: string;\r\n  numberOfLines?: number;\r\n  numberOfDiscs?: number;\r\n  particleRGBColor?: [number, number, number];\r\n  class?: string;\r\n}\r\n\r\nconst props = withDefaults(defineProps<Props>(), {\r\n  strokeColor: \"#737373\",\r\n  numberOfLines: 50,\r\n  numberOfDiscs: 50,\r\n  particleRGBColor: () => [255, 255, 255],\r\n});\r\n\r\nconst canvasRef = ref<HTMLCanvasElement | null>(null);\r\nconst animationFrameIdRef = ref<number>(0);\r\nconst stateRef = ref<State>({\r\n  discs: [],\r\n  lines: [],\r\n  particles: [],\r\n  clip: {},\r\n  startDisc: { p: 0, x: 0, y: 0, w: 0, h: 0 },\r\n  endDisc: { p: 0, x: 0, y: 0, w: 0, h: 0 },\r\n  rect: { width: 0, height: 0 },\r\n  render: { width: 0, height: 0, dpi: 1 },\r\n  particleArea: {},\r\n});\r\n\r\nfunction linear(p: number) {\r\n  return p;\r\n}\r\n\r\nfunction easeInExpo(p: number) {\r\n  return p === 0 ? 0 : Math.pow(2, 10 * (p - 1));\r\n}\r\n\r\nfunction tweenValue(start: number, end: number, p: number, ease: \"inExpo\" | null = null) {\r\n  const delta = end - start;\r\n  const easeFn = ease === \"inExpo\" ? easeInExpo : linear;\r\n  return start + delta * easeFn(p);\r\n}\r\n\r\nfunction tweenDisc(disc: Disc) {\r\n  const { startDisc, endDisc } = stateRef.value;\r\n  disc.x = tweenValue(startDisc.x, endDisc.x, disc.p);\r\n  disc.y = tweenValue(startDisc.y, endDisc.y, disc.p, \"inExpo\");\r\n  disc.w = tweenValue(startDisc.w, endDisc.w, disc.p);\r\n  disc.h = tweenValue(startDisc.h, endDisc.h, disc.p);\r\n}\r\n\r\nfunction setSize() {\r\n  const canvas = canvasRef.value;\r\n  if (!canvas) return;\r\n  const rect = canvas.getBoundingClientRect();\r\n  stateRef.value.rect = { width: rect.width, height: rect.height };\r\n  stateRef.value.render = {\r\n    width: rect.width,\r\n    height: rect.height,\r\n    dpi: window.devicePixelRatio || 1,\r\n  };\r\n  canvas.width = stateRef.value.render.width * stateRef.value.render.dpi;\r\n  canvas.height = stateRef.value.render.height * stateRef.value.render.dpi;\r\n}\r\n\r\nfunction setDiscs() {\r\n  const { width, height } = stateRef.value.rect;\r\n  if (width <= 0 || height <= 0) return;\r\n\r\n  stateRef.value.discs = [];\r\n  stateRef.value.startDisc = {\r\n    p: 0,\r\n    x: width * 0.5,\r\n    y: height * 0.45,\r\n    w: width * 0.75,\r\n    h: height * 0.7,\r\n  };\r\n  stateRef.value.endDisc = {\r\n    p: 0,\r\n    x: width * 0.5,\r\n    y: height * 0.95,\r\n    w: 0,\r\n    h: 0,\r\n  };\r\n\r\n  let prevBottom = height;\r\n  stateRef.value.clip = {};\r\n\r\n  for (let i = 0; i < props.numberOfDiscs; i++) {\r\n    const p = i / props.numberOfDiscs;\r\n    const disc = { p, x: 0, y: 0, w: 0, h: 0 };\r\n    tweenDisc(disc);\r\n    const bottom = disc.y + disc.h;\r\n    if (bottom <= prevBottom) {\r\n      stateRef.value.clip = { disc: { ...disc }, i };\r\n    }\r\n    prevBottom = bottom;\r\n    stateRef.value.discs.push(disc);\r\n  }\r\n\r\n  if (stateRef.value.clip.disc) {\r\n    const clipPath = new Path2D();\r\n    const disc = stateRef.value.clip.disc;\r\n    clipPath.ellipse(disc.x, disc.y, disc.w, disc.h, 0, 0, Math.PI * 2);\r\n    clipPath.rect(disc.x - disc.w, 0, disc.w * 2, disc.y);\r\n    stateRef.value.clip.path = clipPath;\r\n  }\r\n}\r\n\r\nfunction setLines() {\r\n  const { width, height } = stateRef.value.rect;\r\n  // Ensure we have valid dimensions\r\n  if (width <= 0 || height <= 0) return;\r\n\r\n  stateRef.value.lines = [];\r\n  const linesAngle = (Math.PI * 2) / props.numberOfLines;\r\n  for (let i = 0; i < props.numberOfLines; i++) {\r\n    stateRef.value.lines.push([]);\r\n  }\r\n\r\n  stateRef.value.discs.forEach((disc: Disc) => {\r\n    for (let i = 0; i < props.numberOfLines; i++) {\r\n      const angle = i * linesAngle;\r\n      const p = {\r\n        x: disc.x + Math.cos(angle) * disc.w,\r\n        y: disc.y + Math.sin(angle) * disc.h,\r\n      };\r\n      stateRef.value.lines[i].push(p);\r\n    }\r\n  });\r\n\r\n  const offCanvas = document.createElement(\"canvas\");\r\n  // Ensure we set dimensions before getting context\r\n  offCanvas.width = Math.max(1, width); // Ensure at least 1px\r\n  offCanvas.height = Math.max(1, height); // Ensure at least 1px\r\n\r\n  const ctx = offCanvas.getContext(\"2d\");\r\n  if (!ctx || !stateRef.value.clip.path) {\r\n    stateRef.value.linesCanvas = undefined;\r\n    return;\r\n  }\r\n\r\n  // Clear the canvas first\r\n  ctx.clearRect(0, 0, offCanvas.width, offCanvas.height);\r\n\r\n  stateRef.value.lines.forEach((line: Point[]) => {\r\n    ctx.save();\r\n    let lineIsIn = false;\r\n    line.forEach((p1: Point, j: number) => {\r\n      if (j === 0) return;\r\n      const p0 = line[j - 1];\r\n      if (\r\n        !lineIsIn &&\r\n        (ctx.isPointInPath(stateRef.value.clip.path!, p1.x, p1.y) ||\r\n          ctx.isPointInStroke(stateRef.value.clip.path!, p1.x, p1.y))\r\n      ) {\r\n        lineIsIn = true;\r\n      } else if (lineIsIn) {\r\n        ctx.clip(stateRef.value.clip.path!);\r\n      }\r\n      ctx.beginPath();\r\n      ctx.moveTo(p0.x, p0.y);\r\n      ctx.lineTo(p1.x, p1.y);\r\n      ctx.strokeStyle = props.strokeColor;\r\n      ctx.lineWidth = 2;\r\n      ctx.stroke();\r\n      ctx.closePath();\r\n    });\r\n    ctx.restore();\r\n  });\r\n  stateRef.value.linesCanvas = offCanvas;\r\n}\r\n\r\nfunction initParticle(start: boolean = false): Particle {\r\n  const sx =\r\n    (stateRef.value.particleArea.sx || 0) + (stateRef.value.particleArea.sw || 0) * Math.random();\r\n  const ex =\r\n    (stateRef.value.particleArea.ex || 0) + (stateRef.value.particleArea.ew || 0) * Math.random();\r\n  const dx = ex - sx;\r\n  const y = start\r\n    ? (stateRef.value.particleArea.h || 0) * Math.random()\r\n    : stateRef.value.particleArea.h || 0;\r\n  const r = 0.5 + Math.random() * 4;\r\n  const vy = 0.5 + Math.random();\r\n  return {\r\n    x: sx,\r\n    sx,\r\n    dx,\r\n    y,\r\n    vy,\r\n    p: 0,\r\n    r,\r\n    c: `rgba(${props.particleRGBColor[0]}, ${props.particleRGBColor[1]}, ${props.particleRGBColor[2]}, ${Math.random()})`,\r\n  };\r\n}\r\n\r\nfunction setParticles() {\r\n  const { width, height } = stateRef.value.rect;\r\n  stateRef.value.particles = [];\r\n  const disc = stateRef.value.clip.disc;\r\n  if (!disc) return;\r\n  stateRef.value.particleArea = {\r\n    sw: disc.w * 0.5,\r\n    ew: disc.w * 2,\r\n    h: height * 0.85,\r\n  };\r\n  stateRef.value.particleArea.sx = (width - (stateRef.value.particleArea.sw || 0)) / 2;\r\n  stateRef.value.particleArea.ex = (width - (stateRef.value.particleArea.ew || 0)) / 2;\r\n  const totalParticles = 100;\r\n  for (let i = 0; i < totalParticles; i++) {\r\n    stateRef.value.particles.push(initParticle(true));\r\n  }\r\n}\r\n\r\nfunction drawDiscs(ctx: CanvasRenderingContext2D) {\r\n  ctx.strokeStyle = props.strokeColor;\r\n  ctx.lineWidth = 2;\r\n  const outerDisc = stateRef.value.startDisc;\r\n  ctx.beginPath();\r\n  ctx.ellipse(outerDisc.x, outerDisc.y, outerDisc.w, outerDisc.h, 0, 0, Math.PI * 2);\r\n  ctx.stroke();\r\n  ctx.closePath();\r\n  stateRef.value.discs.forEach((disc: Disc, i: number) => {\r\n    if (i % 5 !== 0) return;\r\n    if (disc.w < (stateRef.value.clip.disc?.w || 0) - 5) {\r\n      ctx.save();\r\n      ctx.clip(stateRef.value.clip.path!);\r\n    }\r\n    ctx.beginPath();\r\n    ctx.ellipse(disc.x, disc.y, disc.w, disc.h, 0, 0, Math.PI * 2);\r\n    ctx.stroke();\r\n    ctx.closePath();\r\n    if (disc.w < (stateRef.value.clip.disc?.w || 0) - 5) {\r\n      ctx.restore();\r\n    }\r\n  });\r\n}\r\n\r\nfunction drawLines(ctx: CanvasRenderingContext2D) {\r\n  if (\r\n    stateRef.value.linesCanvas &&\r\n    stateRef.value.linesCanvas.width > 0 &&\r\n    stateRef.value.linesCanvas.height > 0\r\n  ) {\r\n    ctx.drawImage(stateRef.value.linesCanvas, 0, 0);\r\n  }\r\n}\r\n\r\nfunction drawParticles(ctx: CanvasRenderingContext2D) {\r\n  ctx.save();\r\n  ctx.clip(stateRef.value.clip.path!);\r\n  stateRef.value.particles.forEach((particle: Particle) => {\r\n    ctx.fillStyle = particle.c;\r\n    ctx.beginPath();\r\n    ctx.rect(particle.x, particle.y, particle.r, particle.r);\r\n    ctx.closePath();\r\n    ctx.fill();\r\n  });\r\n  ctx.restore();\r\n}\r\n\r\nfunction moveDiscs() {\r\n  stateRef.value.discs.forEach((disc: Disc) => {\r\n    disc.p = (disc.p + 0.001) % 1;\r\n    tweenDisc(disc);\r\n  });\r\n}\r\n\r\nfunction moveParticles() {\r\n  stateRef.value.particles.forEach((particle: Particle, idx: number) => {\r\n    particle.p = 1 - particle.y / (stateRef.value.particleArea.h || 1);\r\n    particle.x = particle.sx + particle.dx * particle.p;\r\n    particle.y -= particle.vy;\r\n    if (particle.y < 0) {\r\n      stateRef.value.particles[idx] = initParticle();\r\n    }\r\n  });\r\n}\r\n\r\nfunction tick() {\r\n  const canvas = canvasRef.value;\r\n  if (!canvas) return;\r\n  const ctx = canvas.getContext(\"2d\");\r\n  if (!ctx) return;\r\n  ctx.clearRect(0, 0, canvas.width, canvas.height);\r\n  ctx.save();\r\n  ctx.scale(stateRef.value.render.dpi, stateRef.value.render.dpi);\r\n  moveDiscs();\r\n  moveParticles();\r\n  drawDiscs(ctx);\r\n  drawLines(ctx);\r\n  drawParticles(ctx);\r\n  ctx.restore();\r\n  animationFrameIdRef.value = requestAnimationFrame(tick);\r\n}\r\n\r\nfunction init() {\r\n  setSize();\r\n  setDiscs();\r\n  setLines();\r\n  setParticles();\r\n}\r\n\r\nfunction handleResize() {\r\n  setSize();\r\n  setDiscs();\r\n  setLines();\r\n  setParticles();\r\n}\r\n\r\nonMounted(() => {\r\n  nextTick(() => {\r\n    setSize();\r\n    init();\r\n    tick();\r\n    window.addEventListener(\"resize\", handleResize);\r\n  });\r\n});\r\n\r\nonBeforeUnmount(() => {\r\n  window.removeEventListener(\"resize\", handleResize);\r\n  cancelAnimationFrame(animationFrameIdRef.value);\r\n});\r\n</script>\r\n"
    }
  ],
  "fileCount": 1,
  "contentHash": "4b007140cf451f87e7478adca2e53e76b260b353"
}
