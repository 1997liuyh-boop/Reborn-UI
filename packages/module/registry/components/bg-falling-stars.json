{
  "name": "bg-falling-stars",
  "dependencies": [],
  "files": [
    {
      "path": "FallingStarsBg.vue",
      "content": "<template>\r\n  <canvas\r\n    ref=\"starsCanvas\"\r\n    :class=\"cn('absolute inset-0 w-full h-full', $props.class)\"\r\n  ></canvas>\r\n</template>\r\n\r\n<script setup lang=\"ts\">\r\nimport { onMounted, ref } from \"vue\";\r\nimport { cn } from \"@/lib/utils\";\r\n\r\ninterface Star {\r\n  x: number;\r\n  y: number;\r\n  z: number;\r\n  speed: number;\r\n}\r\n\r\nconst props = withDefaults(\r\n  defineProps<{\r\n    color?: string;\r\n    count?: number;\r\n    class?: string;\r\n  }>(),\r\n  {\r\n    color: \"#FFF\",\r\n    count: 200,\r\n  },\r\n);\r\n\r\nconst starsCanvas = ref<HTMLCanvasElement | null>(null);\r\nlet perspective: number = 0;\r\nlet stars: Star[] = [];\r\nlet ctx: CanvasRenderingContext2D | null = null;\r\n\r\nonMounted(() => {\r\n  const canvas = starsCanvas.value;\r\n  if (!canvas) return;\r\n\r\n  window.addEventListener(\"resize\", resizeCanvas);\r\n  resizeCanvas(); // Call it initially to set correct size\r\n\r\n  perspective = canvas.width / 2;\r\n  stars = [];\r\n\r\n  // Initialize stars\r\n  for (let i = 0; i < props.count; i++) {\r\n    stars.push({\r\n      x: (Math.random() - 0.5) * 2 * canvas.width,\r\n      y: (Math.random() - 0.5) * 2 * canvas.height,\r\n      z: Math.random() * canvas.width,\r\n      speed: Math.random() * 5 + 2, // Speed for falling effect\r\n    });\r\n  }\r\n\r\n  animate(); // Start animation\r\n});\r\n\r\nfunction hexToRgb() {\r\n  let hex = props.color.replace(/^#/, \"\");\r\n\r\n  // If the hex code is 3 characters, expand it to 6 characters\r\n  if (hex.length === 3) {\r\n    hex = hex\r\n      .split(\"\")\r\n      .map((char) => char + char)\r\n      .join(\"\");\r\n  }\r\n\r\n  // Parse the r, g, b values from the hex string\r\n  const bigint = parseInt(hex, 16);\r\n  const r = (bigint >> 16) & 255; // Extract the red component\r\n  const g = (bigint >> 8) & 255; // Extract the green component\r\n  const b = bigint & 255; // Extract the blue component\r\n\r\n  // Return the RGB values as a string separated by spaces\r\n  return {\r\n    r,\r\n    g,\r\n    b,\r\n  };\r\n}\r\n\r\n// Function to draw a star with a sharp line and blurred trail\r\nfunction drawStar(star: Star) {\r\n  const canvas = starsCanvas.value;\r\n  if (!canvas) return;\r\n\r\n  ctx = canvas.getContext(\"2d\");\r\n  if (!ctx) return;\r\n\r\n  const scale = perspective / (perspective + star.z); // 3D perspective scale\r\n  const x2d = canvas.width / 2 + star.x * scale;\r\n  const y2d = canvas.height / 2 + star.y * scale;\r\n  const size = Math.max(scale * 3, 0.5); // Size based on perspective\r\n\r\n  // Previous position for a trail effect\r\n  const prevScale = perspective / (perspective + star.z + star.speed * 15); // Longer trail distance\r\n  const xPrev = canvas.width / 2 + star.x * prevScale;\r\n  const yPrev = canvas.height / 2 + star.y * prevScale;\r\n\r\n  const rgb = hexToRgb();\r\n\r\n  // Draw blurred trail (longer, with low opacity)\r\n  ctx.save(); // Save current context state for restoring later\r\n  ctx.strokeStyle = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, 0.2)`;\r\n  ctx.lineWidth = size * 2.5; // Thicker trail for a blur effect\r\n  ctx.shadowBlur = 35; // Add blur to the trail\r\n  ctx.shadowColor = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, 0.8)`;\r\n  ctx.beginPath();\r\n  ctx.moveTo(x2d, y2d);\r\n  ctx.lineTo(xPrev, yPrev); // Longer trail\r\n  ctx.stroke();\r\n  ctx.restore(); // Restore context state to remove blur from the main line\r\n\r\n  // Draw sharp line (no blur)\r\n  ctx.strokeStyle = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, 0.6)`;\r\n  ctx.lineWidth = size; // The line width is the same as the star's size\r\n  ctx.beginPath();\r\n  ctx.moveTo(x2d, y2d);\r\n  ctx.lineTo(xPrev, yPrev); // Sharp trail\r\n  ctx.stroke();\r\n\r\n  // Draw the actual star (dot)\r\n  ctx.fillStyle = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, 1)`;\r\n  ctx.beginPath();\r\n  ctx.arc(x2d, y2d, size / 4, 0, Math.PI * 2); // Dot with size matching the width\r\n  ctx.fill();\r\n}\r\n\r\n// Function to animate the stars\r\nfunction animate() {\r\n  const canvas = starsCanvas.value;\r\n  if (!canvas) return;\r\n\r\n  ctx = canvas.getContext(\"2d\");\r\n  if (!ctx) return;\r\n\r\n  ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear canvas for each frame\r\n\r\n  stars.forEach((star) => {\r\n    drawStar(star);\r\n\r\n    // Move star towards the screen (decrease z)\r\n    star.z -= star.speed;\r\n\r\n    // Reset star when it reaches the viewer (z = 0)\r\n    if (star.z <= 0) {\r\n      star.z = canvas.width;\r\n      star.x = (Math.random() - 0.5) * 2 * canvas.width;\r\n      star.y = (Math.random() - 0.5) * 2 * canvas.height;\r\n    }\r\n  });\r\n\r\n  requestAnimationFrame(animate); // Continue animation\r\n}\r\n\r\n// Set canvas to full screen\r\nfunction resizeCanvas() {\r\n  const canvas = starsCanvas.value;\r\n  if (!canvas) return;\r\n\r\n  canvas.width = canvas.clientWidth;\r\n  canvas.height = canvas.clientHeight;\r\n}\r\n</script>\r\n"
    },
    {
      "path": "index.ts",
      "content": "export { default as FallingStarsBg } from \"./FallingStarsBg.vue\";\r\n"
    }
  ],
  "fileCount": 2,
  "contentHash": "7ea35cdcc4e88173d2659eb2914f0455153a5dd4"
}
